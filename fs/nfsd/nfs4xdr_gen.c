// SPDX-License-Identifier: GPL-2.0
// Generated by xdrgen. Manual edits will be lost.
// XDR specification file: ../../Documentation/sunrpc/xdr/nfs4_1.x
// XDR specification modification time: Thu Jan  8 23:12:07 2026

#include <linux/sunrpc/svc.h>

#include "nfs4xdr_gen.h"

static bool __maybe_unused
xdrgen_decode_int64_t(struct xdr_stream *xdr, int64_t *ptr)
{
	return xdrgen_decode_hyper(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_uint32_t(struct xdr_stream *xdr, uint32_t *ptr)
{
	return xdrgen_decode_unsigned_int(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_bitmap4(struct xdr_stream *xdr, bitmap4 *ptr)
{
	if (xdr_stream_decode_u32(xdr, &ptr->count) < 0)
		return false;
	for (u32 i = 0; i < ptr->count; i++)
		if (!xdrgen_decode_uint32_t(xdr, &ptr->element[i]))
			return false;
	return true;
}

static bool __maybe_unused
xdrgen_decode_utf8string(struct xdr_stream *xdr, utf8string *ptr)
{
	return xdrgen_decode_opaque(xdr, ptr, 0);
}

static bool __maybe_unused
xdrgen_decode_utf8str_cis(struct xdr_stream *xdr, utf8str_cis *ptr)
{
	return xdrgen_decode_utf8string(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_utf8str_cs(struct xdr_stream *xdr, utf8str_cs *ptr)
{
	return xdrgen_decode_utf8string(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_utf8str_mixed(struct xdr_stream *xdr, utf8str_mixed *ptr)
{
	return xdrgen_decode_utf8string(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_nfstime4(struct xdr_stream *xdr, struct nfstime4 *ptr)
{
	if (!xdrgen_decode_int64_t(xdr, &ptr->seconds))
		return false;
	if (!xdrgen_decode_uint32_t(xdr, &ptr->nseconds))
		return false;
	return true;
}

static bool __maybe_unused
xdrgen_decode_fattr4_offline(struct xdr_stream *xdr, fattr4_offline *ptr)
{
	return xdrgen_decode_bool(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_open_arguments4(struct xdr_stream *xdr, struct open_arguments4 *ptr)
{
	if (!xdrgen_decode_bitmap4(xdr, &ptr->oa_share_access))
		return false;
	if (!xdrgen_decode_bitmap4(xdr, &ptr->oa_share_deny))
		return false;
	if (!xdrgen_decode_bitmap4(xdr, &ptr->oa_share_access_want))
		return false;
	if (!xdrgen_decode_bitmap4(xdr, &ptr->oa_open_claim))
		return false;
	if (!xdrgen_decode_bitmap4(xdr, &ptr->oa_create_mode))
		return false;
	return true;
}

static bool __maybe_unused
xdrgen_decode_open_args_share_access4(struct xdr_stream *xdr, open_args_share_access4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case OPEN_ARGS_SHARE_ACCESS_READ:
	case OPEN_ARGS_SHARE_ACCESS_WRITE:
	case OPEN_ARGS_SHARE_ACCESS_BOTH:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

static bool __maybe_unused
xdrgen_decode_open_args_share_deny4(struct xdr_stream *xdr, open_args_share_deny4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case OPEN_ARGS_SHARE_DENY_NONE:
	case OPEN_ARGS_SHARE_DENY_READ:
	case OPEN_ARGS_SHARE_DENY_WRITE:
	case OPEN_ARGS_SHARE_DENY_BOTH:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

static bool __maybe_unused
xdrgen_decode_open_args_share_access_want4(struct xdr_stream *xdr, open_args_share_access_want4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case OPEN_ARGS_SHARE_ACCESS_WANT_ANY_DELEG:
	case OPEN_ARGS_SHARE_ACCESS_WANT_NO_DELEG:
	case OPEN_ARGS_SHARE_ACCESS_WANT_CANCEL:
	case OPEN_ARGS_SHARE_ACCESS_WANT_SIGNAL_DELEG_WHEN_RESRC_AVAIL:
	case OPEN_ARGS_SHARE_ACCESS_WANT_PUSH_DELEG_WHEN_UNCONTENDED:
	case OPEN_ARGS_SHARE_ACCESS_WANT_DELEG_TIMESTAMPS:
	case OPEN_ARGS_SHARE_ACCESS_WANT_OPEN_XOR_DELEGATION:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

static bool __maybe_unused
xdrgen_decode_open_args_open_claim4(struct xdr_stream *xdr, open_args_open_claim4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case OPEN_ARGS_OPEN_CLAIM_NULL:
	case OPEN_ARGS_OPEN_CLAIM_PREVIOUS:
	case OPEN_ARGS_OPEN_CLAIM_DELEGATE_CUR:
	case OPEN_ARGS_OPEN_CLAIM_DELEGATE_PREV:
	case OPEN_ARGS_OPEN_CLAIM_FH:
	case OPEN_ARGS_OPEN_CLAIM_DELEG_CUR_FH:
	case OPEN_ARGS_OPEN_CLAIM_DELEG_PREV_FH:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

static bool __maybe_unused
xdrgen_decode_open_args_createmode4(struct xdr_stream *xdr, open_args_createmode4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case OPEN_ARGS_CREATEMODE_UNCHECKED4:
	case OPEN_ARGS_CREATE_MODE_GUARDED:
	case OPEN_ARGS_CREATEMODE_EXCLUSIVE4:
	case OPEN_ARGS_CREATE_MODE_EXCLUSIVE4_1:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

bool
xdrgen_decode_fattr4_open_arguments(struct xdr_stream *xdr, fattr4_open_arguments *ptr)
{
	return xdrgen_decode_open_arguments4(xdr, ptr);
}

/*
 * Determine what OPEN supports.
 */

bool
xdrgen_decode_fattr4_time_deleg_access(struct xdr_stream *xdr, fattr4_time_deleg_access *ptr)
{
	return xdrgen_decode_nfstime4(xdr, ptr);
}

bool
xdrgen_decode_fattr4_time_deleg_modify(struct xdr_stream *xdr, fattr4_time_deleg_modify *ptr)
{
	return xdrgen_decode_nfstime4(xdr, ptr);
}

/*
 * New RECOMMENDED Attribute for
 * delegation caching of times
 */

static bool __maybe_unused
xdrgen_decode_open_delegation_type4(struct xdr_stream *xdr, open_delegation_type4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case OPEN_DELEGATE_NONE:
	case OPEN_DELEGATE_READ:
	case OPEN_DELEGATE_WRITE:
	case OPEN_DELEGATE_NONE_EXT:
	case OPEN_DELEGATE_READ_ATTRS_DELEG:
	case OPEN_DELEGATE_WRITE_ATTRS_DELEG:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

bool
xdrgen_decode_aclmodel4(struct xdr_stream *xdr, aclmodel4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case ACL_MODEL_NFS4:
	case ACL_MODEL_POSIX_DRAFT:
	case ACL_MODEL_NONE:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

bool
xdrgen_decode_aclscope4(struct xdr_stream *xdr, aclscope4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case ACL_SCOPE_FILE_OBJECT:
	case ACL_SCOPE_FILE_SYSTEM:
	case ACL_SCOPE_SERVER:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

bool
xdrgen_decode_posixacetag4(struct xdr_stream *xdr, posixacetag4 *ptr)
{
	u32 val;

	if (xdr_stream_decode_u32(xdr, &val) < 0)
		return false;
	/* Compiler may optimize to a range check for dense enums */
	switch (val) {
	case POSIXACE4_TAG_USER_OBJ:
	case POSIXACE4_TAG_USER:
	case POSIXACE4_TAG_GROUP_OBJ:
	case POSIXACE4_TAG_GROUP:
	case POSIXACE4_TAG_MASK:
	case POSIXACE4_TAG_OTHER:
		break;
	default:
		return false;
	}
	*ptr = val;
	return true;
}

bool
xdrgen_decode_posixaceperm4(struct xdr_stream *xdr, posixaceperm4 *ptr)
{
	return xdrgen_decode_uint32_t(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_posixace4(struct xdr_stream *xdr, struct posixace4 *ptr)
{
	if (!xdrgen_decode_posixacetag4(xdr, &ptr->tag))
		return false;
	if (!xdrgen_decode_posixaceperm4(xdr, &ptr->perm))
		return false;
	if (!xdrgen_decode_utf8str_mixed(xdr, &ptr->who))
		return false;
	return true;
}

static bool __maybe_unused
xdrgen_decode_fattr4_acl_trueform(struct xdr_stream *xdr, fattr4_acl_trueform *ptr)
{
	return xdrgen_decode_aclmodel4(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_fattr4_acl_trueform_scope(struct xdr_stream *xdr, fattr4_acl_trueform_scope *ptr)
{
	return xdrgen_decode_aclscope4(xdr, ptr);
}

static bool __maybe_unused
xdrgen_decode_fattr4_posix_default_acl(struct xdr_stream *xdr, fattr4_posix_default_acl *ptr)
{
	if (xdr_stream_decode_u32(xdr, &ptr->count) < 0)
		return false;
	for (u32 i = 0; i < ptr->count; i++)
		if (!xdrgen_decode_posixace4(xdr, &ptr->element[i]))
			return false;
	return true;
}

static bool __maybe_unused
xdrgen_decode_fattr4_posix_access_acl(struct xdr_stream *xdr, fattr4_posix_access_acl *ptr)
{
	if (xdr_stream_decode_u32(xdr, &ptr->count) < 0)
		return false;
	for (u32 i = 0; i < ptr->count; i++)
		if (!xdrgen_decode_posixace4(xdr, &ptr->element[i]))
			return false;
	return true;
}

/*
 * New for POSIX ACL extension
 */

static bool __maybe_unused
xdrgen_encode_int64_t(struct xdr_stream *xdr, const int64_t value)
{
	return xdrgen_encode_hyper(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_uint32_t(struct xdr_stream *xdr, const uint32_t value)
{
	return xdrgen_encode_unsigned_int(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_bitmap4(struct xdr_stream *xdr, const bitmap4 value)
{
	if (xdr_stream_encode_u32(xdr, value.count) != XDR_UNIT)
		return false;
	for (u32 i = 0; i < value.count; i++)
		if (!xdrgen_encode_uint32_t(xdr, value.element[i]))
			return false;
	return true;
}

static bool __maybe_unused
xdrgen_encode_utf8string(struct xdr_stream *xdr, const utf8string value)
{
	return xdr_stream_encode_opaque(xdr, value.data, value.len) >= 0;
}

static bool __maybe_unused
xdrgen_encode_utf8str_cis(struct xdr_stream *xdr, const utf8str_cis value)
{
	return xdrgen_encode_utf8string(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_utf8str_cs(struct xdr_stream *xdr, const utf8str_cs value)
{
	return xdrgen_encode_utf8string(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_utf8str_mixed(struct xdr_stream *xdr, const utf8str_mixed value)
{
	return xdrgen_encode_utf8string(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_nfstime4(struct xdr_stream *xdr, const struct nfstime4 *value)
{
	if (!xdrgen_encode_int64_t(xdr, value->seconds))
		return false;
	if (!xdrgen_encode_uint32_t(xdr, value->nseconds))
		return false;
	return true;
}

static bool __maybe_unused
xdrgen_encode_fattr4_offline(struct xdr_stream *xdr, const fattr4_offline value)
{
	return xdrgen_encode_bool(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_open_arguments4(struct xdr_stream *xdr, const struct open_arguments4 *value)
{
	if (!xdrgen_encode_bitmap4(xdr, value->oa_share_access))
		return false;
	if (!xdrgen_encode_bitmap4(xdr, value->oa_share_deny))
		return false;
	if (!xdrgen_encode_bitmap4(xdr, value->oa_share_access_want))
		return false;
	if (!xdrgen_encode_bitmap4(xdr, value->oa_open_claim))
		return false;
	if (!xdrgen_encode_bitmap4(xdr, value->oa_create_mode))
		return false;
	return true;
}

static bool __maybe_unused
xdrgen_encode_open_args_share_access4(struct xdr_stream *xdr, open_args_share_access4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

static bool __maybe_unused
xdrgen_encode_open_args_share_deny4(struct xdr_stream *xdr, open_args_share_deny4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

static bool __maybe_unused
xdrgen_encode_open_args_share_access_want4(struct xdr_stream *xdr, open_args_share_access_want4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

static bool __maybe_unused
xdrgen_encode_open_args_open_claim4(struct xdr_stream *xdr, open_args_open_claim4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

static bool __maybe_unused
xdrgen_encode_open_args_createmode4(struct xdr_stream *xdr, open_args_createmode4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

bool
xdrgen_encode_fattr4_open_arguments(struct xdr_stream *xdr, const fattr4_open_arguments *value)
{
	return xdrgen_encode_open_arguments4(xdr, value);
}

bool
xdrgen_encode_fattr4_time_deleg_access(struct xdr_stream *xdr, const fattr4_time_deleg_access *value)
{
	return xdrgen_encode_nfstime4(xdr, value);
}

bool
xdrgen_encode_fattr4_time_deleg_modify(struct xdr_stream *xdr, const fattr4_time_deleg_modify *value)
{
	return xdrgen_encode_nfstime4(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_open_delegation_type4(struct xdr_stream *xdr, open_delegation_type4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

bool
xdrgen_encode_aclmodel4(struct xdr_stream *xdr, aclmodel4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

bool
xdrgen_encode_aclscope4(struct xdr_stream *xdr, aclscope4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

bool
xdrgen_encode_posixacetag4(struct xdr_stream *xdr, posixacetag4 value)
{
	return xdr_stream_encode_u32(xdr, value) == XDR_UNIT;
}

bool
xdrgen_encode_posixaceperm4(struct xdr_stream *xdr, const posixaceperm4 value)
{
	return xdrgen_encode_uint32_t(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_posixace4(struct xdr_stream *xdr, const struct posixace4 *value)
{
	if (!xdrgen_encode_posixacetag4(xdr, value->tag))
		return false;
	if (!xdrgen_encode_posixaceperm4(xdr, value->perm))
		return false;
	if (!xdrgen_encode_utf8str_mixed(xdr, value->who))
		return false;
	return true;
}

static bool __maybe_unused
xdrgen_encode_fattr4_acl_trueform(struct xdr_stream *xdr, const fattr4_acl_trueform value)
{
	return xdrgen_encode_aclmodel4(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_fattr4_acl_trueform_scope(struct xdr_stream *xdr, const fattr4_acl_trueform_scope value)
{
	return xdrgen_encode_aclscope4(xdr, value);
}

static bool __maybe_unused
xdrgen_encode_fattr4_posix_default_acl(struct xdr_stream *xdr, const fattr4_posix_default_acl value)
{
	if (xdr_stream_encode_u32(xdr, value.count) != XDR_UNIT)
		return false;
	for (u32 i = 0; i < value.count; i++)
		if (!xdrgen_encode_posixace4(xdr, &value.element[i]))
			return false;
	return true;
}

static bool __maybe_unused
xdrgen_encode_fattr4_posix_access_acl(struct xdr_stream *xdr, const fattr4_posix_access_acl value)
{
	if (xdr_stream_encode_u32(xdr, value.count) != XDR_UNIT)
		return false;
	for (u32 i = 0; i < value.count; i++)
		if (!xdrgen_encode_posixace4(xdr, &value.element[i]))
			return false;
	return true;
}
