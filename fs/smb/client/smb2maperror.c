// SPDX-License-Identifier: LGPL-2.1
/*
 *
 *   Functions which do error mapping of SMB2 status codes to POSIX errors
 *
 *   Copyright (C) International Business Machines  Corp., 2009
 *   Author(s): Steve French (sfrench@us.ibm.com)
 *
 */
#include <linux/errno.h>
#include "cifsglob.h"
#include "cifsproto.h"
#include "cifs_debug.h"
#include "smb2proto.h"
#include "smb2glob.h"
#include "../common/smb2status.h"
#include "trace.h"

struct status_to_posix_error {
	__u32 smb2_status;
	int posix_error;
	char *status_string;
};

static const struct status_to_posix_error smb2_error_map_table[] = {
/*
 * Automatically generated by the `gen_smb2_mapping` script,
 * sorted by NT status code (cpu-endian, ascending)
 */
#include "smb2_mapping_table.c"
};

int
map_smb2_to_linux_error(char *buf, bool log_err)
{
	struct smb2_hdr *shdr = (struct smb2_hdr *)buf;
	unsigned int i;
	int rc = -EIO;
	__le32 smb2err = shdr->Status;

	if (smb2err == 0) {
		trace_smb3_cmd_done(le32_to_cpu(shdr->Id.SyncId.TreeId),
			      le64_to_cpu(shdr->SessionId),
			      le16_to_cpu(shdr->Command),
			      le64_to_cpu(shdr->MessageId));
		return 0;
	}

	log_err = (log_err && (smb2err != STATUS_MORE_PROCESSING_REQUIRED) &&
		   (smb2err != STATUS_END_OF_FILE)) ||
		  (cifsFYI & CIFS_RC);

	for (i = 0; i < sizeof(smb2_error_map_table) /
			sizeof(struct status_to_posix_error); i++) {
		if (smb2_error_map_table[i].smb2_status == smb2err) {
			if (log_err)
				pr_notice("Status code returned 0x%08x %s\n", smb2err,
					  smb2_error_map_table[i].status_string);
			rc = smb2_error_map_table[i].posix_error;
			break;
		}
	}

	/* on error mapping not found  - return EIO */

	cifs_dbg(FYI, "Mapping SMB2 status code 0x%08x to POSIX err %d\n",
		 __le32_to_cpu(smb2err), rc);

	trace_smb3_cmd_err(le32_to_cpu(shdr->Id.SyncId.TreeId),
			   le64_to_cpu(shdr->SessionId),
			   le16_to_cpu(shdr->Command),
			   le64_to_cpu(shdr->MessageId),
			   le32_to_cpu(smb2err), rc);
	if (rc == -EIO)
		smb_EIO1(smb_eio_trace_smb2_received_error, le32_to_cpu(smb2err));
	return rc;
}
