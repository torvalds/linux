// SPDX-License-Identifier: GPL-2.0-or-later
/*******************************************************************************
 * This file contains tcm implementation using v4 configfs fabric infrastructure
 * for QLogic target mode HBAs
 *
 * (c) Copyright 2010-2013 Datera, Inc.
 *
 * Author: Nicholas A. Bellinger <nab@daterainc.com>
 *
 * tcm_qla2xxx_parse_wwn() and tcm_qla2xxx_format_wwn() contains code from
 * the TCM_FC / Open-FCoE.org fabric module.
 *
 * Copyright (c) 2010 Cisco Systems, Inc
 *
 ****************************************************************************/


#include <linux/module.h>
#include <linux/utsname.h>
#include <linux/vmalloc.h>
#include <linux/list.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/string.h>
#include <linux/configfs.h>
#include <linux/ctype.h>
#include <asm/unaligned.h>
#include <scsi/scsi_host.h>
#include <target/target_core_base.h>
#include <target/target_core_fabric.h>

#include "qla_def.h"
#include "qla_target.h"
#include "tcm_qla2xxx.h"

static struct workqueue_struct *tcm_qla2xxx_free_wq;

/*
 * Parse WWN.
 * If strict, we require lower-case hex and colon separators to be sure
 * the name is the same as what would be generated by ft_format_wwn()
 * so the name and wwn are mapped one-to-one.
 */
static ssize_t tcm_qla2xxx_parse_wwn(const char *name, u64 *wwn, int strict)
{
	const char *cp;
	char c;
	u32 nibble;
	u32 byte = 0;
	u32 pos = 0;
	u32 err;

	*wwn = 0;
	for (cp = name; cp < &name[TCM_QLA2XXX_NAMELEN - 1]; cp++) {
		c = *cp;
		if (c == '\n' && cp[1] == '\0')
			continue;
		if (strict && pos++ == 2 && byte++ < 7) {
			pos = 0;
			if (c == ':')
				continue;
			err = 1;
			goto fail;
		}
		if (c == '\0') {
			err = 2;
			if (strict && byte != 8)
				goto fail;
			return cp - name;
		}
		err = 3;
		if (isdigit(c))
			nibble = c - '0';
		else if (isxdigit(c) && (islower(c) || !strict))
			nibble = tolower(c) - 'a' + 10;
		else
			goto fail;
		*wwn = (*wwn << 4) | nibble;
	}
	err = 4;
fail:
	pr_debug("err %u len %zu pos %u byte %u\n",
			err, cp - name, pos, byte);
	return -1;
}

static ssize_t tcm_qla2xxx_format_wwn(char *buf, size_t len, u64 wwn)
{
	u8 b[8];

	put_unaligned_be64(wwn, b);
	return snprintf(buf, len,
		"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x",
		b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);
}

/*
 * From drivers/scsi/scsi_transport_fc.c:fc_parse_wwn
 */
static int tcm_qla2xxx_npiv_extract_wwn(const char *ns, u64 *nm)
{
	unsigned int i, j;
	u8 wwn[8];

	memset(wwn, 0, sizeof(wwn));

	/* Validate and store the new name */
	for (i = 0, j = 0; i < 16; i++) {
		int value;

		value = hex_to_bin(*ns++);
		if (value >= 0)
			j = (j << 4) | value;
		else
			return -EINVAL;

		if (i % 2) {
			wwn[i/2] = j & 0xff;
			j = 0;
		}
	}

	*nm = wwn_to_u64(wwn);
	return 0;
}

/*
 * This parsing logic follows drivers/scsi/scsi_transport_fc.c:
 * store_fc_host_vport_create()
 */
static int tcm_qla2xxx_npiv_parse_wwn(
	const char *name,
	size_t count,
	u64 *wwpn,
	u64 *wwnn)
{
	unsigned int cnt = count;
	int rc;

	*wwpn = 0;
	*wwnn = 0;

	/* count may include a LF at end of string */
	if (name[cnt-1] == '\n' || name[cnt-1] == 0)
		cnt--;

	/* validate we have enough characters for WWPN */
	if ((cnt != (16+1+16)) || (name[16] != ':'))
		return -EINVAL;

	rc = tcm_qla2xxx_npiv_extract_wwn(&name[0], wwpn);
	if (rc != 0)
		return rc;

	rc = tcm_qla2xxx_npiv_extract_wwn(&name[17], wwnn);
	if (rc != 0)
		return rc;

	return 0;
}

static char *tcm_qla2xxx_get_fabric_wwn(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;

	return lport->lport_naa_name;
}

static u16 tcm_qla2xxx_get_tag(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	return tpg->lport_tpgt;
}

static int tcm_qla2xxx_check_demo_mode(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return tpg->tpg_attrib.generate_node_acls;
}

static int tcm_qla2xxx_check_demo_mode_cache(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return tpg->tpg_attrib.cache_dynamic_acls;
}

static int tcm_qla2xxx_check_demo_write_protect(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return tpg->tpg_attrib.demo_mode_write_protect;
}

static int tcm_qla2xxx_check_prod_write_protect(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return tpg->tpg_attrib.prod_mode_write_protect;
}

static int tcm_qla2xxx_check_demo_mode_login_only(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return tpg->tpg_attrib.demo_mode_login_only;
}

static int tcm_qla2xxx_check_prot_fabric_only(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return tpg->tpg_attrib.fabric_prot_type;
}

static u32 tcm_qla2xxx_tpg_get_inst_index(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return tpg->lport_tpgt;
}

static void tcm_qla2xxx_complete_mcmd(struct work_struct *work)
{
	struct qla_tgt_mgmt_cmd *mcmd = container_of(work,
			struct qla_tgt_mgmt_cmd, free_work);

	transport_generic_free_cmd(&mcmd->se_cmd, 0);
}

/*
 * Called from qla_target_template->free_mcmd(), and will call
 * tcm_qla2xxx_release_cmd() via normal struct target_core_fabric_ops
 * release callback.  qla_hw_data->hardware_lock is expected to be held
 */
static void tcm_qla2xxx_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd)
{
	if (!mcmd)
		return;
	INIT_WORK(&mcmd->free_work, tcm_qla2xxx_complete_mcmd);
	queue_work(tcm_qla2xxx_free_wq, &mcmd->free_work);
}

static void tcm_qla2xxx_complete_free(struct work_struct *work)
{
	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);
	unsigned long flags;

	cmd->cmd_in_wq = 0;

	WARN_ON(cmd->trc_flags & TRC_CMD_FREE);

	/* To do: protect all tgt_counters manipulations with proper locking. */
	cmd->qpair->tgt_counters.qla_core_ret_sta_ctio++;
	cmd->trc_flags |= TRC_CMD_FREE;
	cmd->cmd_sent_to_fw = 0;

	spin_lock_irqsave(&cmd->sess->sess_cmd_lock, flags);
	list_del_init(&cmd->sess_cmd_list);
	spin_unlock_irqrestore(&cmd->sess->sess_cmd_lock, flags);

	transport_generic_free_cmd(&cmd->se_cmd, 0);
}

static struct qla_tgt_cmd *tcm_qla2xxx_get_cmd(struct fc_port *sess)
{
	struct se_session *se_sess = sess->se_sess;
	struct qla_tgt_cmd *cmd;
	int tag, cpu;

	tag = sbitmap_queue_get(&se_sess->sess_tag_pool, &cpu);
	if (tag < 0)
		return NULL;

	cmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];
	memset(cmd, 0, sizeof(struct qla_tgt_cmd));
	cmd->se_cmd.map_tag = tag;
	cmd->se_cmd.map_cpu = cpu;

	return cmd;
}

static void tcm_qla2xxx_rel_cmd(struct qla_tgt_cmd *cmd)
{
	target_free_tag(cmd->sess->se_sess, &cmd->se_cmd);
}

/*
 * Called from qla_target_template->free_cmd(), and will call
 * tcm_qla2xxx_release_cmd via normal struct target_core_fabric_ops
 * release callback.  qla_hw_data->hardware_lock is expected to be held
 */
static void tcm_qla2xxx_free_cmd(struct qla_tgt_cmd *cmd)
{
	cmd->qpair->tgt_counters.core_qla_free_cmd++;
	cmd->cmd_in_wq = 1;

	WARN_ON(cmd->trc_flags & TRC_CMD_DONE);
	cmd->trc_flags |= TRC_CMD_DONE;

	INIT_WORK(&cmd->work, tcm_qla2xxx_complete_free);
	queue_work_on(smp_processor_id(), tcm_qla2xxx_free_wq, &cmd->work);
}

/*
 * Called from struct target_core_fabric_ops->check_stop_free() context
 */
static int tcm_qla2xxx_check_stop_free(struct se_cmd *se_cmd)
{
	struct qla_tgt_cmd *cmd;

	if ((se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) == 0) {
		cmd = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);
		cmd->trc_flags |= TRC_CMD_CHK_STOP;
	}

	return target_put_sess_cmd(se_cmd);
}

/* tcm_qla2xxx_release_cmd - Callback from TCM Core to release underlying
 * fabric descriptor @se_cmd command to release
 */
static void tcm_qla2xxx_release_cmd(struct se_cmd *se_cmd)
{
	struct qla_tgt_cmd *cmd;

	if (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) {
		struct qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,
				struct qla_tgt_mgmt_cmd, se_cmd);
		qlt_free_mcmd(mcmd);
		return;
	}
	cmd = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);

	if (WARN_ON(cmd->cmd_sent_to_fw))
		return;

	qlt_free_cmd(cmd);
}

static void tcm_qla2xxx_release_session(struct kref *kref)
{
	struct fc_port  *sess = container_of(kref,
	    struct fc_port, sess_kref);

	qlt_unreg_sess(sess);
}

static void tcm_qla2xxx_put_sess(struct fc_port *sess)
{
	if (!sess)
		return;

	kref_put(&sess->sess_kref, tcm_qla2xxx_release_session);
}

static void tcm_qla2xxx_close_session(struct se_session *se_sess)
{
	struct fc_port *sess = se_sess->fabric_sess_ptr;

	BUG_ON(!sess);

	target_stop_session(se_sess);

	sess->explicit_logout = 1;
	tcm_qla2xxx_put_sess(sess);
}

static u32 tcm_qla2xxx_sess_get_index(struct se_session *se_sess)
{
	return 0;
}

static int tcm_qla2xxx_write_pending(struct se_cmd *se_cmd)
{
	struct qla_tgt_cmd *cmd = container_of(se_cmd,
				struct qla_tgt_cmd, se_cmd);

	if (cmd->aborted) {
		/* Cmd can loop during Q-full.  tcm_qla2xxx_aborted_task
		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task
		 * already kick start the free.
		 */
		pr_debug("write_pending aborted cmd[%p] refcount %d "
			"transport_state %x, t_state %x, se_cmd_flags %x\n",
			cmd, kref_read(&cmd->se_cmd.cmd_kref),
			cmd->se_cmd.transport_state,
			cmd->se_cmd.t_state,
			cmd->se_cmd.se_cmd_flags);
		transport_generic_request_failure(&cmd->se_cmd,
			TCM_CHECK_CONDITION_ABORT_CMD);
		return 0;
	}
	cmd->trc_flags |= TRC_XFR_RDY;
	cmd->bufflen = se_cmd->data_length;
	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);

	cmd->sg_cnt = se_cmd->t_data_nents;
	cmd->sg = se_cmd->t_data_sg;

	cmd->prot_sg_cnt = se_cmd->t_prot_nents;
	cmd->prot_sg = se_cmd->t_prot_sg;
	cmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;
	se_cmd->pi_err = 0;

	/*
	 * qla_target.c:qlt_rdy_to_xfer() will call dma_map_sg() to setup
	 * the SGL mappings into PCIe memory for incoming FCP WRITE data.
	 */
	return qlt_rdy_to_xfer(cmd);
}

static void tcm_qla2xxx_set_default_node_attrs(struct se_node_acl *nacl)
{
	return;
}

static int tcm_qla2xxx_get_cmd_state(struct se_cmd *se_cmd)
{
	if (!(se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)) {
		struct qla_tgt_cmd *cmd = container_of(se_cmd,
				struct qla_tgt_cmd, se_cmd);
		return cmd->state;
	}

	return 0;
}

/*
 * Called from process context in qla_target.c:qlt_do_work() code
 */
static int tcm_qla2xxx_handle_cmd(scsi_qla_host_t *vha, struct qla_tgt_cmd *cmd,
	unsigned char *cdb, uint32_t data_length, int fcp_task_attr,
	int data_dir, int bidi)
{
	struct se_cmd *se_cmd = &cmd->se_cmd;
	struct se_session *se_sess;
	struct fc_port *sess;
#ifdef CONFIG_TCM_QLA2XXX_DEBUG
	struct se_portal_group *se_tpg;
	struct tcm_qla2xxx_tpg *tpg;
#endif
	int rc, target_flags = TARGET_SCF_ACK_KREF;
	unsigned long flags;

	if (bidi)
		target_flags |= TARGET_SCF_BIDI_OP;

	if (se_cmd->cpuid != WORK_CPU_UNBOUND)
		target_flags |= TARGET_SCF_USE_CPUID;

	sess = cmd->sess;
	if (!sess) {
		pr_err("Unable to locate struct fc_port from qla_tgt_cmd\n");
		return -EINVAL;
	}

	se_sess = sess->se_sess;
	if (!se_sess) {
		pr_err("Unable to locate active struct se_session\n");
		return -EINVAL;
	}

#ifdef CONFIG_TCM_QLA2XXX_DEBUG
	se_tpg = se_sess->se_tpg;
	tpg = container_of(se_tpg, struct tcm_qla2xxx_tpg, se_tpg);
	if (unlikely(tpg->tpg_attrib.jam_host)) {
		/* return, and dont run target_submit_cmd,discarding command */
		return 0;
	}
#endif
	cmd->qpair->tgt_counters.qla_core_sbt_cmd++;

	spin_lock_irqsave(&sess->sess_cmd_lock, flags);
	list_add_tail(&cmd->sess_cmd_list, &sess->sess_cmd_list);
	spin_unlock_irqrestore(&sess->sess_cmd_lock, flags);

	rc = target_init_cmd(se_cmd, se_sess, &cmd->sense_buffer[0],
			     cmd->unpacked_lun, data_length, fcp_task_attr,
			     data_dir, target_flags);
	if (rc)
		return rc;

	if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
			       GFP_KERNEL))
		return 0;

	target_submit(se_cmd);
	return 0;
}

static void tcm_qla2xxx_handle_data_work(struct work_struct *work)
{
	struct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);

	/*
	 * Ensure that the complete FCP WRITE payload has been received.
	 * Otherwise return an exception via CHECK_CONDITION status.
	 */
	cmd->cmd_in_wq = 0;
	cmd->cmd_sent_to_fw = 0;
	if (cmd->aborted) {
		transport_generic_request_failure(&cmd->se_cmd,
			TCM_CHECK_CONDITION_ABORT_CMD);
		return;
	}

	cmd->qpair->tgt_counters.qla_core_ret_ctio++;
	if (!cmd->write_data_transferred) {
		switch (cmd->dif_err_code) {
		case DIF_ERR_GRD:
			cmd->se_cmd.pi_err =
			    TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;
			break;
		case DIF_ERR_REF:
			cmd->se_cmd.pi_err =
			    TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;
			break;
		case DIF_ERR_APP:
			cmd->se_cmd.pi_err =
			    TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;
			break;
		case DIF_ERR_NONE:
		default:
			break;
		}

		if (cmd->se_cmd.pi_err)
			transport_generic_request_failure(&cmd->se_cmd,
				cmd->se_cmd.pi_err);
		else
			transport_generic_request_failure(&cmd->se_cmd,
				TCM_CHECK_CONDITION_ABORT_CMD);

		return;
	}

	return target_execute_cmd(&cmd->se_cmd);
}

/*
 * Called from qla_target.c:qlt_do_ctio_completion()
 */
static void tcm_qla2xxx_handle_data(struct qla_tgt_cmd *cmd)
{
	cmd->trc_flags |= TRC_DATA_IN;
	cmd->cmd_in_wq = 1;
	INIT_WORK(&cmd->work, tcm_qla2xxx_handle_data_work);
	queue_work_on(smp_processor_id(), tcm_qla2xxx_free_wq, &cmd->work);
}

static int tcm_qla2xxx_chk_dif_tags(uint32_t tag)
{
	return 0;
}

static int tcm_qla2xxx_dif_tags(struct qla_tgt_cmd *cmd,
    uint16_t *pfw_prot_opts)
{
	struct se_cmd *se_cmd = &cmd->se_cmd;

	if (!(se_cmd->prot_checks & TARGET_DIF_CHECK_GUARD))
		*pfw_prot_opts |= PO_DISABLE_GUARD_CHECK;

	if (!(se_cmd->prot_checks & TARGET_DIF_CHECK_APPTAG))
		*pfw_prot_opts |= PO_DIS_APP_TAG_VALD;

	return 0;
}

/*
 * Called from qla_target.c:qlt_issue_task_mgmt()
 */
static int tcm_qla2xxx_handle_tmr(struct qla_tgt_mgmt_cmd *mcmd, u64 lun,
	uint16_t tmr_func, uint32_t tag)
{
	struct fc_port *sess = mcmd->sess;
	struct se_cmd *se_cmd = &mcmd->se_cmd;
	int transl_tmr_func = 0;

	switch (tmr_func) {
	case QLA_TGT_ABTS:
		pr_debug("%ld: ABTS received\n", sess->vha->host_no);
		transl_tmr_func = TMR_ABORT_TASK;
		break;
	case QLA_TGT_2G_ABORT_TASK:
		pr_debug("%ld: 2G Abort Task received\n", sess->vha->host_no);
		transl_tmr_func = TMR_ABORT_TASK;
		break;
	case QLA_TGT_CLEAR_ACA:
		pr_debug("%ld: CLEAR_ACA received\n", sess->vha->host_no);
		transl_tmr_func = TMR_CLEAR_ACA;
		break;
	case QLA_TGT_TARGET_RESET:
		pr_debug("%ld: TARGET_RESET received\n", sess->vha->host_no);
		transl_tmr_func = TMR_TARGET_WARM_RESET;
		break;
	case QLA_TGT_LUN_RESET:
		pr_debug("%ld: LUN_RESET received\n", sess->vha->host_no);
		transl_tmr_func = TMR_LUN_RESET;
		break;
	case QLA_TGT_CLEAR_TS:
		pr_debug("%ld: CLEAR_TS received\n", sess->vha->host_no);
		transl_tmr_func = TMR_CLEAR_TASK_SET;
		break;
	case QLA_TGT_ABORT_TS:
		pr_debug("%ld: ABORT_TS received\n", sess->vha->host_no);
		transl_tmr_func = TMR_ABORT_TASK_SET;
		break;
	default:
		pr_debug("%ld: Unknown task mgmt fn 0x%x\n",
		    sess->vha->host_no, tmr_func);
		return -ENOSYS;
	}

	return target_submit_tmr(se_cmd, sess->se_sess, NULL, lun, mcmd,
	    transl_tmr_func, GFP_ATOMIC, tag, TARGET_SCF_ACK_KREF);
}

static struct qla_tgt_cmd *tcm_qla2xxx_find_cmd_by_tag(struct fc_port *sess,
    uint64_t tag)
{
	struct qla_tgt_cmd *cmd;
	unsigned long flags;

	if (!sess->se_sess)
		return NULL;

	spin_lock_irqsave(&sess->sess_cmd_lock, flags);
	list_for_each_entry(cmd, &sess->sess_cmd_list, sess_cmd_list) {
		if (cmd->se_cmd.tag == tag)
			goto done;
	}
	cmd = NULL;
done:
	spin_unlock_irqrestore(&sess->sess_cmd_lock, flags);

	return cmd;
}

static int tcm_qla2xxx_queue_data_in(struct se_cmd *se_cmd)
{
	struct qla_tgt_cmd *cmd = container_of(se_cmd,
				struct qla_tgt_cmd, se_cmd);
	struct scsi_qla_host *vha = cmd->vha;

	if (cmd->aborted) {
		/* Cmd can loop during Q-full.  tcm_qla2xxx_aborted_task
		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task
		 * already kick start the free.
		 */
		pr_debug("queue_data_in aborted cmd[%p] refcount %d "
			"transport_state %x, t_state %x, se_cmd_flags %x\n",
			cmd, kref_read(&cmd->se_cmd.cmd_kref),
			cmd->se_cmd.transport_state,
			cmd->se_cmd.t_state,
			cmd->se_cmd.se_cmd_flags);
		vha->hw->tgt.tgt_ops->free_cmd(cmd);
		return 0;
	}

	cmd->trc_flags |= TRC_XMIT_DATA;
	cmd->bufflen = se_cmd->data_length;
	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);

	cmd->sg_cnt = se_cmd->t_data_nents;
	cmd->sg = se_cmd->t_data_sg;
	cmd->offset = 0;

	cmd->prot_sg_cnt = se_cmd->t_prot_nents;
	cmd->prot_sg = se_cmd->t_prot_sg;
	cmd->blk_sz  = se_cmd->se_dev->dev_attrib.block_size;
	se_cmd->pi_err = 0;

	/*
	 * Now queue completed DATA_IN the qla2xxx LLD and response ring
	 */
	return qlt_xmit_response(cmd, QLA_TGT_XMIT_DATA|QLA_TGT_XMIT_STATUS,
				se_cmd->scsi_status);
}

static int tcm_qla2xxx_queue_status(struct se_cmd *se_cmd)
{
	struct qla_tgt_cmd *cmd = container_of(se_cmd,
				struct qla_tgt_cmd, se_cmd);
	struct scsi_qla_host *vha = cmd->vha;
	int xmit_type = QLA_TGT_XMIT_STATUS;

	if (cmd->aborted) {
		/*
		 * Cmd can loop during Q-full. tcm_qla2xxx_aborted_task
		 * can get ahead of this cmd. tcm_qla2xxx_aborted_task
		 * already kick start the free.
		 */
		pr_debug(
		    "queue_data_in aborted cmd[%p] refcount %d transport_state %x, t_state %x, se_cmd_flags %x\n",
		    cmd, kref_read(&cmd->se_cmd.cmd_kref),
		    cmd->se_cmd.transport_state, cmd->se_cmd.t_state,
		    cmd->se_cmd.se_cmd_flags);
		vha->hw->tgt.tgt_ops->free_cmd(cmd);
		return 0;
	}
	cmd->bufflen = se_cmd->data_length;
	cmd->sg = NULL;
	cmd->sg_cnt = 0;
	cmd->offset = 0;
	cmd->dma_data_direction = target_reverse_dma_direction(se_cmd);
	cmd->trc_flags |= TRC_XMIT_STATUS;

	if (se_cmd->data_direction == DMA_FROM_DEVICE) {
		/*
		 * For FCP_READ with CHECK_CONDITION status, clear cmd->bufflen
		 * for qla_tgt_xmit_response LLD code
		 */
		if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {
			se_cmd->se_cmd_flags &= ~SCF_OVERFLOW_BIT;
			se_cmd->residual_count = 0;
		}
		se_cmd->se_cmd_flags |= SCF_UNDERFLOW_BIT;
		se_cmd->residual_count += se_cmd->data_length;

		cmd->bufflen = 0;
	}
	/*
	 * Now queue status response to qla2xxx LLD code and response ring
	 */
	return qlt_xmit_response(cmd, xmit_type, se_cmd->scsi_status);
}

static void tcm_qla2xxx_queue_tm_rsp(struct se_cmd *se_cmd)
{
	struct se_tmr_req *se_tmr = se_cmd->se_tmr_req;
	struct qla_tgt_mgmt_cmd *mcmd = container_of(se_cmd,
				struct qla_tgt_mgmt_cmd, se_cmd);

	pr_debug("queue_tm_rsp: mcmd: %p func: 0x%02x response: 0x%02x\n",
			mcmd, se_tmr->function, se_tmr->response);
	/*
	 * Do translation between TCM TM response codes and
	 * QLA2xxx FC TM response codes.
	 */
	switch (se_tmr->response) {
	case TMR_FUNCTION_COMPLETE:
		mcmd->fc_tm_rsp = FC_TM_SUCCESS;
		break;
	case TMR_TASK_DOES_NOT_EXIST:
		mcmd->fc_tm_rsp = FC_TM_BAD_CMD;
		break;
	case TMR_FUNCTION_REJECTED:
		mcmd->fc_tm_rsp = FC_TM_REJECT;
		break;
	case TMR_LUN_DOES_NOT_EXIST:
	default:
		mcmd->fc_tm_rsp = FC_TM_FAILED;
		break;
	}
	/*
	 * Queue the TM response to QLA2xxx LLD to build a
	 * CTIO response packet.
	 */
	qlt_xmit_tm_rsp(mcmd);
}

static void tcm_qla2xxx_aborted_task(struct se_cmd *se_cmd)
{
	struct qla_tgt_cmd *cmd;
	unsigned long flags;

	if (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)
		return;

	cmd  = container_of(se_cmd, struct qla_tgt_cmd, se_cmd);

	spin_lock_irqsave(&cmd->sess->sess_cmd_lock, flags);
	list_del_init(&cmd->sess_cmd_list);
	spin_unlock_irqrestore(&cmd->sess->sess_cmd_lock, flags);

	qlt_abort_cmd(cmd);
}

static void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *,
			struct tcm_qla2xxx_nacl *, struct fc_port *);
/*
 * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 */
static void tcm_qla2xxx_clear_nacl_from_fcport_map(struct fc_port *sess)
{
	struct se_node_acl *se_nacl = sess->se_sess->se_node_acl;
	struct se_portal_group *se_tpg = se_nacl->se_tpg;
	struct se_wwn *se_wwn = se_tpg->se_tpg_wwn;
	struct tcm_qla2xxx_lport *lport = container_of(se_wwn,
				struct tcm_qla2xxx_lport, lport_wwn);
	struct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
				struct tcm_qla2xxx_nacl, se_node_acl);
	void *node;

	pr_debug("fc_rport domain: port_id 0x%06x\n", nacl->nport_id);

	node = btree_remove32(&lport->lport_fcport_map, nacl->nport_id);
	if (WARN_ON(node && (node != se_nacl))) {
		/*
		 * The nacl no longer matches what we think it should be.
		 * Most likely a new dynamic acl has been added while
		 * someone dropped the hardware lock.  It clearly is a
		 * bug elsewhere, but this bit can't make things worse.
		 */
		btree_insert32(&lport->lport_fcport_map, nacl->nport_id,
			       node, GFP_ATOMIC);
	}

	pr_debug("Removed from fcport_map: %p for WWNN: 0x%016LX, port_id: 0x%06x\n",
	    se_nacl, nacl->nport_wwnn, nacl->nport_id);
	/*
	 * Now clear the se_nacl and session pointers from our HW lport lookup
	 * table mapping for this initiator's fabric S_ID and LOOP_ID entries.
	 *
	 * This is done ahead of callbacks into tcm_qla2xxx_free_session() ->
	 * target_wait_for_sess_cmds() before the session waits for outstanding
	 * I/O to complete, to avoid a race between session shutdown execution
	 * and incoming ATIOs or TMRs picking up a stale se_node_act reference.
	 */
	tcm_qla2xxx_clear_sess_lookup(lport, nacl, sess);
}

static void tcm_qla2xxx_shutdown_sess(struct fc_port *sess)
{
	target_stop_session(sess->se_sess);
}

static int tcm_qla2xxx_init_nodeacl(struct se_node_acl *se_nacl,
		const char *name)
{
	struct tcm_qla2xxx_nacl *nacl =
		container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);
	u64 wwnn;

	if (tcm_qla2xxx_parse_wwn(name, &wwnn, 1) < 0)
		return -EINVAL;

	nacl->nport_wwnn = wwnn;
	tcm_qla2xxx_format_wwn(&nacl->nport_name[0], TCM_QLA2XXX_NAMELEN, wwnn);

	return 0;
}

/* Start items for tcm_qla2xxx_tpg_attrib_cit */

#define DEF_QLA_TPG_ATTRIB(name)					\
									\
static ssize_t tcm_qla2xxx_tpg_attrib_##name##_show(			\
		struct config_item *item, char *page)			\
{									\
	struct se_portal_group *se_tpg = attrib_to_tpg(item);		\
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,		\
			struct tcm_qla2xxx_tpg, se_tpg);		\
									\
	return sprintf(page, "%d\n", tpg->tpg_attrib.name);	\
}									\
									\
static ssize_t tcm_qla2xxx_tpg_attrib_##name##_store(			\
		struct config_item *item, const char *page, size_t count) \
{									\
	struct se_portal_group *se_tpg = attrib_to_tpg(item);		\
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,		\
			struct tcm_qla2xxx_tpg, se_tpg);		\
	struct tcm_qla2xxx_tpg_attrib *a = &tpg->tpg_attrib;		\
	unsigned long val;						\
	int ret;							\
									\
	ret = kstrtoul(page, 0, &val);					\
	if (ret < 0) {							\
		pr_err("kstrtoul() failed with"				\
				" ret: %d\n", ret);			\
		return -EINVAL;						\
	}								\
									\
	if ((val != 0) && (val != 1)) {					\
		pr_err("Illegal boolean value %lu\n", val);		\
		return -EINVAL;						\
	}								\
									\
	a->name = val;							\
									\
	return count;							\
}									\
CONFIGFS_ATTR(tcm_qla2xxx_tpg_attrib_, name)

DEF_QLA_TPG_ATTRIB(generate_node_acls);
DEF_QLA_TPG_ATTRIB(cache_dynamic_acls);
DEF_QLA_TPG_ATTRIB(demo_mode_write_protect);
DEF_QLA_TPG_ATTRIB(prod_mode_write_protect);
DEF_QLA_TPG_ATTRIB(demo_mode_login_only);
#ifdef CONFIG_TCM_QLA2XXX_DEBUG
DEF_QLA_TPG_ATTRIB(jam_host);
#endif

static struct configfs_attribute *tcm_qla2xxx_tpg_attrib_attrs[] = {
	&tcm_qla2xxx_tpg_attrib_attr_generate_node_acls,
	&tcm_qla2xxx_tpg_attrib_attr_cache_dynamic_acls,
	&tcm_qla2xxx_tpg_attrib_attr_demo_mode_write_protect,
	&tcm_qla2xxx_tpg_attrib_attr_prod_mode_write_protect,
	&tcm_qla2xxx_tpg_attrib_attr_demo_mode_login_only,
#ifdef CONFIG_TCM_QLA2XXX_DEBUG
	&tcm_qla2xxx_tpg_attrib_attr_jam_host,
#endif
	NULL,
};

/* End items for tcm_qla2xxx_tpg_attrib_cit */

static ssize_t tcm_qla2xxx_tpg_enable_show(struct config_item *item,
		char *page)
{
	struct se_portal_group *se_tpg = to_tpg(item);
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			struct tcm_qla2xxx_tpg, se_tpg);

	return snprintf(page, PAGE_SIZE, "%d\n",
			atomic_read(&tpg->lport_tpg_enabled));
}

static ssize_t tcm_qla2xxx_tpg_enable_store(struct config_item *item,
		const char *page, size_t count)
{
	struct se_portal_group *se_tpg = to_tpg(item);
	struct se_wwn *se_wwn = se_tpg->se_tpg_wwn;
	struct tcm_qla2xxx_lport *lport = container_of(se_wwn,
			struct tcm_qla2xxx_lport, lport_wwn);
	struct scsi_qla_host *vha = lport->qla_vha;
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			struct tcm_qla2xxx_tpg, se_tpg);
	unsigned long op;
	int rc;

	rc = kstrtoul(page, 0, &op);
	if (rc < 0) {
		pr_err("kstrtoul() returned %d\n", rc);
		return -EINVAL;
	}
	if ((op != 1) && (op != 0)) {
		pr_err("Illegal value for tpg_enable: %lu\n", op);
		return -EINVAL;
	}
	if (op) {
		if (atomic_read(&tpg->lport_tpg_enabled))
			return -EEXIST;

		atomic_set(&tpg->lport_tpg_enabled, 1);
		qlt_enable_vha(vha);
	} else {
		if (!atomic_read(&tpg->lport_tpg_enabled))
			return count;

		atomic_set(&tpg->lport_tpg_enabled, 0);
		qlt_stop_phase1(vha->vha_tgt.qla_tgt);
		qlt_stop_phase2(vha->vha_tgt.qla_tgt);
	}

	return count;
}

static ssize_t tcm_qla2xxx_tpg_dynamic_sessions_show(struct config_item *item,
		char *page)
{
	return target_show_dynamic_sessions(to_tpg(item), page);
}

static ssize_t tcm_qla2xxx_tpg_fabric_prot_type_store(struct config_item *item,
		const char *page, size_t count)
{
	struct se_portal_group *se_tpg = to_tpg(item);
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	unsigned long val;
	int ret = kstrtoul(page, 0, &val);

	if (ret) {
		pr_err("kstrtoul() returned %d for fabric_prot_type\n", ret);
		return ret;
	}
	if (val != 0 && val != 1 && val != 3) {
		pr_err("Invalid qla2xxx fabric_prot_type: %lu\n", val);
		return -EINVAL;
	}
	tpg->tpg_attrib.fabric_prot_type = val;

	return count;
}

static ssize_t tcm_qla2xxx_tpg_fabric_prot_type_show(struct config_item *item,
		char *page)
{
	struct se_portal_group *se_tpg = to_tpg(item);
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);

	return sprintf(page, "%d\n", tpg->tpg_attrib.fabric_prot_type);
}

CONFIGFS_ATTR(tcm_qla2xxx_tpg_, enable);
CONFIGFS_ATTR_RO(tcm_qla2xxx_tpg_, dynamic_sessions);
CONFIGFS_ATTR(tcm_qla2xxx_tpg_, fabric_prot_type);

static struct configfs_attribute *tcm_qla2xxx_tpg_attrs[] = {
	&tcm_qla2xxx_tpg_attr_enable,
	&tcm_qla2xxx_tpg_attr_dynamic_sessions,
	&tcm_qla2xxx_tpg_attr_fabric_prot_type,
	NULL,
};

static struct se_portal_group *tcm_qla2xxx_make_tpg(struct se_wwn *wwn,
						    const char *name)
{
	struct tcm_qla2xxx_lport *lport = container_of(wwn,
			struct tcm_qla2xxx_lport, lport_wwn);
	struct tcm_qla2xxx_tpg *tpg;
	unsigned long tpgt;
	int ret;

	if (strstr(name, "tpgt_") != name)
		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > USHRT_MAX)
		return ERR_PTR(-EINVAL);

	if ((tpgt != 1)) {
		pr_err("In non NPIV mode, a single TPG=1 is used for HW port mappings\n");
		return ERR_PTR(-ENOSYS);
	}

	tpg = kzalloc(sizeof(struct tcm_qla2xxx_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err("Unable to allocate struct tcm_qla2xxx_tpg\n");
		return ERR_PTR(-ENOMEM);
	}
	tpg->lport = lport;
	tpg->lport_tpgt = tpgt;
	/*
	 * By default allow READ-ONLY TPG demo-mode access w/ cached dynamic
	 * NodeACLs
	 */
	tpg->tpg_attrib.generate_node_acls = 1;
	tpg->tpg_attrib.demo_mode_write_protect = 1;
	tpg->tpg_attrib.cache_dynamic_acls = 1;
	tpg->tpg_attrib.demo_mode_login_only = 1;
	tpg->tpg_attrib.jam_host = 0;

	ret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}

	lport->tpg_1 = tpg;

	return &tpg->se_tpg;
}

static void tcm_qla2xxx_drop_tpg(struct se_portal_group *se_tpg)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;
	struct scsi_qla_host *vha = lport->qla_vha;
	/*
	 * Call into qla2x_target.c LLD logic to shutdown the active
	 * FC Nexuses and disable target mode operation for this qla_hw_data
	 */
	if (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stop)
		qlt_stop_phase1(vha->vha_tgt.qla_tgt);

	core_tpg_deregister(se_tpg);
	/*
	 * Clear local TPG=1 pointer for non NPIV mode.
	 */
	lport->tpg_1 = NULL;
	kfree(tpg);
}

static ssize_t tcm_qla2xxx_npiv_tpg_enable_show(struct config_item *item,
		char *page)
{
	return tcm_qla2xxx_tpg_enable_show(item, page);
}

static ssize_t tcm_qla2xxx_npiv_tpg_enable_store(struct config_item *item,
		const char *page, size_t count)
{
	struct se_portal_group *se_tpg = to_tpg(item);
	struct se_wwn *se_wwn = se_tpg->se_tpg_wwn;
	struct tcm_qla2xxx_lport *lport = container_of(se_wwn,
			struct tcm_qla2xxx_lport, lport_wwn);
	struct scsi_qla_host *vha = lport->qla_vha;
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
			struct tcm_qla2xxx_tpg, se_tpg);
	unsigned long op;
	int rc;

	rc = kstrtoul(page, 0, &op);
	if (rc < 0) {
		pr_err("kstrtoul() returned %d\n", rc);
		return -EINVAL;
	}
	if ((op != 1) && (op != 0)) {
		pr_err("Illegal value for tpg_enable: %lu\n", op);
		return -EINVAL;
	}
	if (op) {
		if (atomic_read(&tpg->lport_tpg_enabled))
			return -EEXIST;

		atomic_set(&tpg->lport_tpg_enabled, 1);
		qlt_enable_vha(vha);
	} else {
		if (!atomic_read(&tpg->lport_tpg_enabled))
			return count;

		atomic_set(&tpg->lport_tpg_enabled, 0);
		qlt_stop_phase1(vha->vha_tgt.qla_tgt);
		qlt_stop_phase2(vha->vha_tgt.qla_tgt);
	}

	return count;
}

CONFIGFS_ATTR(tcm_qla2xxx_npiv_tpg_, enable);

static struct configfs_attribute *tcm_qla2xxx_npiv_tpg_attrs[] = {
        &tcm_qla2xxx_npiv_tpg_attr_enable,
        NULL,
};

static struct se_portal_group *tcm_qla2xxx_npiv_make_tpg(struct se_wwn *wwn,
							 const char *name)
{
	struct tcm_qla2xxx_lport *lport = container_of(wwn,
			struct tcm_qla2xxx_lport, lport_wwn);
	struct tcm_qla2xxx_tpg *tpg;
	unsigned long tpgt;
	int ret;

	if (strstr(name, "tpgt_") != name)
		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > USHRT_MAX)
		return ERR_PTR(-EINVAL);

	tpg = kzalloc(sizeof(struct tcm_qla2xxx_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err("Unable to allocate struct tcm_qla2xxx_tpg\n");
		return ERR_PTR(-ENOMEM);
	}
	tpg->lport = lport;
	tpg->lport_tpgt = tpgt;

	/*
	 * By default allow READ-ONLY TPG demo-mode access w/ cached dynamic
	 * NodeACLs
	 */
	tpg->tpg_attrib.generate_node_acls = 1;
	tpg->tpg_attrib.demo_mode_write_protect = 1;
	tpg->tpg_attrib.cache_dynamic_acls = 1;
	tpg->tpg_attrib.demo_mode_login_only = 1;

	ret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_FCP);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	lport->tpg_1 = tpg;
	return &tpg->se_tpg;
}

/*
 * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 */
static struct fc_port *tcm_qla2xxx_find_sess_by_s_id(scsi_qla_host_t *vha,
						     const be_id_t s_id)
{
	struct tcm_qla2xxx_lport *lport;
	struct se_node_acl *se_nacl;
	struct tcm_qla2xxx_nacl *nacl;
	u32 key;

	lport = vha->vha_tgt.target_lport_ptr;
	if (!lport) {
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		return NULL;
	}

	key = sid_to_key(s_id);
	pr_debug("find_sess_by_s_id: 0x%06x\n", key);

	se_nacl = btree_lookup32(&lport->lport_fcport_map, key);
	if (!se_nacl) {
		pr_debug("Unable to locate s_id: 0x%06x\n", key);
		return NULL;
	}
	pr_debug("find_sess_by_s_id: located se_nacl: %p, initiatorname: %s\n",
	    se_nacl, se_nacl->initiatorname);

	nacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);
	if (!nacl->fc_port) {
		pr_err("Unable to locate struct fc_port\n");
		return NULL;
	}

	return nacl->fc_port;
}

/*
 * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 */
static void tcm_qla2xxx_set_sess_by_s_id(
	struct tcm_qla2xxx_lport *lport,
	struct se_node_acl *new_se_nacl,
	struct tcm_qla2xxx_nacl *nacl,
	struct se_session *se_sess,
	struct fc_port *fc_port,
	be_id_t s_id)
{
	u32 key;
	void *slot;
	int rc;

	key = sid_to_key(s_id);
	pr_debug("set_sess_by_s_id: %06x\n", key);

	slot = btree_lookup32(&lport->lport_fcport_map, key);
	if (!slot) {
		if (new_se_nacl) {
			pr_debug("Setting up new fc_port entry to new_se_nacl\n");
			nacl->nport_id = key;
			rc = btree_insert32(&lport->lport_fcport_map, key,
					new_se_nacl, GFP_ATOMIC);
			if (rc)
				printk(KERN_ERR "Unable to insert s_id into fcport_map: %06x\n",
				    (int)key);
		} else {
			pr_debug("Wiping nonexisting fc_port entry\n");
		}

		fc_port->se_sess = se_sess;
		nacl->fc_port = fc_port;
		return;
	}

	if (nacl->fc_port) {
		if (new_se_nacl == NULL) {
			pr_debug("Clearing existing nacl->fc_port and fc_port entry\n");
			btree_remove32(&lport->lport_fcport_map, key);
			nacl->fc_port = NULL;
			return;
		}
		pr_debug("Replacing existing nacl->fc_port and fc_port entry\n");
		btree_update32(&lport->lport_fcport_map, key, new_se_nacl);
		fc_port->se_sess = se_sess;
		nacl->fc_port = fc_port;
		return;
	}

	if (new_se_nacl == NULL) {
		pr_debug("Clearing existing fc_port entry\n");
		btree_remove32(&lport->lport_fcport_map, key);
		return;
	}

	pr_debug("Replacing existing fc_port entry w/o active nacl->fc_port\n");
	btree_update32(&lport->lport_fcport_map, key, new_se_nacl);
	fc_port->se_sess = se_sess;
	nacl->fc_port = fc_port;

	pr_debug("Setup nacl->fc_port %p by s_id for se_nacl: %p, initiatorname: %s\n",
	    nacl->fc_port, new_se_nacl, new_se_nacl->initiatorname);
}

/*
 * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 */
static struct fc_port *tcm_qla2xxx_find_sess_by_loop_id(
	scsi_qla_host_t *vha,
	const uint16_t loop_id)
{
	struct tcm_qla2xxx_lport *lport;
	struct se_node_acl *se_nacl;
	struct tcm_qla2xxx_nacl *nacl;
	struct tcm_qla2xxx_fc_loopid *fc_loopid;

	lport = vha->vha_tgt.target_lport_ptr;
	if (!lport) {
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		return NULL;
	}

	pr_debug("find_sess_by_loop_id: Using loop_id: 0x%04x\n", loop_id);

	fc_loopid = lport->lport_loopid_map + loop_id;
	se_nacl = fc_loopid->se_nacl;
	if (!se_nacl) {
		pr_debug("Unable to locate se_nacl by loop_id: 0x%04x\n",
		    loop_id);
		return NULL;
	}

	nacl = container_of(se_nacl, struct tcm_qla2xxx_nacl, se_node_acl);

	if (!nacl->fc_port) {
		pr_err("Unable to locate struct fc_port\n");
		return NULL;
	}

	return nacl->fc_port;
}

/*
 * Expected to be called with struct qla_hw_data->tgt.sess_lock held
 */
static void tcm_qla2xxx_set_sess_by_loop_id(
	struct tcm_qla2xxx_lport *lport,
	struct se_node_acl *new_se_nacl,
	struct tcm_qla2xxx_nacl *nacl,
	struct se_session *se_sess,
	struct fc_port *fc_port,
	uint16_t loop_id)
{
	struct se_node_acl *saved_nacl;
	struct tcm_qla2xxx_fc_loopid *fc_loopid;

	pr_debug("set_sess_by_loop_id: Using loop_id: 0x%04x\n", loop_id);

	fc_loopid = &((struct tcm_qla2xxx_fc_loopid *)
			lport->lport_loopid_map)[loop_id];

	saved_nacl = fc_loopid->se_nacl;
	if (!saved_nacl) {
		pr_debug("Setting up new fc_loopid->se_nacl to new_se_nacl\n");
		fc_loopid->se_nacl = new_se_nacl;
		if (fc_port->se_sess != se_sess)
			fc_port->se_sess = se_sess;
		if (nacl->fc_port != fc_port)
			nacl->fc_port = fc_port;
		return;
	}

	if (nacl->fc_port) {
		if (new_se_nacl == NULL) {
			pr_debug("Clearing nacl->fc_port and fc_loopid->se_nacl\n");
			fc_loopid->se_nacl = NULL;
			nacl->fc_port = NULL;
			return;
		}

		pr_debug("Replacing existing nacl->fc_port and fc_loopid->se_nacl\n");
		fc_loopid->se_nacl = new_se_nacl;
		if (fc_port->se_sess != se_sess)
			fc_port->se_sess = se_sess;
		if (nacl->fc_port != fc_port)
			nacl->fc_port = fc_port;
		return;
	}

	if (new_se_nacl == NULL) {
		pr_debug("Clearing fc_loopid->se_nacl\n");
		fc_loopid->se_nacl = NULL;
		return;
	}

	pr_debug("Replacing existing fc_loopid->se_nacl w/o active nacl->fc_port\n");
	fc_loopid->se_nacl = new_se_nacl;
	if (fc_port->se_sess != se_sess)
		fc_port->se_sess = se_sess;
	if (nacl->fc_port != fc_port)
		nacl->fc_port = fc_port;

	pr_debug("Setup nacl->fc_port %p by loop_id for se_nacl: %p, initiatorname: %s\n",
	    nacl->fc_port, new_se_nacl, new_se_nacl->initiatorname);
}

/*
 * Should always be called with qla_hw_data->tgt.sess_lock held.
 */
static void tcm_qla2xxx_clear_sess_lookup(struct tcm_qla2xxx_lport *lport,
		struct tcm_qla2xxx_nacl *nacl, struct fc_port *sess)
{
	struct se_session *se_sess = sess->se_sess;

	tcm_qla2xxx_set_sess_by_s_id(lport, NULL, nacl, se_sess,
				     sess, port_id_to_be_id(sess->d_id));
	tcm_qla2xxx_set_sess_by_loop_id(lport, NULL, nacl, se_sess,
				sess, sess->loop_id);
}

static void tcm_qla2xxx_free_session(struct fc_port *sess)
{
	struct qla_tgt *tgt = sess->tgt;
	struct qla_hw_data *ha = tgt->ha;
	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
	struct se_session *se_sess;
	struct tcm_qla2xxx_lport *lport;

	se_sess = sess->se_sess;
	if (!se_sess) {
		pr_err("struct fc_port->se_sess is NULL\n");
		dump_stack();
		return;
	}

	lport = vha->vha_tgt.target_lport_ptr;
	if (!lport) {
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		return;
	}
	target_wait_for_sess_cmds(se_sess);

	target_remove_session(se_sess);
}

static int tcm_qla2xxx_session_cb(struct se_portal_group *se_tpg,
				  struct se_session *se_sess, void *p)
{
	struct tcm_qla2xxx_tpg *tpg = container_of(se_tpg,
				struct tcm_qla2xxx_tpg, se_tpg);
	struct tcm_qla2xxx_lport *lport = tpg->lport;
	struct qla_hw_data *ha = lport->qla_vha->hw;
	struct se_node_acl *se_nacl = se_sess->se_node_acl;
	struct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
				struct tcm_qla2xxx_nacl, se_node_acl);
	struct fc_port *qlat_sess = p;
	uint16_t loop_id = qlat_sess->loop_id;
	unsigned long flags;

	/*
	 * And now setup se_nacl and session pointers into HW lport internal
	 * mappings for fabric S_ID and LOOP_ID.
	 */
	spin_lock_irqsave(&ha->tgt.sess_lock, flags);
	tcm_qla2xxx_set_sess_by_s_id(lport, se_nacl, nacl, se_sess, qlat_sess,
				     port_id_to_be_id(qlat_sess->d_id));
	tcm_qla2xxx_set_sess_by_loop_id(lport, se_nacl, nacl,
					se_sess, qlat_sess, loop_id);
	spin_unlock_irqrestore(&ha->tgt.sess_lock, flags);

	return 0;
}

/*
 * Called via qlt_create_sess():ha->qla2x_tmpl->check_initiator_node_acl()
 * to locate struct se_node_acl
 */
static int tcm_qla2xxx_check_initiator_node_acl(
	scsi_qla_host_t *vha,
	unsigned char *fc_wwpn,
	struct fc_port *qlat_sess)
{
	struct qla_hw_data *ha = vha->hw;
	struct tcm_qla2xxx_lport *lport;
	struct tcm_qla2xxx_tpg *tpg;
	struct se_session *se_sess;
	unsigned char port_name[36];
	int num_tags = (ha->cur_fw_xcb_count) ? ha->cur_fw_xcb_count :
		       TCM_QLA2XXX_DEFAULT_TAGS;

	lport = vha->vha_tgt.target_lport_ptr;
	if (!lport) {
		pr_err("Unable to locate struct tcm_qla2xxx_lport\n");
		dump_stack();
		return -EINVAL;
	}
	/*
	 * Locate the TPG=1 reference..
	 */
	tpg = lport->tpg_1;
	if (!tpg) {
		pr_err("Unable to locate struct tcm_qla2xxx_lport->tpg_1\n");
		return -EINVAL;
	}
	/*
	 * Format the FCP Initiator port_name into colon seperated values to
	 * match the format by tcm_qla2xxx explict ConfigFS NodeACLs.
	 */
	memset(&port_name, 0, 36);
	snprintf(port_name, sizeof(port_name), "%8phC", fc_wwpn);
	/*
	 * Locate our struct se_node_acl either from an explict NodeACL created
	 * via ConfigFS, or via running in TPG demo mode.
	 */
	se_sess = target_setup_session(&tpg->se_tpg, num_tags,
				       sizeof(struct qla_tgt_cmd),
				       TARGET_PROT_ALL, port_name,
				       qlat_sess, tcm_qla2xxx_session_cb);
	if (IS_ERR(se_sess))
		return PTR_ERR(se_sess);

	return 0;
}

static void tcm_qla2xxx_update_sess(struct fc_port *sess, port_id_t s_id,
				    uint16_t loop_id, bool conf_compl_supported)
{
	struct qla_tgt *tgt = sess->tgt;
	struct qla_hw_data *ha = tgt->ha;
	scsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);
	struct tcm_qla2xxx_lport *lport = vha->vha_tgt.target_lport_ptr;
	struct se_node_acl *se_nacl = sess->se_sess->se_node_acl;
	struct tcm_qla2xxx_nacl *nacl = container_of(se_nacl,
			struct tcm_qla2xxx_nacl, se_node_acl);
	u32 key;


	if (sess->loop_id != loop_id || sess->d_id.b24 != s_id.b24)
		pr_info("Updating session %p from port %8phC loop_id %d -> %d s_id %x:%x:%x -> %x:%x:%x\n",
		    sess, sess->port_name,
		    sess->loop_id, loop_id, sess->d_id.b.domain,
		    sess->d_id.b.area, sess->d_id.b.al_pa, s_id.b.domain,
		    s_id.b.area, s_id.b.al_pa);

	if (sess->loop_id != loop_id) {
		/*
		 * Because we can shuffle loop IDs around and we
		 * update different sessions non-atomically, we might
		 * have overwritten this session's old loop ID
		 * already, and we might end up overwriting some other
		 * session that will be updated later.  So we have to
		 * be extra careful and we can't warn about those things...
		 */
		if (lport->lport_loopid_map[sess->loop_id].se_nacl == se_nacl)
			lport->lport_loopid_map[sess->loop_id].se_nacl = NULL;

		lport->lport_loopid_map[loop_id].se_nacl = se_nacl;

		sess->loop_id = loop_id;
	}

	if (sess->d_id.b24 != s_id.b24) {
		key = (((u32) sess->d_id.b.domain << 16) |
		       ((u32) sess->d_id.b.area   <<  8) |
		       ((u32) sess->d_id.b.al_pa));

		if (btree_lookup32(&lport->lport_fcport_map, key))
			WARN(btree_remove32(&lport->lport_fcport_map, key) !=
			    se_nacl, "Found wrong se_nacl when updating s_id %x:%x:%x\n",
			    sess->d_id.b.domain, sess->d_id.b.area,
			    sess->d_id.b.al_pa);
		else
			WARN(1, "No lport_fcport_map entry for s_id %x:%x:%x\n",
			     sess->d_id.b.domain, sess->d_id.b.area,
			     sess->d_id.b.al_pa);

		key = (((u32) s_id.b.domain << 16) |
		       ((u32) s_id.b.area   <<  8) |
		       ((u32) s_id.b.al_pa));

		if (btree_lookup32(&lport->lport_fcport_map, key)) {
			WARN(1, "Already have lport_fcport_map entry for s_id %x:%x:%x\n",
			     s_id.b.domain, s_id.b.area, s_id.b.al_pa);
			btree_update32(&lport->lport_fcport_map, key, se_nacl);
		} else {
			btree_insert32(&lport->lport_fcport_map, key, se_nacl,
			    GFP_ATOMIC);
		}

		sess->d_id = s_id;
		nacl->nport_id = key;
	}

	sess->conf_compl_supported = conf_compl_supported;

}

/*
 * Calls into tcm_qla2xxx used by qla2xxx LLD I/O path.
 */
static struct qla_tgt_func_tmpl tcm_qla2xxx_template = {
	.find_cmd_by_tag	= tcm_qla2xxx_find_cmd_by_tag,
	.handle_cmd		= tcm_qla2xxx_handle_cmd,
	.handle_data		= tcm_qla2xxx_handle_data,
	.handle_tmr		= tcm_qla2xxx_handle_tmr,
	.get_cmd		= tcm_qla2xxx_get_cmd,
	.rel_cmd		= tcm_qla2xxx_rel_cmd,
	.free_cmd		= tcm_qla2xxx_free_cmd,
	.free_mcmd		= tcm_qla2xxx_free_mcmd,
	.free_session		= tcm_qla2xxx_free_session,
	.update_sess		= tcm_qla2xxx_update_sess,
	.check_initiator_node_acl = tcm_qla2xxx_check_initiator_node_acl,
	.find_sess_by_s_id	= tcm_qla2xxx_find_sess_by_s_id,
	.find_sess_by_loop_id	= tcm_qla2xxx_find_sess_by_loop_id,
	.clear_nacl_from_fcport_map = tcm_qla2xxx_clear_nacl_from_fcport_map,
	.put_sess		= tcm_qla2xxx_put_sess,
	.shutdown_sess		= tcm_qla2xxx_shutdown_sess,
	.get_dif_tags		= tcm_qla2xxx_dif_tags,
	.chk_dif_tags		= tcm_qla2xxx_chk_dif_tags,
};

static int tcm_qla2xxx_init_lport(struct tcm_qla2xxx_lport *lport)
{
	int rc;

	rc = btree_init32(&lport->lport_fcport_map);
	if (rc) {
		pr_err("Unable to initialize lport->lport_fcport_map btree\n");
		return rc;
	}

	lport->lport_loopid_map =
		vzalloc(array_size(65536,
				   sizeof(struct tcm_qla2xxx_fc_loopid)));
	if (!lport->lport_loopid_map) {
		pr_err("Unable to allocate lport->lport_loopid_map of %zu bytes\n",
		    sizeof(struct tcm_qla2xxx_fc_loopid) * 65536);
		btree_destroy32(&lport->lport_fcport_map);
		return -ENOMEM;
	}
	pr_debug("qla2xxx: Allocated lport_loopid_map of %zu bytes\n",
	       sizeof(struct tcm_qla2xxx_fc_loopid) * 65536);
	return 0;
}

static int tcm_qla2xxx_lport_register_cb(struct scsi_qla_host *vha,
					 void *target_lport_ptr,
					 u64 npiv_wwpn, u64 npiv_wwnn)
{
	struct qla_hw_data *ha = vha->hw;
	struct tcm_qla2xxx_lport *lport =
			(struct tcm_qla2xxx_lport *)target_lport_ptr;
	/*
	 * Setup tgt_ops, local pointer to vha and target_lport_ptr
	 */
	ha->tgt.tgt_ops = &tcm_qla2xxx_template;
	vha->vha_tgt.target_lport_ptr = target_lport_ptr;
	lport->qla_vha = vha;

	return 0;
}

static struct se_wwn *tcm_qla2xxx_make_lport(
	struct target_fabric_configfs *tf,
	struct config_group *group,
	const char *name)
{
	struct tcm_qla2xxx_lport *lport;
	u64 wwpn;
	int ret = -ENODEV;

	if (tcm_qla2xxx_parse_wwn(name, &wwpn, 1) < 0)
		return ERR_PTR(-EINVAL);

	lport = kzalloc(sizeof(struct tcm_qla2xxx_lport), GFP_KERNEL);
	if (!lport) {
		pr_err("Unable to allocate struct tcm_qla2xxx_lport\n");
		return ERR_PTR(-ENOMEM);
	}
	lport->lport_wwpn = wwpn;
	tcm_qla2xxx_format_wwn(&lport->lport_name[0], TCM_QLA2XXX_NAMELEN,
				wwpn);
	sprintf(lport->lport_naa_name, "naa.%016llx", (unsigned long long) wwpn);

	ret = tcm_qla2xxx_init_lport(lport);
	if (ret != 0)
		goto out;

	ret = qlt_lport_register(lport, wwpn, 0, 0,
				 tcm_qla2xxx_lport_register_cb);
	if (ret != 0)
		goto out_lport;

	return &lport->lport_wwn;
out_lport:
	vfree(lport->lport_loopid_map);
	btree_destroy32(&lport->lport_fcport_map);
out:
	kfree(lport);
	return ERR_PTR(ret);
}

static void tcm_qla2xxx_drop_lport(struct se_wwn *wwn)
{
	struct tcm_qla2xxx_lport *lport = container_of(wwn,
			struct tcm_qla2xxx_lport, lport_wwn);
	struct scsi_qla_host *vha = lport->qla_vha;
	struct se_node_acl *node;
	u32 key = 0;

	/*
	 * Call into qla2x_target.c LLD logic to complete the
	 * shutdown of struct qla_tgt after the call to
	 * qlt_stop_phase1() from tcm_qla2xxx_drop_tpg() above..
	 */
	if (vha->vha_tgt.qla_tgt && !vha->vha_tgt.qla_tgt->tgt_stopped)
		qlt_stop_phase2(vha->vha_tgt.qla_tgt);

	qlt_lport_deregister(vha);

	vfree(lport->lport_loopid_map);
	btree_for_each_safe32(&lport->lport_fcport_map, key, node)
		btree_remove32(&lport->lport_fcport_map, key);
	btree_destroy32(&lport->lport_fcport_map);
	kfree(lport);
}

static int tcm_qla2xxx_lport_register_npiv_cb(struct scsi_qla_host *base_vha,
					      void *target_lport_ptr,
					      u64 npiv_wwpn, u64 npiv_wwnn)
{
	struct fc_vport *vport;
	struct Scsi_Host *sh = base_vha->host;
	struct scsi_qla_host *npiv_vha;
	struct tcm_qla2xxx_lport *lport =
			(struct tcm_qla2xxx_lport *)target_lport_ptr;
	struct tcm_qla2xxx_lport *base_lport =
			(struct tcm_qla2xxx_lport *)base_vha->vha_tgt.target_lport_ptr;
	struct fc_vport_identifiers vport_id;

	if (qla_ini_mode_enabled(base_vha)) {
		pr_err("qla2xxx base_vha not enabled for target mode\n");
		return -EPERM;
	}

	if (!base_lport || !base_lport->tpg_1 ||
	    !atomic_read(&base_lport->tpg_1->lport_tpg_enabled)) {
		pr_err("qla2xxx base_lport or tpg_1 not available\n");
		return -EPERM;
	}

	memset(&vport_id, 0, sizeof(vport_id));
	vport_id.port_name = npiv_wwpn;
	vport_id.node_name = npiv_wwnn;
	vport_id.roles = FC_PORT_ROLE_FCP_INITIATOR;
	vport_id.vport_type = FC_PORTTYPE_NPIV;
	vport_id.disable = false;

	vport = fc_vport_create(sh, 0, &vport_id);
	if (!vport) {
		pr_err("fc_vport_create failed for qla2xxx_npiv\n");
		return -ENODEV;
	}
	/*
	 * Setup local pointer to NPIV vhba + target_lport_ptr
	 */
	npiv_vha = (struct scsi_qla_host *)vport->dd_data;
	npiv_vha->vha_tgt.target_lport_ptr = target_lport_ptr;
	lport->qla_vha = npiv_vha;
	scsi_host_get(npiv_vha->host);
	return 0;
}


static struct se_wwn *tcm_qla2xxx_npiv_make_lport(
	struct target_fabric_configfs *tf,
	struct config_group *group,
	const char *name)
{
	struct tcm_qla2xxx_lport *lport;
	u64 phys_wwpn, npiv_wwpn, npiv_wwnn;
	char *p, tmp[128];
	int ret;

	snprintf(tmp, 128, "%s", name);

	p = strchr(tmp, '@');
	if (!p) {
		pr_err("Unable to locate NPIV '@' separator\n");
		return ERR_PTR(-EINVAL);
	}
	*p++ = '\0';

	if (tcm_qla2xxx_parse_wwn(tmp, &phys_wwpn, 1) < 0)
		return ERR_PTR(-EINVAL);

	if (tcm_qla2xxx_npiv_parse_wwn(p, strlen(p)+1,
				       &npiv_wwpn, &npiv_wwnn) < 0)
		return ERR_PTR(-EINVAL);

	lport = kzalloc(sizeof(struct tcm_qla2xxx_lport), GFP_KERNEL);
	if (!lport) {
		pr_err("Unable to allocate struct tcm_qla2xxx_lport for NPIV\n");
		return ERR_PTR(-ENOMEM);
	}
	lport->lport_npiv_wwpn = npiv_wwpn;
	lport->lport_npiv_wwnn = npiv_wwnn;
	sprintf(lport->lport_naa_name, "naa.%016llx", (unsigned long long) npiv_wwpn);

	ret = tcm_qla2xxx_init_lport(lport);
	if (ret != 0)
		goto out;

	ret = qlt_lport_register(lport, phys_wwpn, npiv_wwpn, npiv_wwnn,
				 tcm_qla2xxx_lport_register_npiv_cb);
	if (ret != 0)
		goto out_lport;

	return &lport->lport_wwn;
out_lport:
	vfree(lport->lport_loopid_map);
	btree_destroy32(&lport->lport_fcport_map);
out:
	kfree(lport);
	return ERR_PTR(ret);
}

static void tcm_qla2xxx_npiv_drop_lport(struct se_wwn *wwn)
{
	struct tcm_qla2xxx_lport *lport = container_of(wwn,
			struct tcm_qla2xxx_lport, lport_wwn);
	struct scsi_qla_host *npiv_vha = lport->qla_vha;
	struct qla_hw_data *ha = npiv_vha->hw;
	scsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);

	scsi_host_put(npiv_vha->host);
	/*
	 * Notify libfc that we want to release the vha->fc_vport
	 */
	fc_vport_terminate(npiv_vha->fc_vport);
	scsi_host_put(base_vha->host);
	kfree(lport);
}


static ssize_t tcm_qla2xxx_wwn_version_show(struct config_item *item,
		char *page)
{
	return sprintf(page,
	    "TCM QLOGIC QLA2XXX NPIV capable fabric module %s on %s/%s on %s\n",
	    QLA2XXX_VERSION, utsname()->sysname,
	    utsname()->machine, utsname()->release);
}

CONFIGFS_ATTR_RO(tcm_qla2xxx_wwn_, version);

static struct configfs_attribute *tcm_qla2xxx_wwn_attrs[] = {
	&tcm_qla2xxx_wwn_attr_version,
	NULL,
};

static const struct target_core_fabric_ops tcm_qla2xxx_ops = {
	.module				= THIS_MODULE,
	.fabric_name			= "qla2xxx",
	.node_acl_size			= sizeof(struct tcm_qla2xxx_nacl),
	/*
	 * XXX: Limit assumes single page per scatter-gather-list entry.
	 * Current maximum is ~4.9 MB per se_cmd->t_data_sg with PAGE_SIZE=4096
	 */
	.max_data_sg_nents		= 1200,
	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
	.tpg_get_tag			= tcm_qla2xxx_get_tag,
	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
	.tpg_check_demo_mode_write_protect =
					tcm_qla2xxx_check_demo_write_protect,
	.tpg_check_prod_mode_write_protect =
					tcm_qla2xxx_check_prod_write_protect,
	.tpg_check_prot_fabric_only	= tcm_qla2xxx_check_prot_fabric_only,
	.tpg_check_demo_mode_login_only = tcm_qla2xxx_check_demo_mode_login_only,
	.tpg_get_inst_index		= tcm_qla2xxx_tpg_get_inst_index,
	.check_stop_free		= tcm_qla2xxx_check_stop_free,
	.release_cmd			= tcm_qla2xxx_release_cmd,
	.close_session			= tcm_qla2xxx_close_session,
	.sess_get_index			= tcm_qla2xxx_sess_get_index,
	.sess_get_initiator_sid		= NULL,
	.write_pending			= tcm_qla2xxx_write_pending,
	.set_default_node_attributes	= tcm_qla2xxx_set_default_node_attrs,
	.get_cmd_state			= tcm_qla2xxx_get_cmd_state,
	.queue_data_in			= tcm_qla2xxx_queue_data_in,
	.queue_status			= tcm_qla2xxx_queue_status,
	.queue_tm_rsp			= tcm_qla2xxx_queue_tm_rsp,
	.aborted_task			= tcm_qla2xxx_aborted_task,
	/*
	 * Setup function pointers for generic logic in
	 * target_core_fabric_configfs.c
	 */
	.fabric_make_wwn		= tcm_qla2xxx_make_lport,
	.fabric_drop_wwn		= tcm_qla2xxx_drop_lport,
	.fabric_make_tpg		= tcm_qla2xxx_make_tpg,
	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,

	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
	.tfc_tpg_base_attrs		= tcm_qla2xxx_tpg_attrs,
	.tfc_tpg_attrib_attrs		= tcm_qla2xxx_tpg_attrib_attrs,
};

static const struct target_core_fabric_ops tcm_qla2xxx_npiv_ops = {
	.module				= THIS_MODULE,
	.fabric_name			= "qla2xxx_npiv",
	.node_acl_size			= sizeof(struct tcm_qla2xxx_nacl),
	.tpg_get_wwn			= tcm_qla2xxx_get_fabric_wwn,
	.tpg_get_tag			= tcm_qla2xxx_get_tag,
	.tpg_check_demo_mode		= tcm_qla2xxx_check_demo_mode,
	.tpg_check_demo_mode_cache	= tcm_qla2xxx_check_demo_mode_cache,
	.tpg_check_demo_mode_write_protect = tcm_qla2xxx_check_demo_mode,
	.tpg_check_prod_mode_write_protect =
	    tcm_qla2xxx_check_prod_write_protect,
	.tpg_check_demo_mode_login_only	= tcm_qla2xxx_check_demo_mode_login_only,
	.tpg_get_inst_index		= tcm_qla2xxx_tpg_get_inst_index,
	.check_stop_free                = tcm_qla2xxx_check_stop_free,
	.release_cmd			= tcm_qla2xxx_release_cmd,
	.close_session			= tcm_qla2xxx_close_session,
	.sess_get_index			= tcm_qla2xxx_sess_get_index,
	.sess_get_initiator_sid		= NULL,
	.write_pending			= tcm_qla2xxx_write_pending,
	.set_default_node_attributes	= tcm_qla2xxx_set_default_node_attrs,
	.get_cmd_state			= tcm_qla2xxx_get_cmd_state,
	.queue_data_in			= tcm_qla2xxx_queue_data_in,
	.queue_status			= tcm_qla2xxx_queue_status,
	.queue_tm_rsp			= tcm_qla2xxx_queue_tm_rsp,
	.aborted_task			= tcm_qla2xxx_aborted_task,
	/*
	 * Setup function pointers for generic logic in
	 * target_core_fabric_configfs.c
	 */
	.fabric_make_wwn		= tcm_qla2xxx_npiv_make_lport,
	.fabric_drop_wwn		= tcm_qla2xxx_npiv_drop_lport,
	.fabric_make_tpg		= tcm_qla2xxx_npiv_make_tpg,
	.fabric_drop_tpg		= tcm_qla2xxx_drop_tpg,
	.fabric_init_nodeacl		= tcm_qla2xxx_init_nodeacl,

	.tfc_wwn_attrs			= tcm_qla2xxx_wwn_attrs,
	.tfc_tpg_base_attrs		= tcm_qla2xxx_npiv_tpg_attrs,
};

static int tcm_qla2xxx_register_configfs(void)
{
	int ret;

	pr_debug("TCM QLOGIC QLA2XXX fabric module %s on %s/%s on %s\n",
	    QLA2XXX_VERSION, utsname()->sysname,
	    utsname()->machine, utsname()->release);

	ret = target_register_template(&tcm_qla2xxx_ops);
	if (ret)
		return ret;

	ret = target_register_template(&tcm_qla2xxx_npiv_ops);
	if (ret)
		goto out_fabric;

	tcm_qla2xxx_free_wq = alloc_workqueue("tcm_qla2xxx_free",
						WQ_MEM_RECLAIM, 0);
	if (!tcm_qla2xxx_free_wq) {
		ret = -ENOMEM;
		goto out_fabric_npiv;
	}

	return 0;

out_fabric_npiv:
	target_unregister_template(&tcm_qla2xxx_npiv_ops);
out_fabric:
	target_unregister_template(&tcm_qla2xxx_ops);
	return ret;
}

static void tcm_qla2xxx_deregister_configfs(void)
{
	destroy_workqueue(tcm_qla2xxx_free_wq);

	target_unregister_template(&tcm_qla2xxx_ops);
	target_unregister_template(&tcm_qla2xxx_npiv_ops);
}

static int __init tcm_qla2xxx_init(void)
{
	int ret;

	BUILD_BUG_ON(sizeof(struct abts_recv_from_24xx) != 64);
	BUILD_BUG_ON(sizeof(struct abts_resp_from_24xx_fw) != 64);
	BUILD_BUG_ON(sizeof(struct atio7_fcp_cmnd) != 32);
	BUILD_BUG_ON(sizeof(struct atio_from_isp) != 64);
	BUILD_BUG_ON(sizeof(struct ba_acc_le) != 12);
	BUILD_BUG_ON(sizeof(struct ba_rjt_le) != 4);
	BUILD_BUG_ON(sizeof(struct ctio7_from_24xx) != 64);
	BUILD_BUG_ON(sizeof(struct ctio7_to_24xx) != 64);
	BUILD_BUG_ON(sizeof(struct ctio_crc2_to_fw) != 64);
	BUILD_BUG_ON(sizeof(struct ctio_crc_from_fw) != 64);
	BUILD_BUG_ON(sizeof(struct ctio_to_2xxx) != 64);
	BUILD_BUG_ON(sizeof(struct fcp_hdr) != 24);
	BUILD_BUG_ON(sizeof(struct fcp_hdr_le) != 24);
	BUILD_BUG_ON(sizeof(struct nack_to_isp) != 64);

	ret = tcm_qla2xxx_register_configfs();
	if (ret < 0)
		return ret;

	return 0;
}

static void __exit tcm_qla2xxx_exit(void)
{
	tcm_qla2xxx_deregister_configfs();
}

MODULE_DESCRIPTION("TCM QLA24XX+ series NPIV enabled fabric driver");
MODULE_LICENSE("GPL");
module_init(tcm_qla2xxx_init);
module_exit(tcm_qla2xxx_exit);
