// SPDX-License-Identifier: MIT
/*
 * Copyright Â© 2025 Intel Corporation
 */

#include <drm/drm_print.h>

#include "i915_reg.h"
#include "i915_utils.h"
#include "intel_cx0_phy.h"
#include "intel_cx0_phy_regs.h"
#include "intel_de.h"
#include "intel_display.h"
#include "intel_display_types.h"
#include "intel_dpll_mgr.h"
#include "intel_hdmi.h"
#include "intel_lt_phy.h"
#include "intel_lt_phy_regs.h"
#include "intel_psr.h"
#include "intel_tc.h"

#define INTEL_LT_PHY_LANE0		BIT(0)
#define INTEL_LT_PHY_LANE1		BIT(1)
#define INTEL_LT_PHY_BOTH_LANES		(INTEL_LT_PHY_LANE1 |\
					 INTEL_LT_PHY_LANE0)
#define MODE_DP				3

static const struct intel_lt_phy_pll_state xe3plpd_lt_dp_rbr = {
	.clock = 162000,
	.config = {
		0x83,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x5,  0xa,  0x2a, 0x20 },
		{ 0x80, 0x0,  0x0,  0x0  },
		{ 0x4,  0x4,  0x82, 0x28 },
		{ 0xfa, 0x16, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x5,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x4b, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0a },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_dp_hbr1 = {
	.clock = 270000,
	.config = {
		0x8b,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x3,  0xca, 0x34, 0xa0 },
		{ 0xe0, 0x0,  0x0,  0x0  },
		{ 0x5,  0x4,  0x81, 0xad },
		{ 0xfa, 0x11, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x7,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x43, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0d },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_dp_hbr2 = {
	.clock = 540000,
	.config = {
		0x93,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x1,  0x4d, 0x34, 0xa0 },
		{ 0xe0, 0x0,  0x0,  0x0  },
		{ 0xa,  0x4,  0x81, 0xda },
		{ 0xfa, 0x11, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x7,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x43, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0d },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_dp_hbr3 = {
	.clock = 810000,
	.config = {
		0x9b,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x1,  0x4a, 0x34, 0xa0 },
		{ 0xe0, 0x0,  0x0,  0x0  },
		{ 0x5,  0x4,  0x80, 0xa8 },
		{ 0xfa, 0x11, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x7,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x43, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0d },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_dp_uhbr10 = {
	.clock = 1000000,
	.config = {
		0x43,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x85,
		0x85,
		0x85,
		0x85,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x1,  0xa,  0x20, 0x80 },
		{ 0x6a, 0xaa, 0xaa, 0xab },
		{ 0x0,  0x3,  0x4,  0x94 },
		{ 0xfa, 0x1c, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x4,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x45, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x14, 0x2a, 0x14 },
		{ 0x0,  0x5b, 0xe0, 0x8  },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_dp_uhbr13_5 = {
	.clock = 1350000,
	.config = {
		0xcb,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x2,  0x9,  0x2b, 0xe0 },
		{ 0x90, 0x0,  0x0,  0x0  },
		{ 0x8,  0x4,  0x80, 0xe0 },
		{ 0xfa, 0x15, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x6,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x49, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x57, 0xe0, 0x0c },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_dp_uhbr20 = {
	.clock = 2000000,
	.config = {
		0x53,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x85,
		0x85,
		0x85,
		0x85,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
		0x86,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x1,  0xa,  0x20, 0x80 },
		{ 0x6a, 0xaa, 0xaa, 0xab },
		{ 0x0,  0x3,  0x4,  0x94 },
		{ 0xfa, 0x1c, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x4,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x45, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x14, 0x2a, 0x14 },
		{ 0x0,  0x5b, 0xe0, 0x8  },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state * const xe3plpd_lt_dp_tables[] = {
	&xe3plpd_lt_dp_rbr,
	&xe3plpd_lt_dp_hbr1,
	&xe3plpd_lt_dp_hbr2,
	&xe3plpd_lt_dp_hbr3,
	&xe3plpd_lt_dp_uhbr10,
	&xe3plpd_lt_dp_uhbr13_5,
	&xe3plpd_lt_dp_uhbr20,
	NULL,
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_edp_2_16 = {
	.clock = 216000,
	.config = {
		0xa3,
		0x2d,
		0x1,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x3,  0xca, 0x2a, 0x20 },
		{ 0x80, 0x0,  0x0,  0x0  },
		{ 0x6,  0x4,  0x81, 0xbc },
		{ 0xfa, 0x16, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x5,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x4b, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0a },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_edp_2_43 = {
	.clock = 243000,
	.config = {
		0xab,
		0x2d,
		0x1,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x3,  0xca, 0x2f, 0x60 },
		{ 0xb0, 0x0,  0x0,  0x0  },
		{ 0x6,  0x4,  0x81, 0xbc },
		{ 0xfa, 0x13, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x6,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x47, 0x48, 0x0,  0x0  },
		{ 0x0,  0x0,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0c },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_edp_3_24 = {
	.clock = 324000,
	.config = {
		0xb3,
		0x2d,
		0x1,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x2,  0x8a, 0x2a, 0x20 },
		{ 0x80, 0x0,  0x0,  0x0  },
		{ 0x6,  0x4,  0x81, 0x28 },
		{ 0xfa, 0x16, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x5,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x4b, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0a },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_edp_4_32 = {
	.clock = 432000,
	.config = {
		0xbb,
		0x2d,
		0x1,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x1,  0x4d, 0x2a, 0x20 },
		{ 0x80, 0x0,  0x0,  0x0  },
		{ 0xc,  0x4,  0x81, 0xbc },
		{ 0xfa, 0x16, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x5,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x4b, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x5b, 0xe0, 0x0a },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_edp_6_75 = {
	.clock = 675000,
	.config = {
		0xdb,
		0x2d,
		0x1,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x1,  0x4a, 0x2b, 0xe0 },
		{ 0x90, 0x0,  0x0,  0x0  },
		{ 0x6,  0x4,  0x80, 0xa8 },
		{ 0xfa, 0x15, 0x83, 0x11 },
		{ 0x80, 0x0f, 0xf9, 0x53 },
		{ 0x84, 0x26, 0x6,  0x4  },
		{ 0x0,  0xe0, 0x1,  0x0  },
		{ 0x49, 0x48, 0x0,  0x0  },
		{ 0x27, 0x8,  0x0,  0x0  },
		{ 0x5a, 0x13, 0x29, 0x13 },
		{ 0x0,  0x57, 0xe0, 0x0c },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state * const xe3plpd_lt_edp_tables[] = {
	&xe3plpd_lt_dp_rbr,
	&xe3plpd_lt_edp_2_16,
	&xe3plpd_lt_edp_2_43,
	&xe3plpd_lt_dp_hbr1,
	&xe3plpd_lt_edp_3_24,
	&xe3plpd_lt_edp_4_32,
	&xe3plpd_lt_dp_hbr2,
	&xe3plpd_lt_edp_6_75,
	&xe3plpd_lt_dp_hbr3,
	NULL,
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_hdmi_252 = {
	.clock = 25200,
	.config = {
		0x84,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x0c, 0x15, 0x27, 0x60 },
		{ 0x0,  0x0,  0x0,  0x0  },
		{ 0x8,  0x4,  0x98, 0x28 },
		{ 0x42, 0x0,  0x84, 0x10 },
		{ 0x80, 0x0f, 0xd9, 0xb5 },
		{ 0x86, 0x0,  0x0,  0x0  },
		{ 0x1,  0xa0, 0x1,  0x0  },
		{ 0x4b, 0x0,  0x0,  0x0  },
		{ 0x28, 0x0,  0x0,  0x0  },
		{ 0x0,  0x14, 0x2a, 0x14 },
		{ 0x0,  0x0,  0x0,  0x0  },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_hdmi_272 = {
	.clock = 27200,
	.config = {
		0x84,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x0b, 0x15, 0x26, 0xa0 },
		{ 0x60, 0x0,  0x0,  0x0  },
		{ 0x8,  0x4,  0x96, 0x28 },
		{ 0xfa, 0x0c, 0x84, 0x11 },
		{ 0x80, 0x0f, 0xd9, 0x53 },
		{ 0x86, 0x0,  0x0,  0x0  },
		{ 0x1,  0xa0, 0x1,  0x0  },
		{ 0x4b, 0x0,  0x0,  0x0  },
		{ 0x28, 0x0,  0x0,  0x0  },
		{ 0x0,  0x14, 0x2a, 0x14 },
		{ 0x0,  0x0,  0x0,  0x0  },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_hdmi_742p5 = {
	.clock = 74250,
	.config = {
		0x84,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x4,  0x15, 0x26, 0xa0 },
		{ 0x60, 0x0,  0x0,  0x0  },
		{ 0x8,  0x4,  0x88, 0x28 },
		{ 0xfa, 0x0c, 0x84, 0x11 },
		{ 0x80, 0x0f, 0xd9, 0x53 },
		{ 0x86, 0x0,  0x0,  0x0  },
		{ 0x1,  0xa0, 0x1,  0x0  },
		{ 0x4b, 0x0,  0x0,  0x0  },
		{ 0x28, 0x0,  0x0,  0x0  },
		{ 0x0,  0x14, 0x2a, 0x14 },
		{ 0x0,  0x0,  0x0,  0x0  },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_hdmi_1p485 = {
	.clock = 148500,
	.config = {
		0x84,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x2,  0x15, 0x26, 0xa0 },
		{ 0x60, 0x0,  0x0,  0x0  },
		{ 0x8,  0x4,  0x84, 0x28 },
		{ 0xfa, 0x0c, 0x84, 0x11 },
		{ 0x80, 0x0f, 0xd9, 0x53 },
		{ 0x86, 0x0,  0x0,  0x0  },
		{ 0x1,  0xa0, 0x1,  0x0  },
		{ 0x4b, 0x0,  0x0,  0x0  },
		{ 0x28, 0x0,  0x0,  0x0  },
		{ 0x0,  0x14, 0x2a, 0x14 },
		{ 0x0,  0x0,  0x0,  0x0  },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state xe3plpd_lt_hdmi_5p94 = {
	.clock = 594000,
	.config = {
		0x84,
		0x2d,
		0x0,
	},
	.addr_msb = {
		0x87,
		0x87,
		0x87,
		0x87,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
		0x88,
	},
	.addr_lsb = {
		0x10,
		0x0c,
		0x14,
		0xe4,
		0x0c,
		0x10,
		0x14,
		0x18,
		0x48,
		0x40,
		0x4c,
		0x24,
		0x44,
	},
	.data = {
		{ 0x0,  0x4c, 0x2,  0x0  },
		{ 0x0,  0x95, 0x26, 0xa0 },
		{ 0x60, 0x0,  0x0,  0x0  },
		{ 0x8,  0x4,  0x81, 0x28 },
		{ 0xfa, 0x0c, 0x84, 0x11 },
		{ 0x80, 0x0f, 0xd9, 0x53 },
		{ 0x86, 0x0,  0x0,  0x0  },
		{ 0x1,  0xa0, 0x1,  0x0  },
		{ 0x4b, 0x0,  0x0,  0x0  },
		{ 0x28, 0x0,  0x0,  0x0  },
		{ 0x0,  0x14, 0x2a, 0x14 },
		{ 0x0,  0x0,  0x0,  0x0  },
		{ 0x0,  0x0,  0x0,  0x0  },
	},
};

static const struct intel_lt_phy_pll_state * const xe3plpd_lt_hdmi_tables[] = {
	&xe3plpd_lt_hdmi_252,
	&xe3plpd_lt_hdmi_272,
	&xe3plpd_lt_hdmi_742p5,
	&xe3plpd_lt_hdmi_1p485,
	&xe3plpd_lt_hdmi_5p94,
	NULL,
};

static u8 intel_lt_phy_get_owned_lane_mask(struct intel_encoder *encoder)
{
	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);

	if (!intel_tc_port_in_dp_alt_mode(dig_port))
		return INTEL_LT_PHY_BOTH_LANES;

	return intel_tc_port_max_lane_count(dig_port) > 2
		? INTEL_LT_PHY_BOTH_LANES : INTEL_LT_PHY_LANE0;
}

static u8 intel_lt_phy_read(struct intel_encoder *encoder, u8 lane_mask, u16 addr)
{
	return intel_cx0_read(encoder, lane_mask, addr);
}

static void intel_lt_phy_write(struct intel_encoder *encoder,
			       u8 lane_mask, u16 addr, u8 data, bool committed)
{
	intel_cx0_write(encoder, lane_mask, addr, data, committed);
}

static void
intel_lt_phy_setup_powerdown(struct intel_encoder *encoder, u8 lane_count)
{
	/*
	 * The new PORT_BUF_CTL6 stuff for dc5 entry and exit needs to be handled
	 * by dmc firmware not explicitly mentioned in Bspec. This leaves this
	 * function as a wrapper only but keeping it expecting future changes.
	 */
	intel_cx0_setup_powerdown(encoder);
}

static void
intel_lt_phy_powerdown_change_sequence(struct intel_encoder *encoder,
				       u8 lane_mask, u8 state)
{
	intel_cx0_powerdown_change_sequence(encoder, lane_mask, state);
}

static void
intel_lt_phy_lane_reset(struct intel_encoder *encoder,
			u8 lane_count)
{
	struct intel_display *display = to_intel_display(encoder);
	enum port port = encoder->port;
	enum phy phy = intel_encoder_to_phy(encoder);
	u8 owned_lane_mask = intel_lt_phy_get_owned_lane_mask(encoder);
	u32 lane_pipe_reset = owned_lane_mask == INTEL_LT_PHY_BOTH_LANES
				? XELPDP_LANE_PIPE_RESET(0) | XELPDP_LANE_PIPE_RESET(1)
				: XELPDP_LANE_PIPE_RESET(0);
	u32 lane_phy_current_status = owned_lane_mask == INTEL_LT_PHY_BOTH_LANES
					? (XELPDP_LANE_PHY_CURRENT_STATUS(0) |
					   XELPDP_LANE_PHY_CURRENT_STATUS(1))
					: XELPDP_LANE_PHY_CURRENT_STATUS(0);
	u32 lane_phy_pulse_status = owned_lane_mask == INTEL_LT_PHY_BOTH_LANES
					? (XE3PLPDP_LANE_PHY_PULSE_STATUS(0) |
					   XE3PLPDP_LANE_PHY_PULSE_STATUS(1))
					: XE3PLPDP_LANE_PHY_PULSE_STATUS(0);

	intel_de_rmw(display, XE3PLPD_PORT_BUF_CTL5(port),
		     XE3PLPD_MACCLK_RATE_MASK, XE3PLPD_MACCLK_RATE_DEF);

	intel_de_rmw(display, XELPDP_PORT_BUF_CTL1(display, port),
		     XE3PLPDP_PHY_MODE_MASK, XE3PLPDP_PHY_MODE_DP);

	intel_lt_phy_setup_powerdown(encoder, lane_count);
	intel_lt_phy_powerdown_change_sequence(encoder, owned_lane_mask,
					       XELPDP_P2_STATE_RESET);

	intel_de_rmw(display, XE3PLPD_PORT_BUF_CTL5(port),
		     XE3PLPD_MACCLK_RESET_0, 0);

	intel_de_rmw(display, XELPDP_PORT_CLOCK_CTL(display, port),
		     XELPDP_LANE_PCLK_PLL_REQUEST(0),
		     XELPDP_LANE_PCLK_PLL_REQUEST(0));

	if (intel_de_wait_custom(display, XELPDP_PORT_CLOCK_CTL(display, port),
				 XELPDP_LANE_PCLK_PLL_ACK(0),
				 XELPDP_LANE_PCLK_PLL_ACK(0),
				 XE3PLPD_MACCLK_TURNON_LATENCY_US,
				 XE3PLPD_MACCLK_TURNON_LATENCY_MS, NULL))
		drm_warn(display->drm, "PHY %c PLL MacCLK assertion Ack not done after %dus.\n",
			 phy_name(phy), XE3PLPD_MACCLK_TURNON_LATENCY_MS * 1000);

	intel_de_rmw(display, XELPDP_PORT_CLOCK_CTL(display, port),
		     XELPDP_FORWARD_CLOCK_UNGATE,
		     XELPDP_FORWARD_CLOCK_UNGATE);

	intel_de_rmw(display, XELPDP_PORT_BUF_CTL2(display, port),
		     lane_pipe_reset | lane_phy_pulse_status, 0);

	if (intel_de_wait_custom(display, XELPDP_PORT_BUF_CTL2(display, port),
				 lane_phy_current_status, 0,
				 XE3PLPD_RESET_END_LATENCY_US, 2, NULL))
		drm_warn(display->drm,
			 "PHY %c failed to bring out of Lane reset after %dus.\n",
			 phy_name(phy), XE3PLPD_RESET_END_LATENCY_US);

	if (intel_de_wait_custom(display, XELPDP_PORT_BUF_CTL2(display, port),
				 lane_phy_pulse_status, lane_phy_pulse_status,
				 XE3PLPD_RATE_CALIB_DONE_LATENCY_US, 0, NULL))
		drm_warn(display->drm, "PHY %c PLL rate not changed after %dus.\n",
			 phy_name(phy), XE3PLPD_RATE_CALIB_DONE_LATENCY_US);

	intel_de_rmw(display, XELPDP_PORT_BUF_CTL2(display, port), lane_phy_pulse_status, 0);
}

static void
intel_lt_phy_program_port_clock_ctl(struct intel_encoder *encoder,
				    const struct intel_crtc_state *crtc_state,
				    bool lane_reversal)
{
	struct intel_display *display = to_intel_display(encoder);
	u32 val = 0;

	intel_de_rmw(display, XELPDP_PORT_BUF_CTL1(display, encoder->port),
		     XELPDP_PORT_REVERSAL,
		     lane_reversal ? XELPDP_PORT_REVERSAL : 0);

	val |= XELPDP_FORWARD_CLOCK_UNGATE;

	/*
	 * We actually mean MACCLK here and not MAXPCLK when using LT Phy
	 * but since the register bits still remain the same we use
	 * the same definition
	 */
	if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI) &&
	    intel_hdmi_is_frl(crtc_state->port_clock))
		val |= XELPDP_DDI_CLOCK_SELECT_PREP(display, XELPDP_DDI_CLOCK_SELECT_DIV18CLK);
	else
		val |= XELPDP_DDI_CLOCK_SELECT_PREP(display, XELPDP_DDI_CLOCK_SELECT_MAXPCLK);

	intel_de_rmw(display, XELPDP_PORT_CLOCK_CTL(display, encoder->port),
		     XELPDP_LANE1_PHY_CLOCK_SELECT | XELPDP_FORWARD_CLOCK_UNGATE |
		     XELPDP_DDI_CLOCK_SELECT_MASK(display) | XELPDP_SSC_ENABLE_PLLA |
		     XELPDP_SSC_ENABLE_PLLB, val);
}

static u32 intel_lt_phy_get_dp_clock(u8 rate)
{
	switch (rate) {
	case 0:
		return 162000;
	case 1:
		return 270000;
	case 2:
		return 540000;
	case 3:
		return 810000;
	case 4:
		return 216000;
	case 5:
		return 243000;
	case 6:
		return 324000;
	case 7:
		return 432000;
	case 8:
		return 1000000;
	case 9:
		return 1350000;
	case 10:
		return 2000000;
	case 11:
		return 675000;
	default:
		MISSING_CASE(rate);
		return 0;
	}
}

static bool
intel_lt_phy_config_changed(struct intel_encoder *encoder,
			    const struct intel_crtc_state *crtc_state)
{
	u8 val, rate;
	u32 clock;

	val = intel_lt_phy_read(encoder, INTEL_LT_PHY_LANE0,
				LT_PHY_VDR_0_CONFIG);
	rate = REG_FIELD_GET8(LT_PHY_VDR_RATE_ENCODING_MASK, val);

	/*
	 * The only time we do not reconfigure the PLL is when we are
	 * using 1.62 Gbps clock since PHY PLL defaults to that
	 * otherwise we always need to reconfigure it.
	 */
	if (intel_crtc_has_dp_encoder(crtc_state)) {
		clock = intel_lt_phy_get_dp_clock(rate);
		if (crtc_state->port_clock == 1620000 && crtc_state->port_clock == clock)
			return false;
	}

	return true;
}

static intel_wakeref_t intel_lt_phy_transaction_begin(struct intel_encoder *encoder)
{
	struct intel_display *display = to_intel_display(encoder);
	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
	intel_wakeref_t wakeref;

	intel_psr_pause(intel_dp);
	wakeref = intel_display_power_get(display, POWER_DOMAIN_DC_OFF);

	return wakeref;
}

static void intel_lt_phy_transaction_end(struct intel_encoder *encoder, intel_wakeref_t wakeref)
{
	struct intel_display *display = to_intel_display(encoder);
	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);

	intel_psr_resume(intel_dp);
	intel_display_power_put(display, POWER_DOMAIN_DC_OFF, wakeref);
}

static const struct intel_lt_phy_pll_state * const *
intel_lt_phy_pll_tables_get(struct intel_crtc_state *crtc_state,
			    struct intel_encoder *encoder)
{
	if (intel_crtc_has_dp_encoder(crtc_state)) {
		if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_EDP))
			return xe3plpd_lt_edp_tables;

		return xe3plpd_lt_dp_tables;
	} else if (intel_crtc_has_type(crtc_state, INTEL_OUTPUT_HDMI)) {
		return xe3plpd_lt_hdmi_tables;
	}

	MISSING_CASE(encoder->type);
	return NULL;
}

int
intel_lt_phy_pll_calc_state(struct intel_crtc_state *crtc_state,
			    struct intel_encoder *encoder)
{
	const struct intel_lt_phy_pll_state * const *tables;
	int i;

	tables = intel_lt_phy_pll_tables_get(crtc_state, encoder);
	if (!tables)
		return -EINVAL;

	for (i = 0; tables[i]; i++) {
		if (crtc_state->port_clock == tables[i]->clock) {
			crtc_state->dpll_hw_state.ltpll = *tables[i];
			return 0;
		}
	}

	/* TODO: Add a function to compute the data for HDMI TMDS*/

	return -EINVAL;
}

static void
intel_lt_phy_program_pll(struct intel_encoder *encoder,
			 const struct intel_crtc_state *crtc_state)
{
	u8 owned_lane_mask = intel_lt_phy_get_owned_lane_mask(encoder);
	int i, j, k;

	intel_lt_phy_write(encoder, owned_lane_mask, LT_PHY_VDR_0_CONFIG,
			   crtc_state->dpll_hw_state.ltpll.config[0], MB_WRITE_COMMITTED);
	intel_lt_phy_write(encoder, INTEL_LT_PHY_LANE0, LT_PHY_VDR_1_CONFIG,
			   crtc_state->dpll_hw_state.ltpll.config[1], MB_WRITE_COMMITTED);
	intel_lt_phy_write(encoder, owned_lane_mask, LT_PHY_VDR_2_CONFIG,
			   crtc_state->dpll_hw_state.ltpll.config[2], MB_WRITE_COMMITTED);

	for (i = 0; i <= 12; i++) {
		intel_lt_phy_write(encoder, INTEL_LT_PHY_LANE0, LT_PHY_VDR_X_ADDR_MSB(i),
				   crtc_state->dpll_hw_state.ltpll.addr_msb[i],
				   MB_WRITE_COMMITTED);
		intel_lt_phy_write(encoder, INTEL_LT_PHY_LANE0, LT_PHY_VDR_X_ADDR_LSB(i),
				   crtc_state->dpll_hw_state.ltpll.addr_lsb[i],
				   MB_WRITE_COMMITTED);

		for (j = 3, k = 0; j >= 0; j--, k++)
			intel_lt_phy_write(encoder, INTEL_LT_PHY_LANE0,
					   LT_PHY_VDR_X_DATAY(i, j),
					   crtc_state->dpll_hw_state.ltpll.data[i][k],
					   MB_WRITE_COMMITTED);
	}
}

void intel_lt_phy_pll_enable(struct intel_encoder *encoder,
			     const struct intel_crtc_state *crtc_state)
{
	struct intel_display *display = to_intel_display(encoder);
	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
	bool lane_reversal = dig_port->lane_reversal;
	u8 owned_lane_mask = intel_lt_phy_get_owned_lane_mask(encoder);
	intel_wakeref_t wakeref = 0;

	wakeref = intel_lt_phy_transaction_begin(encoder);

	/* 1. Enable MacCLK at default 162 MHz frequency. */
	intel_lt_phy_lane_reset(encoder, crtc_state->lane_count);

	/* 2. Program PORT_CLOCK_CTL register to configure clock muxes, gating, and SSC. */
	intel_lt_phy_program_port_clock_ctl(encoder, crtc_state, lane_reversal);

	/* 3. Change owned PHY lanes power to Ready state. */
	intel_lt_phy_powerdown_change_sequence(encoder, owned_lane_mask,
					       XELPDP_P2_STATE_READY);

	/*
	 * 4. Read the PHY message bus VDR register PHY_VDR_0_Config check enabled PLL type,
	 * encoded rate and encoded mode.
	 */
	if (intel_lt_phy_config_changed(encoder, crtc_state)) {
		/*
		 * 5. Program the PHY internal PLL registers over PHY message bus for the desired
		 * frequency and protocol type
		 */
		intel_lt_phy_program_pll(encoder, crtc_state);

		/* 6. Use the P2P transaction flow */
		/*
		 * 6.1. Set the PHY VDR register 0xCC4[Rate Control VDR Update] = 1 over PHY message
		 * bus for Owned PHY Lanes.
		 */
		/*
		 * 6.2. Poll for P2P Transaction Ready = "1" and read the MAC message bus VDR
		 * register at offset 0xC00 for Owned PHY Lanes*.
		 */
		/* 6.3. Clear P2P transaction Ready bit. */
		/* 7. Program PORT_CLOCK_CTL[PCLK PLL Request LN0] = 0. */
		/* 8. Poll for PORT_CLOCK_CTL[PCLK PLL Ack LN0]= 0. */
		/*
		 * 9. Follow the Display Voltage Frequency Switching - Sequence Before Frequency
		 * Change. We handle this step in bxt_set_cdclk().
		 */
		/* 10. Program DDI_CLK_VALFREQ to match intended DDI clock frequency. */
		/* 11. Program PORT_CLOCK_CTL[PCLK PLL Request LN0] = 1. */
		/* 12. Poll for PORT_CLOCK_CTL[PCLK PLL Ack LN0]= 1. */
	} else {
		intel_de_write(display, DDI_CLK_VALFREQ(encoder->port), crtc_state->port_clock);
	}

	/* 13. Ungate the forward clock by setting PORT_CLOCK_CTL[Forward Clock Ungate] = 1. */
	/* 14. SW clears PORT_BUF_CTL2 [PHY Pulse Status]. */
	/*
	 * 15. Clear the PHY VDR register 0xCC4[Rate Control VDR Update] over PHY message bus for
	 * Owned PHY Lanes.
	 */
	/* 16. Poll for PORT_BUF_CTL2 register PHY Pulse Status = 1 for Owned PHY Lanes. */
	/* 17. SW clears PORT_BUF_CTL2 [PHY Pulse Status]. */
	/*
	 * 18. Follow the Display Voltage Frequency Switching - Sequence After Frequency Change.
	 * We handle this step in bxt_set_cdclk()
	 */
	/* 19. Move the PHY powerdown state to Active and program to enable/disable transmitters */

	intel_lt_phy_transaction_end(encoder, wakeref);
}
