// SPDX-License-Identifier: MIT
/*
 * Copyright(c) 2025, Intel Corporation. All rights reserved.
 */

#include "regs/xe_irq_regs.h"
#include "regs/xe_mert_regs.h"

#include "xe_device.h"
#include "xe_mert.h"
#include "xe_mmio.h"
#include "xe_tile.h"

/**
 * xe_mert_invalidate_lmtt - Invalidate MERT LMTT
 * @tile: the &xe_tile
 *
 * Trigger invalidation of the MERT LMTT and wait for completion.
 *
 * Return: 0 on success or -ETIMEDOUT in case of a timeout.
 */
int xe_mert_invalidate_lmtt(struct xe_tile *tile)
{
	struct xe_device *xe = tile_to_xe(tile);
	struct xe_mert *mert = &tile->mert;
	const long timeout = HZ / 4;
	unsigned long flags;

	xe_assert(xe, xe_device_has_mert(xe));
	xe_assert(xe, xe_tile_is_root(tile));

	spin_lock_irqsave(&mert->lock, flags);
	if (!mert->tlb_inv_triggered) {
		mert->tlb_inv_triggered = true;
		reinit_completion(&mert->tlb_inv_done);
		xe_mmio_write32(&tile->mmio, MERT_TLB_INV_DESC_A, MERT_TLB_INV_DESC_A_VALID);
	}
	spin_unlock_irqrestore(&mert->lock, flags);

	if (!wait_for_completion_timeout(&mert->tlb_inv_done, timeout))
		return -ETIMEDOUT;

	return 0;
}

/**
 * xe_mert_irq_handler - Handler for MERT interrupts
 * @xe: the &xe_device
 * @master_ctl: interrupt register
 *
 * Handle interrupts generated by MERT.
 */
void xe_mert_irq_handler(struct xe_device *xe, u32 master_ctl)
{
	struct xe_tile *tile = xe_device_get_root_tile(xe);
	unsigned long flags;
	u32 reg_val;
	u8 err;

	if (!(master_ctl & SOC_H2DMEMINT_IRQ))
		return;

	reg_val = xe_mmio_read32(&tile->mmio, MERT_TLB_CT_INTR_ERR_ID_PORT);
	xe_mmio_write32(&tile->mmio, MERT_TLB_CT_INTR_ERR_ID_PORT, 0);

	err = FIELD_GET(MERT_TLB_CT_ERROR_MASK, reg_val);
	if (err == MERT_TLB_CT_LMTT_FAULT)
		drm_dbg(&xe->drm, "MERT catastrophic error: LMTT fault (VF%u)\n",
			FIELD_GET(MERT_TLB_CT_VFID_MASK, reg_val));
	else if (err)
		drm_dbg(&xe->drm, "MERT catastrophic error: Unexpected fault (0x%x)\n", err);

	spin_lock_irqsave(&tile->mert.lock, flags);
	if (tile->mert.tlb_inv_triggered) {
		reg_val = xe_mmio_read32(&tile->mmio, MERT_TLB_INV_DESC_A);
		if (!(reg_val & MERT_TLB_INV_DESC_A_VALID)) {
			tile->mert.tlb_inv_triggered = false;
			complete_all(&tile->mert.tlb_inv_done);
		}
	}
	spin_unlock_irqrestore(&tile->mert.lock, flags);
}
