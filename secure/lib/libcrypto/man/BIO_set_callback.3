.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BIO_SET_CALLBACK 3"
.TH BIO_SET_CALLBACK 3 "2019-02-26" "1.1.1b" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
BIO_set_callback_ex, BIO_get_callback_ex, BIO_set_callback, BIO_get_callback, BIO_set_callback_arg, BIO_get_callback_arg, BIO_debug_callback, BIO_callback_fn_ex, BIO_callback_fn \&\- BIO callback functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
\&
\& typedef long (*BIO_callback_fn_ex)(BIO *b, int oper, const char *argp,
\&                                    size_t len, int argi,
\&                                    long argl, int ret, size_t *processed);
\& typedef long (*BIO_callback_fn)(BIO *b, int oper, const char *argp, int argi,
\&                                 long argl, long ret);
\&
\& void BIO_set_callback_ex(BIO *b, BIO_callback_fn_ex callback);
\& BIO_callback_fn_ex BIO_get_callback_ex(const BIO *b);
\&
\& void BIO_set_callback(BIO *b, BIO_callback_fn cb);
\& BIO_callback_fn BIO_get_callback(BIO *b);
\& void BIO_set_callback_arg(BIO *b, char *arg);
\& char *BIO_get_callback_arg(const BIO *b);
\&
\& long BIO_debug_callback(BIO *bio, int cmd, const char *argp, int argi,
\&                         long argl, long ret);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBBIO_set_callback_ex()\fR and \fBBIO_get_callback_ex()\fR set and retrieve the \s-1BIO\s0
callback. The callback is called during most high level \s-1BIO\s0 operations. It can
be used for debugging purposes to trace operations on a \s-1BIO\s0 or to modify its
operation.
.PP
\&\fBBIO_set_callback()\fR and \fBBIO_get_callback()\fR set and retrieve the old format \s-1BIO\s0
callback. New code should not use these functions, but they are retained for
backwards compatibility. Any callback set via \fBBIO_set_callback_ex()\fR will get
called in preference to any set by \fBBIO_set_callback()\fR.
.PP
\&\fBBIO_set_callback_arg()\fR and \fBBIO_get_callback_arg()\fR are macros which can be
used to set and retrieve an argument for use in the callback.
.PP
\&\fBBIO_debug_callback()\fR is a standard debugging callback which prints
out information relating to each \s-1BIO\s0 operation. If the callback
argument is set it is interpreted as a \s-1BIO\s0 to send the information
to, otherwise stderr is used.
.PP
\&\fBBIO_callback_fn_ex()\fR is the type of the callback function and \fBBIO_callback_fn()\fR
is the type of the old format callback function. The meaning of each argument
is described below:
.IP "\fBb\fR" 4
.IX Item "b"
The \s-1BIO\s0 the callback is attached to is passed in \fBb\fR.
.IP "\fBoper\fR" 4
.IX Item "oper"
\&\fBoper\fR is set to the operation being performed. For some operations
the callback is called twice, once before and once after the actual
operation, the latter case has \fBoper\fR or'ed with \s-1BIO_CB_RETURN.\s0
.IP "\fBlen\fR" 4
.IX Item "len"
The length of the data requested to be read or written. This is only useful if
\&\fBoper\fR is \s-1BIO_CB_READ, BIO_CB_WRITE\s0 or \s-1BIO_CB_GETS.\s0
.IP "\fBargp\fR \fBargi\fR \fBargl\fR" 4
.IX Item "argp argi argl"
The meaning of the arguments \fBargp\fR, \fBargi\fR and \fBargl\fR depends on
the value of \fBoper\fR, that is the operation being performed.
.IP "\fBprocessed\fR" 4
.IX Item "processed"
\&\fBprocessed\fR is a pointer to a location which will be updated with the amount of
data that was actually read or written. Only used for \s-1BIO_CB_READ, BIO_CB_WRITE,
BIO_CB_GETS\s0 and \s-1BIO_CB_PUTS.\s0
.IP "\fBret\fR" 4
.IX Item "ret"
\&\fBret\fR is the return value that would be returned to the
application if no callback were present. The actual value returned
is the return value of the callback itself. In the case of callbacks
called before the actual \s-1BIO\s0 operation 1 is placed in \fBret\fR, if
the return value is not positive it will be immediately returned to
the application and the \s-1BIO\s0 operation will not be performed.
.PP
The callback should normally simply return \fBret\fR when it has
finished processing, unless it specifically wishes to modify the
value returned to the application.
.SH "CALLBACK OPERATIONS"
.IX Header "CALLBACK OPERATIONS"
In the notes below, \fBcallback\fR defers to the actual callback
function that is called.
.IP "\fBBIO_free(b)\fR" 4
.IX Item "BIO_free(b)"
.Vb 1
\& callback_ex(b, BIO_CB_FREE, NULL, 0, 0, 0L, 1L, NULL)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_FREE, NULL, 0L, 0L, 1L)
.Ve
.Sp
is called before the free operation.
.IP "\fBBIO_read_ex(b, data, dlen, readbytes)\fR" 4
.IX Item "BIO_read_ex(b, data, dlen, readbytes)"
.Vb 1
\& callback_ex(b, BIO_CB_READ, data, dlen, 0, 0L, 1L, NULL)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_READ, data, dlen, 0L, 1L)
.Ve
.Sp
is called before the read and
.Sp
.Vb 2
\& callback_ex(b, BIO_CB_READ | BIO_CB_RETURN, data, dlen, 0, 0L, retvalue,
\&             &readbytes)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_READ|BIO_CB_RETURN, data, dlen, 0L, retvalue)
.Ve
.Sp
after.
.IP "\fBBIO_write(b, data, dlen, written)\fR" 4
.IX Item "BIO_write(b, data, dlen, written)"
.Vb 1
\& callback_ex(b, BIO_CB_WRITE, data, dlen, 0, 0L, 1L, NULL)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_WRITE, datat, dlen, 0L, 1L)
.Ve
.Sp
is called before the write and
.Sp
.Vb 2
\& callback_ex(b, BIO_CB_WRITE | BIO_CB_RETURN, data, dlen, 0, 0L, retvalue,
\&             &written)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_WRITE|BIO_CB_RETURN, data, dlen, 0L, retvalue)
.Ve
.Sp
after.
.IP "\fBBIO_gets(b, buf, size)\fR" 4
.IX Item "BIO_gets(b, buf, size)"
.Vb 1
\& callback_ex(b, BIO_CB_GETS, buf, size, 0, 0L, 1, NULL, NULL)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_GETS, buf, size, 0L, 1L)
.Ve
.Sp
is called before the operation and
.Sp
.Vb 2
\& callback_ex(b, BIO_CB_GETS | BIO_CB_RETURN, buf, size, 0, 0L, retvalue,
\&             &readbytes)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_GETS|BIO_CB_RETURN, buf, size, 0L, retvalue)
.Ve
.Sp
after.
.IP "\fBBIO_puts(b, buf)\fR" 4
.IX Item "BIO_puts(b, buf)"
.Vb 1
\& callback_ex(b, BIO_CB_PUTS, buf, 0, 0, 0L, 1L, NULL);
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_PUTS, buf, 0, 0L, 1L)
.Ve
.Sp
is called before the operation and
.Sp
.Vb 1
\& callback_ex(b, BIO_CB_PUTS | BIO_CB_RETURN, buf, 0, 0, 0L, retvalue, &written)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_PUTS|BIO_CB_RETURN, buf, 0, 0L, retvalue)
.Ve
.Sp
after.
.IP "\fBBIO_ctrl(\s-1BIO\s0 *b, int cmd, long larg, void *parg)\fR" 4
.IX Item "BIO_ctrl(BIO *b, int cmd, long larg, void *parg)"
.Vb 1
\& callback_ex(b, BIO_CB_CTRL, parg, 0, cmd, larg, 1L, NULL)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_CTRL, parg, cmd, larg, 1L)
.Ve
.Sp
is called before the call and
.Sp
.Vb 1
\& callback_ex(b, BIO_CB_CTRL | BIO_CB_RETURN, parg, 0, cmd, larg, ret, NULL)
.Ve
.Sp
or
.Sp
.Vb 1
\& callback(b, BIO_CB_CTRL|BIO_CB_RETURN, parg, cmd, larg, ret)
.Ve
.Sp
after.
.Sp
Note: \fBcmd\fR == \fB\s-1BIO_CTRL_SET_CALLBACK\s0\fR is special, because \fBparg\fR is not the
argument of type \fBBIO_info_cb\fR itself.  In this case \fBparg\fR is a pointer to
the actual call parameter, see \fBBIO_callback_ctrl\fR.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The \fBBIO_debug_callback()\fR function is a good example, its source is
in crypto/bio/bio_cb.c
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBBIO_get_callback_ex()\fR and \fBBIO_get_callback()\fR return the callback function
previously set by a call to \fBBIO_set_callback_ex()\fR and \fBBIO_set_callback()\fR
respectively.
.PP
\&\fBBIO_get_callback_arg()\fR returns a \fBchar\fR pointer to the value previously set
via a call to \fBBIO_set_callback_arg()\fR.
.PP
\&\fBBIO_debug_callback()\fR returns 1 or \fBret\fR if it's called after specific \s-1BIO\s0
operations.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2018 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the OpenSSL license (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
