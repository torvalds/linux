.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_IA32CAP 3"
.TH OPENSSL_IA32CAP 3 "2019-02-26" "1.1.1b" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_ia32cap \- the x86[_64] processor capabilities vector
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& env OPENSSL_ia32cap=... <application>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OpenSSL supports a range of x86[_64] instruction set extensions. These
extensions are denoted by individual bits in capability vector returned
by processor in \s-1EDX:ECX\s0 register pair after executing \s-1CPUID\s0 instruction
with EAX=1 input value (see Intel Application Note #241618). This vector
is copied to memory upon toolkit initialization and used to choose
between different code paths to provide optimal performance across wide
range of processors. For the moment of this writing following bits are
significant:
.IP "bit #4 denoting presence of Time-Stamp Counter." 4
.IX Item "bit #4 denoting presence of Time-Stamp Counter."
.PD 0
.IP "bit #19 denoting availability of \s-1CLFLUSH\s0 instruction;" 4
.IX Item "bit #19 denoting availability of CLFLUSH instruction;"
.IP "bit #20, reserved by Intel, is used to choose among \s-1RC4\s0 code paths;" 4
.IX Item "bit #20, reserved by Intel, is used to choose among RC4 code paths;"
.IP "bit #23 denoting \s-1MMX\s0 support;" 4
.IX Item "bit #23 denoting MMX support;"
.IP "bit #24, \s-1FXSR\s0 bit, denoting availability of \s-1XMM\s0 registers;" 4
.IX Item "bit #24, FXSR bit, denoting availability of XMM registers;"
.IP "bit #25 denoting \s-1SSE\s0 support;" 4
.IX Item "bit #25 denoting SSE support;"
.IP "bit #26 denoting \s-1SSE2\s0 support;" 4
.IX Item "bit #26 denoting SSE2 support;"
.IP "bit #28 denoting Hyperthreading, which is used to distinguish cores with shared cache;" 4
.IX Item "bit #28 denoting Hyperthreading, which is used to distinguish cores with shared cache;"
.IP "bit #30, reserved by Intel, denotes specifically Intel CPUs;" 4
.IX Item "bit #30, reserved by Intel, denotes specifically Intel CPUs;"
.IP "bit #33 denoting availability of \s-1PCLMULQDQ\s0 instruction;" 4
.IX Item "bit #33 denoting availability of PCLMULQDQ instruction;"
.IP "bit #41 denoting \s-1SSSE3,\s0 Supplemental \s-1SSE3,\s0 support;" 4
.IX Item "bit #41 denoting SSSE3, Supplemental SSE3, support;"
.IP "bit #43 denoting \s-1AMD XOP\s0 support (forced to zero on non-AMD CPUs);" 4
.IX Item "bit #43 denoting AMD XOP support (forced to zero on non-AMD CPUs);"
.IP "bit #54 denoting availability of \s-1MOVBE\s0 instruction;" 4
.IX Item "bit #54 denoting availability of MOVBE instruction;"
.IP "bit #57 denoting AES-NI instruction set extension;" 4
.IX Item "bit #57 denoting AES-NI instruction set extension;"
.IP "bit #58, \s-1XSAVE\s0 bit, lack of which in combination with \s-1MOVBE\s0 is used to identify Atom Silvermont core;" 4
.IX Item "bit #58, XSAVE bit, lack of which in combination with MOVBE is used to identify Atom Silvermont core;"
.IP "bit #59, \s-1OSXSAVE\s0 bit, denoting availability of \s-1YMM\s0 registers;" 4
.IX Item "bit #59, OSXSAVE bit, denoting availability of YMM registers;"
.IP "bit #60 denoting \s-1AVX\s0 extension;" 4
.IX Item "bit #60 denoting AVX extension;"
.IP "bit #62 denoting availability of \s-1RDRAND\s0 instruction;" 4
.IX Item "bit #62 denoting availability of RDRAND instruction;"
.PD
.PP
For example, in 32\-bit application context clearing bit #26 at run-time
disables high-performance \s-1SSE2\s0 code present in the crypto library, while
clearing bit #24 disables \s-1SSE2\s0 code operating on 128\-bit \s-1XMM\s0 register
bank. You might have to do the latter if target OpenSSL application is
executed on \s-1SSE2\s0 capable \s-1CPU,\s0 but under control of \s-1OS\s0 that does not
enable \s-1XMM\s0 registers. Historically address of the capability vector copy
was exposed to application through \fBOPENSSL_ia32cap_loc()\fR, but not
anymore. Now the only way to affect the capability detection is to set
OPENSSL_ia32cap environment variable prior target application start. To
give a specific example, on Intel P4 processor 'env
OPENSSL_ia32cap=0x16980010 apps/openssl', or better yet 'env
OPENSSL_ia32cap=~0x1000000 apps/openssl' would achieve the desired
effect. Alternatively you can reconfigure the toolkit with no\-sse2
option and recompile.
.PP
Less intuitive is clearing bit #28, or ~0x10000000 in the \*(L"environment
variable\*(R" terms. The truth is that it's not copied from \s-1CPUID\s0 output
verbatim, but is adjusted to reflect whether or not the data cache is
actually shared between logical cores. This in turn affects the decision
on whether or not expensive countermeasures against cache-timing attacks
are applied, most notably in \s-1AES\s0 assembler module.
.PP
The capability vector is further extended with \s-1EBX\s0 value returned by
\&\s-1CPUID\s0 with EAX=7 and ECX=0 as input. Following bits are significant:
.IP "bit #64+3 denoting availability of \s-1BMI1\s0 instructions, e.g. \s-1ANDN\s0;" 4
.IX Item "bit #64+3 denoting availability of BMI1 instructions, e.g. ANDN;"
.PD 0
.IP "bit #64+5 denoting availability of \s-1AVX2\s0 instructions;" 4
.IX Item "bit #64+5 denoting availability of AVX2 instructions;"
.IP "bit #64+8 denoting availability of \s-1BMI2\s0 instructions, e.g. \s-1MULX\s0 and \s-1RORX\s0;" 4
.IX Item "bit #64+8 denoting availability of BMI2 instructions, e.g. MULX and RORX;"
.IP "bit #64+16 denoting availability of \s-1AVX512F\s0 extension;" 4
.IX Item "bit #64+16 denoting availability of AVX512F extension;"
.IP "bit #64+18 denoting availability of \s-1RDSEED\s0 instruction;" 4
.IX Item "bit #64+18 denoting availability of RDSEED instruction;"
.IP "bit #64+19 denoting availability of \s-1ADCX\s0 and \s-1ADOX\s0 instructions;" 4
.IX Item "bit #64+19 denoting availability of ADCX and ADOX instructions;"
.IP "bit #64+21 denoting availability of VPMADD52[\s-1LH\s0]UQ instructions, a.k.a. \s-1AVX512IFMA\s0 extension;" 4
.IX Item "bit #64+21 denoting availability of VPMADD52[LH]UQ instructions, a.k.a. AVX512IFMA extension;"
.IP "bit #64+29 denoting availability of \s-1SHA\s0 extension;" 4
.IX Item "bit #64+29 denoting availability of SHA extension;"
.IP "bit #64+30 denoting availability of \s-1AVX512BW\s0 extension;" 4
.IX Item "bit #64+30 denoting availability of AVX512BW extension;"
.IP "bit #64+31 denoting availability of \s-1AVX512VL\s0 extension;" 4
.IX Item "bit #64+31 denoting availability of AVX512VL extension;"
.IP "bit #64+41 denoting availability of \s-1VAES\s0 extension;" 4
.IX Item "bit #64+41 denoting availability of VAES extension;"
.IP "bit #64+42 denoting availability of \s-1VPCLMULQDQ\s0 extension;" 4
.IX Item "bit #64+42 denoting availability of VPCLMULQDQ extension;"
.PD
.PP
To control this extended capability word use ':' as delimiter when
setting up OPENSSL_ia32cap environment variable. For example assigning
\&':~0x20' would disable \s-1AVX2\s0 code paths, and ':0' \- all post-AVX
extensions.
.PP
It should be noted that whether or not some of the most \*(L"fancy\*(R"
extension code paths are actually assembled depends on current assembler
version. Base minimum of \s-1AES\-NI/PCLMULQDQ, SSSE3\s0 and \s-1SHA\s0 extension code
paths are always assembled. Apart from that, minimum assembler version
requirements are summarized in below table:
.PP
.Vb 8
\&   Extension   | GNU as | nasm   | llvm
\&   \-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-
\&   AVX         | 2.19   | 2.09   | 3.0
\&   AVX2        | 2.22   | 2.10   | 3.1
\&   ADCX/ADOX   | 2.23   | 2.10   | 3.3
\&   AVX512      | 2.25   | 2.11.8 | see NOTES
\&   AVX512IFMA  | 2.26   | 2.11.8 | see NOTES
\&   VAES        | 2.30   | 2.13.3 |
.Ve
.SH "NOTES"
.IX Header "NOTES"
Even though \s-1AVX512\s0 support was implemented in llvm 3.6, compilation of
assembly modules apparently requires explicit \-march flag. But then
compiler generates processor-specific code, which in turn contradicts
the mere idea of run-time switch execution facilitated by the variable
in question. Till the limitation is lifted, it's possible to work around
the problem by making build procedure use following script:
.PP
.Vb 2
\&   #!/bin/sh
\&   exec clang \-no\-integrated\-as "$@"
.Ve
.PP
instead of real clang. In which case it doesn't matter which clang
version is used, as it is \s-1GNU\s0 assembler version that will be checked.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Not available.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004\-2018 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the OpenSSL license (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
