.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SSL_GET_ERROR 3"
.TH SSL_GET_ERROR 3 "2019-02-26" "1.1.1b" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SSL_get_error \- obtain result code for TLS/SSL I/O operation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/ssl.h>
\&
\& int SSL_get_error(const SSL *ssl, int ret);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBSSL_get_error()\fR returns a result code (suitable for the C \*(L"switch\*(R"
statement) for a preceding call to \fBSSL_connect()\fR, \fBSSL_accept()\fR, \fBSSL_do_handshake()\fR,
\&\fBSSL_read_ex()\fR, \fBSSL_read()\fR, \fBSSL_peek_ex()\fR, \fBSSL_peek()\fR, \fBSSL_write_ex()\fR or
\&\fBSSL_write()\fR on \fBssl\fR.  The value returned by that \s-1TLS/SSL I/O\s0 function must be
passed to \fBSSL_get_error()\fR in parameter \fBret\fR.
.PP
In addition to \fBssl\fR and \fBret\fR, \fBSSL_get_error()\fR inspects the
current thread's OpenSSL error queue.  Thus, \fBSSL_get_error()\fR must be
used in the same thread that performed the \s-1TLS/SSL I/O\s0 operation, and no
other OpenSSL function calls should appear in between.  The current
thread's error queue must be empty before the \s-1TLS/SSL I/O\s0 operation is
attempted, or \fBSSL_get_error()\fR will not work reliably.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
The following return values can currently occur:
.IP "\s-1SSL_ERROR_NONE\s0" 4
.IX Item "SSL_ERROR_NONE"
The \s-1TLS/SSL I/O\s0 operation completed.  This result code is returned
if and only if \fBret > 0\fR.
.IP "\s-1SSL_ERROR_ZERO_RETURN\s0" 4
.IX Item "SSL_ERROR_ZERO_RETURN"
The \s-1TLS/SSL\s0 peer has closed the connection for writing by sending the
close_notify alert.
No more data can be read.
Note that \fB\s-1SSL_ERROR_ZERO_RETURN\s0\fR does not necessarily
indicate that the underlying transport has been closed.
.IP "\s-1SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE\s0" 4
.IX Item "SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE"
The operation did not complete and can be retried later.
.Sp
\&\fB\s-1SSL_ERROR_WANT_READ\s0\fR is returned when the last operation was a read
operation from a non-blocking \fB\s-1BIO\s0\fR.
It means that not enough data was available at this time to complete the
operation.
If at a later time the underlying \fB\s-1BIO\s0\fR has data available for reading the same
function can be called again.
.Sp
\&\fBSSL_read()\fR and \fBSSL_read_ex()\fR can also set \fB\s-1SSL_ERROR_WANT_READ\s0\fR when there is
still unprocessed data available at either the \fB\s-1SSL\s0\fR or the \fB\s-1BIO\s0\fR layer, even
for a blocking \fB\s-1BIO\s0\fR.
See \fBSSL_read\fR\|(3) for more information.
.Sp
\&\fB\s-1SSL_ERROR_WANT_WRITE\s0\fR is returned when the last operation was a write
to a non-blocking \fB\s-1BIO\s0\fR and it was unable to sent all data to the \fB\s-1BIO\s0\fR.
When the \fB\s-1BIO\s0\fR is writeable again, the same function can be called again.
.Sp
Note that the retry may again lead to an \fB\s-1SSL_ERROR_WANT_READ\s0\fR or
\&\fB\s-1SSL_ERROR_WANT_WRITE\s0\fR condition.
There is no fixed upper limit for the number of iterations that
may be necessary until progress becomes visible at application
protocol level.
.Sp
It is safe to call \fBSSL_read()\fR or \fBSSL_read_ex()\fR when more data is available
even when the call that set this error was an \fBSSL_write()\fR or \fBSSL_write_ex()\fR.
However if the call was an \fBSSL_write()\fR or \fBSSL_write_ex()\fR, it should be called
again to continue sending the application data.
.Sp
For socket \fB\s-1BIO\s0\fRs (e.g. when \fBSSL_set_fd()\fR was used), \fBselect()\fR or
\&\fBpoll()\fR on the underlying socket can be used to find out when the
\&\s-1TLS/SSL I/O\s0 function should be retried.
.Sp
Caveat: Any \s-1TLS/SSL I/O\s0 function can lead to either of
\&\fB\s-1SSL_ERROR_WANT_READ\s0\fR and \fB\s-1SSL_ERROR_WANT_WRITE\s0\fR.
In particular,
\&\fBSSL_read_ex()\fR, \fBSSL_read()\fR, \fBSSL_peek_ex()\fR, or \fBSSL_peek()\fR may want to write data
and \fBSSL_write()\fR or \fBSSL_write_ex()\fR may want to read data.
This is mainly because
\&\s-1TLS/SSL\s0 handshakes may occur at any time during the protocol (initiated by
either the client or the server); \fBSSL_read_ex()\fR, \fBSSL_read()\fR, \fBSSL_peek_ex()\fR,
\&\fBSSL_peek()\fR, \fBSSL_write_ex()\fR, and \fBSSL_write()\fR will handle any pending handshakes.
.IP "\s-1SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT\s0" 4
.IX Item "SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT"
The operation did not complete; the same \s-1TLS/SSL I/O\s0 function should be
called again later. The underlying \s-1BIO\s0 was not connected yet to the peer
and the call would block in \fBconnect()\fR/\fBaccept()\fR. The \s-1SSL\s0 function should be
called again when the connection is established. These messages can only
appear with a \fBBIO_s_connect()\fR or \fBBIO_s_accept()\fR \s-1BIO,\s0 respectively.
In order to find out, when the connection has been successfully established,
on many platforms \fBselect()\fR or \fBpoll()\fR for writing on the socket file descriptor
can be used.
.IP "\s-1SSL_ERROR_WANT_X509_LOOKUP\s0" 4
.IX Item "SSL_ERROR_WANT_X509_LOOKUP"
The operation did not complete because an application callback set by
\&\fBSSL_CTX_set_client_cert_cb()\fR has asked to be called again.
The \s-1TLS/SSL I/O\s0 function should be called again later.
Details depend on the application.
.IP "\s-1SSL_ERROR_WANT_ASYNC\s0" 4
.IX Item "SSL_ERROR_WANT_ASYNC"
The operation did not complete because an asynchronous engine is still
processing data. This will only occur if the mode has been set to \s-1SSL_MODE_ASYNC\s0
using \fBSSL_CTX_set_mode\fR\|(3) or \fBSSL_set_mode\fR\|(3) and an asynchronous capable
engine is being used. An application can determine whether the engine has
completed its processing using \fBselect()\fR or \fBpoll()\fR on the asynchronous wait file
descriptor. This file descriptor is available by calling
\&\fBSSL_get_all_async_fds\fR\|(3) or \fBSSL_get_changed_async_fds\fR\|(3). The \s-1TLS/SSL I/O\s0
function should be called again later. The function \fBmust\fR be called from the
same thread that the original call was made from.
.IP "\s-1SSL_ERROR_WANT_ASYNC_JOB\s0" 4
.IX Item "SSL_ERROR_WANT_ASYNC_JOB"
The asynchronous job could not be started because there were no async jobs
available in the pool (see \fBASYNC_init_thread\fR\|(3)). This will only occur if the
mode has been set to \s-1SSL_MODE_ASYNC\s0 using \fBSSL_CTX_set_mode\fR\|(3) or
\&\fBSSL_set_mode\fR\|(3) and a maximum limit has been set on the async job pool
through a call to \fBASYNC_init_thread\fR\|(3). The application should retry the
operation after a currently executing asynchronous operation for the current
thread has completed.
.IP "\s-1SSL_ERROR_WANT_CLIENT_HELLO_CB\s0" 4
.IX Item "SSL_ERROR_WANT_CLIENT_HELLO_CB"
The operation did not complete because an application callback set by
\&\fBSSL_CTX_set_client_hello_cb()\fR has asked to be called again.
The \s-1TLS/SSL I/O\s0 function should be called again later.
Details depend on the application.
.IP "\s-1SSL_ERROR_SYSCALL\s0" 4
.IX Item "SSL_ERROR_SYSCALL"
Some non-recoverable, fatal I/O error occurred. The OpenSSL error queue may
contain more information on the error. For socket I/O on Unix systems, consult
\&\fBerrno\fR for details. If this error occurs then no further I/O operations should
be performed on the connection and \fBSSL_shutdown()\fR must not be called.
.Sp
This value can also be returned for other errors, check the error queue for
details.
.IP "\s-1SSL_ERROR_SSL\s0" 4
.IX Item "SSL_ERROR_SSL"
A non-recoverable, fatal error in the \s-1SSL\s0 library occurred, usually a protocol
error.  The OpenSSL error queue contains more information on the error. If this
error occurs then no further I/O operations should be performed on the
connection and \fBSSL_shutdown()\fR must not be called.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBssl\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The \s-1SSL_ERROR_WANT_ASYNC\s0 error code was added in OpenSSL 1.1.0.
The \s-1SSL_ERROR_WANT_CLIENT_HELLO_CB\s0 error code was added in OpenSSL 1.1.1.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2000\-2018 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the OpenSSL license (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
