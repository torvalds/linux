// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_UNORDERED_SET
#define _LIBCPP_UNORDERED_SET

// clang-format off

/*

    unordered_set synopsis

#include <initializer_list>

namespace std
{

template <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,
          class Alloc = allocator<Value>>
class unordered_set
{
public:
    // types
    typedef Value                                                      key_type;
    typedef key_type                                                   value_type;
    typedef Hash                                                       hasher;
    typedef Pred                                                       key_equal;
    typedef Alloc                                                      allocator_type;
    typedef value_type&                                                reference;
    typedef const value_type&                                          const_reference;
    typedef typename allocator_traits<allocator_type>::pointer         pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type       size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef /unspecified/ iterator;
    typedef /unspecified/ const_iterator;
    typedef /unspecified/ local_iterator;
    typedef /unspecified/ const_local_iterator;

    typedef unspecified node_type unspecified;                            // C++17
    typedef INSERT_RETURN_TYPE<iterator, node_type> insert_return_type;   // C++17

    unordered_set()
        noexcept(
            is_nothrow_default_constructible<hasher>::value &&
            is_nothrow_default_constructible<key_equal>::value &&
            is_nothrow_default_constructible<allocator_type>::value);
    explicit unordered_set(size_type n, const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
        unordered_set(InputIterator f, InputIterator l,
                      size_type n = 0, const hasher& hf = hasher(),
                      const key_equal& eql = key_equal(),
                      const allocator_type& a = allocator_type());
    template<container-compatible-range<value_type> R>
      unordered_set(from_range_t, R&& rg, size_type n = see below,
        const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type()); // C++23
    explicit unordered_set(const allocator_type&);
    unordered_set(const unordered_set&);
    unordered_set(const unordered_set&, const Allocator&);
    unordered_set(unordered_set&&)
        noexcept(
            is_nothrow_move_constructible<hasher>::value &&
            is_nothrow_move_constructible<key_equal>::value &&
            is_nothrow_move_constructible<allocator_type>::value);
    unordered_set(unordered_set&&, const Allocator&);
    unordered_set(initializer_list<value_type>, size_type n = 0,
                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_set(size_type n, const allocator_type& a); // C++14
    unordered_set(size_type n, const hasher& hf, const allocator_type& a); // C++14
    template <class InputIterator>
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14
    template <class InputIterator>
      unordered_set(InputIterator f, InputIterator l, size_type n,
                    const hasher& hf,  const allocator_type& a); // C++14
    template<container-compatible-range<value_type> R>
      unordered_set(from_range_t, R&& rg, size_type n, const allocator_type& a)
        : unordered_set(from_range, std::forward<R>(rg), n, hasher(), key_equal(), a) { } // C++23
    template<container-compatible-range<value_type> R>
      unordered_set(from_range_t, R&& rg, size_type n, const hasher& hf, const allocator_type& a)
        : unordered_set(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }       // C++23
    unordered_set(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14
    unordered_set(initializer_list<value_type> il, size_type n,
                  const hasher& hf,  const allocator_type& a); // C++14
    ~unordered_set();
    unordered_set& operator=(const unordered_set&);
    unordered_set& operator=(unordered_set&&)
        noexcept(
            allocator_type::propagate_on_container_move_assignment::value &&
            is_nothrow_move_assignable<allocator_type>::value &&
            is_nothrow_move_assignable<hasher>::value &&
            is_nothrow_move_assignable<key_equal>::value);
    unordered_set& operator=(initializer_list<value_type>);

    allocator_type get_allocator() const noexcept;

    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    iterator       begin() noexcept;
    iterator       end() noexcept;
    const_iterator begin()  const noexcept;
    const_iterator end()    const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend()   const noexcept;

    template <class... Args>
        pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& obj);
    pair<iterator, bool> insert(value_type&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    template<container-compatible-range<value_type> R>
      void insert_range(R&& rg);                                      // C++23
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);                       // C++17
    node_type extract(const key_type& x);                             // C++17
    insert_return_type insert(node_type&& nh);                        // C++17
    iterator           insert(const_iterator hint, node_type&& nh);   // C++17

    iterator erase(const_iterator position);
    iterator erase(iterator position);  // C++14
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>& source);         // C++17
    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>&& source);        // C++17
    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);    // C++17
    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);   // C++17

    void swap(unordered_set&)
       noexcept(allocator_traits<Allocator>::is_always_equal::value &&
                 noexcept(swap(declval<hasher&>(), declval<hasher&>())) &&
                 noexcept(swap(declval<key_equal&>(), declval<key_equal&>()))); // C++17

    hasher hash_function() const;
    key_equal key_eq() const;

    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    template<typename K>
        iterator find(const K& x);              // C++20
    template<typename K>
        const_iterator find(const K& x) const;  // C++20
    size_type count(const key_type& k) const;
    template<typename K>
        size_type count(const K& k) const; // C++20
    bool contains(const key_type& k) const; // C++20
    template<typename K>
        bool contains(const K& k) const; // C++20
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
    template<typename K>
        pair<iterator, iterator>             equal_range(const K& k); // C++20
    template<typename K>
        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20

    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;

    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;

    local_iterator       begin(size_type n);
    local_iterator       end(size_type n);
    const_local_iterator begin(size_type n) const;
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
};

template<class InputIterator,
    class Hash = hash<typename iterator_traits<InputIterator>::value_type>,
    class Pred = equal_to<typename iterator_traits<InputIterator>::value_type>,
    class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
unordered_set(InputIterator, InputIterator, typename see below::size_type = see below,
    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
  -> unordered_set<typename iterator_traits<InputIterator>::value_type,
        Hash, Pred, Allocator>; // C++17

template<ranges::input_range R,
         class Hash = hash<ranges::range_value_t<R>>,
         class Pred = equal_to<ranges::range_value_t<R>>,
         class Allocator = allocator<ranges::range_value_t<R>>>
  unordered_set(from_range_t, R&&, typename see below::size_type = see below, Hash = Hash(), Pred = Pred(), Allocator = Allocator())
    -> unordered_set<ranges::range_value_t<R>, Hash, Pred, Allocator>; // C++23

template<class T, class Hash = hash<T>,
          class Pred = equal_to<T>, class Allocator = allocator<T>>
unordered_set(initializer_list<T>, typename see below::size_type = see below,
    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
  -> unordered_set<T, Hash, Pred, Allocator>; // C++17

template<class InputIterator,  class Allocator>
unordered_set(InputIterator, InputIterator, typename see below::size_type, Allocator)
  -> unordered_set<typename iterator_traits<InputIterator>::value_type,
        hash<typename iterator_traits<InputIterator>::value_type>,
        equal_to<typename iterator_traits<InputIterator>::value_type>,
        Allocator>; // C++17

template<class InputIterator, class Hash, class Allocator>
unordered_set(InputIterator, InputIterator, typename see below::size_type,
    Hash, Allocator)
  -> unordered_set<typename iterator_traits<InputIterator>::value_type, Hash,
        equal_to<typename iterator_traits<InputIterator>::value_type>,
        Allocator>; // C++17

template<ranges::input_range R, class Allocator>
  unordered_set(from_range_t, R&&, typename see below::size_type, Allocator)
    -> unordered_set<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
                      equal_to<ranges::range_value_t<R>>, Allocator>; // C++23

template<ranges::input_range R, class Allocator>
  unordered_set(from_range_t, R&&, Allocator)
    -> unordered_set<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
                      equal_to<ranges::range_value_t<R>>, Allocator>; // C++23

template<ranges::input_range R, class Hash, class Allocator>
  unordered_set(from_range_t, R&&, typename see below::size_type, Hash, Allocator)
    -> unordered_set<ranges::range_value_t<R>, Hash,
                      equal_to<ranges::range_value_t<R>>, Allocator>; // C++23

template<class T, class Allocator>
unordered_set(initializer_list<T>, typename see below::size_type, Allocator)
  -> unordered_set<T, hash<T>, equal_to<T>, Allocator>; // C++17

template<class T, class Hash, class Allocator>
unordered_set(initializer_list<T>, typename see below::size_type, Hash, Allocator)
  -> unordered_set<T, Hash, equal_to<T>, Allocator>; // C++17

template <class Value, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
              unordered_set<Value, Hash, Pred, Alloc>& y)
              noexcept(noexcept(x.swap(y)));

template <class Value, class Hash, class Pred, class Alloc>
    bool
    operator==(const unordered_set<Value, Hash, Pred, Alloc>& x,
               const unordered_set<Value, Hash, Pred, Alloc>& y);

template <class Value, class Hash, class Pred, class Alloc>
    bool
    operator!=(const unordered_set<Value, Hash, Pred, Alloc>& x,
               const unordered_set<Value, Hash, Pred, Alloc>& y); // removed in C++20

template <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,
          class Alloc = allocator<Value>>
class unordered_multiset
{
public:
    // types
    typedef Value                                                      key_type;
    typedef key_type                                                   value_type;
    typedef Hash                                                       hasher;
    typedef Pred                                                       key_equal;
    typedef Alloc                                                      allocator_type;
    typedef value_type&                                                reference;
    typedef const value_type&                                          const_reference;
    typedef typename allocator_traits<allocator_type>::pointer         pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type       size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef /unspecified/ iterator;
    typedef /unspecified/ const_iterator;
    typedef /unspecified/ local_iterator;
    typedef /unspecified/ const_local_iterator;

    typedef unspecified node_type unspecified;   // C++17

    unordered_multiset()
        noexcept(
            is_nothrow_default_constructible<hasher>::value &&
            is_nothrow_default_constructible<key_equal>::value &&
            is_nothrow_default_constructible<allocator_type>::value);
    explicit unordered_multiset(size_type n, const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
        unordered_multiset(InputIterator f, InputIterator l,
                      size_type n = 0, const hasher& hf = hasher(),
                      const key_equal& eql = key_equal(),
                      const allocator_type& a = allocator_type());
    template<container-compatible-range<value_type> R>
      unordered_multiset(from_range_t, R&& rg, size_type n = see below,
        const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type()); // C++23
    explicit unordered_multiset(const allocator_type&);
    unordered_multiset(const unordered_multiset&);
    unordered_multiset(const unordered_multiset&, const Allocator&);
    unordered_multiset(unordered_multiset&&)
        noexcept(
            is_nothrow_move_constructible<hasher>::value &&
            is_nothrow_move_constructible<key_equal>::value &&
            is_nothrow_move_constructible<allocator_type>::value);
    unordered_multiset(unordered_multiset&&, const Allocator&);
    unordered_multiset(initializer_list<value_type>, size_type n = /see below/,
                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_multiset(size_type n, const allocator_type& a); // C++14
    unordered_multiset(size_type n, const hasher& hf, const allocator_type& a); // C++14
    template <class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14
    template <class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l, size_type n,
                         const hasher& hf, const allocator_type& a); // C++14
    template<container-compatible-range<value_type> R>
      unordered_multiset(from_range_t, R&& rg, size_type n, const allocator_type& a)
        : unordered_multiset(from_range, std::forward<R>(rg), n, hasher(), key_equal(), a) { } // C++23
    template<container-compatible-range<value_type> R>
      unordered_multiset(from_range_t, R&& rg, size_type n, const hasher& hf, const allocator_type& a)
        : unordered_multiset(from_range, std::forward<R>(rg), n, hf, key_equal(), a) { }       // C++23
    unordered_multiset(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14
    unordered_multiset(initializer_list<value_type> il, size_type n,
                       const hasher& hf,  const allocator_type& a); // C++14
    ~unordered_multiset();
    unordered_multiset& operator=(const unordered_multiset&);
    unordered_multiset& operator=(unordered_multiset&&)
        noexcept(
            allocator_type::propagate_on_container_move_assignment::value &&
            is_nothrow_move_assignable<allocator_type>::value &&
            is_nothrow_move_assignable<hasher>::value &&
            is_nothrow_move_assignable<key_equal>::value);
    unordered_multiset& operator=(initializer_list<value_type>);

    allocator_type get_allocator() const noexcept;

    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    iterator       begin() noexcept;
    iterator       end() noexcept;
    const_iterator begin()  const noexcept;
    const_iterator end()    const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend()   const noexcept;

    template <class... Args>
        iterator emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& obj);
    iterator insert(value_type&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    template<container-compatible-range<value_type> R>
      void insert_range(R&& rg);                            // C++23
    void insert(initializer_list<value_type>);

    node_type extract(const_iterator position);             // C++17
    node_type extract(const key_type& x);                   // C++17
    iterator insert(node_type&& nh);                        // C++17
    iterator insert(const_iterator hint, node_type&& nh);   // C++17

    iterator erase(const_iterator position);
    iterator erase(iterator position);  // C++14
    size_type erase(const key_type& k);
    iterator erase(const_iterator first, const_iterator last);
    void clear() noexcept;

    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);    // C++17
    template<class H2, class P2>
      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);   // C++17
    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>& source);         // C++17
    template<class H2, class P2>
      void merge(unordered_set<Key, H2, P2, Allocator>&& source);        // C++17

    void swap(unordered_multiset&)
       noexcept(allocator_traits<Allocator>::is_always_equal::value &&
                 noexcept(swap(declval<hasher&>(), declval<hasher&>())) &&
                 noexcept(swap(declval<key_equal&>(), declval<key_equal&>()))); // C++17

    hasher hash_function() const;
    key_equal key_eq() const;

    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    template<typename K>
        iterator find(const K& x);              // C++20
    template<typename K>
        const_iterator find(const K& x) const;  // C++20
    size_type count(const key_type& k) const;
    template<typename K>
        size_type count(const K& k) const; // C++20
    bool contains(const key_type& k) const; // C++20
    template<typename K>
        bool contains(const K& k) const; // C++20
    pair<iterator, iterator>             equal_range(const key_type& k);
    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
    template<typename K>
        pair<iterator, iterator>             equal_range(const K& k); // C++20
    template<typename K>
        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20

    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;

    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;

    local_iterator       begin(size_type n);
    local_iterator       end(size_type n);
    const_local_iterator begin(size_type n) const;
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
};

template<class InputIterator,
    class Hash = hash<typename iterator_traits<InputIterator>::value_type>,
    class Pred = equal_to<typename iterator_traits<InputIterator>::value_type>,
    class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
unordered_multiset(InputIterator, InputIterator, see below::size_type = see below,
    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
  -> unordered_multiset<typename iterator_traits<InputIterator>::value_type,
        Hash, Pred, Allocator>; // C++17

template<ranges::input_range R,
         class Hash = hash<ranges::range_value_t<R>>,
         class Pred = equal_to<ranges::range_value_t<R>>,
         class Allocator = allocator<ranges::range_value_t<R>>>
  unordered_multiset(from_range_t, R&&, typename see below::size_type = see below, Hash = Hash(), Pred = Pred(), Allocator = Allocator())
    -> unordered_multiset<ranges::range_value_t<R>, Hash, Pred, Allocator>; // C++23

template<class T, class Hash = hash<T>,
          class Pred = equal_to<T>, class Allocator = allocator<T>>
unordered_multiset(initializer_list<T>, typename see below::size_type = see below,
    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
  -> unordered_multiset<T, Hash, Pred, Allocator>; // C++17

template<class InputIterator,  class Allocator>
unordered_multiset(InputIterator, InputIterator, typename see below::size_type, Allocator)
  -> unordered_multiset<typename iterator_traits<InputIterator>::value_type,
        hash<typename iterator_traits<InputIterator>::value_type>,
        equal_to<typename iterator_traits<InputIterator>::value_type>,
        Allocator>; // C++17

template<class InputIterator,  class Hash, class Allocator>
unordered_multiset(InputIterator, InputIterator, typename see below::size_type,
    Hash, Allocator)
  -> unordered_multiset<typename iterator_traits<InputIterator>::value_type, Hash,
        equal_to<typename iterator_traits<InputIterator>::value_type>, Allocator>; // C++17

template<ranges::input_range R, class Allocator>
  unordered_multiset(from_range_t, R&&, typename see below::size_type, Allocator)
    -> unordered_multiset<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
                      equal_to<ranges::range_value_t<R>>, Allocator>; // C++23

template<ranges::input_range R, class Allocator>
  unordered_multiset(from_range_t, R&&, Allocator)
    -> unordered_multiset<ranges::range_value_t<R>, hash<ranges::range_value_t<R>>,
                      equal_to<ranges::range_value_t<R>>, Allocator>; // C++23

template<ranges::input_range R, class Hash, class Allocator>
  unordered_multiset(from_range_t, R&&, typename see below::size_type, Hash, Allocator)
    -> unordered_multiset<ranges::range_value_t<R>, Hash,
                      equal_to<ranges::range_value_t<R>>, Allocator>; // C++23

template<class T, class Allocator>
unordered_multiset(initializer_list<T>, typename see below::size_type, Allocator)
  -> unordered_multiset<T, hash<T>, equal_to<T>, Allocator>; // C++17

template<class T, class Hash, class Allocator>
unordered_multiset(initializer_list<T>, typename see below::size_type, Hash, Allocator)
  -> unordered_multiset<T, Hash, equal_to<T>, Allocator>; // C++17

template <class Value, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
              unordered_multiset<Value, Hash, Pred, Alloc>& y)
              noexcept(noexcept(x.swap(y)));

template <class K, class T, class H, class P, class A, class Predicate>
    typename unordered_set<K, T, H, P, A>::size_type
    erase_if(unordered_set<K, T, H, P, A>& c, Predicate pred);       // C++20

template <class K, class T, class H, class P, class A, class Predicate>
    typename unordered_multiset<K, T, H, P, A>::size_type
    erase_if(unordered_multiset<K, T, H, P, A>& c, Predicate pred);  // C++20


template <class Value, class Hash, class Pred, class Alloc>
    bool
    operator==(const unordered_multiset<Value, Hash, Pred, Alloc>& x,
               const unordered_multiset<Value, Hash, Pred, Alloc>& y);

template <class Value, class Hash, class Pred, class Alloc>
    bool
    operator!=(const unordered_multiset<Value, Hash, Pred, Alloc>& x,
               const unordered_multiset<Value, Hash, Pred, Alloc>& y); // removed in C++20
}  // std

*/

// clang-format on

#include <__algorithm/is_permutation.h>
#include <__assert>
#include <__config>
#include <__functional/is_transparent.h>
#include <__functional/operations.h>
#include <__hash_table>
#include <__iterator/distance.h>
#include <__iterator/erase_if_container.h>
#include <__iterator/iterator_traits.h>
#include <__iterator/ranges_iterator_traits.h>
#include <__memory/addressof.h>
#include <__memory/allocator.h>
#include <__memory_resource/polymorphic_allocator.h>
#include <__node_handle>
#include <__ranges/concepts.h>
#include <__ranges/container_compatible_range.h>
#include <__ranges/from_range.h>
#include <__type_traits/is_allocator.h>
#include <__utility/forward.h>
#include <version>

// standard-mandated includes

// [iterator.range]
#include <__iterator/access.h>
#include <__iterator/data.h>
#include <__iterator/empty.h>
#include <__iterator/reverse_access.h>
#include <__iterator/size.h>

// [unord.set.syn]
#include <compare>
#include <initializer_list>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

template <class _Value, class _Hash, class _Pred, class _Alloc>
class unordered_multiset;

template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>, class _Alloc = allocator<_Value> >
class _LIBCPP_TEMPLATE_VIS unordered_set {
public:
  // types
  typedef _Value key_type;
  typedef key_type value_type;
  typedef __type_identity_t<_Hash> hasher;
  typedef __type_identity_t<_Pred> key_equal;
  typedef __type_identity_t<_Alloc> allocator_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  static_assert(__check_valid_allocator<allocator_type>::value, "");
  static_assert(is_same<value_type, typename allocator_type::value_type>::value,
                "Allocator::value_type must be same type as value_type");

private:
  typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;

  __table __table_;

public:
  typedef typename __table::pointer pointer;
  typedef typename __table::const_pointer const_pointer;
  typedef typename __table::size_type size_type;
  typedef typename __table::difference_type difference_type;

  typedef typename __table::const_iterator iterator;
  typedef typename __table::const_iterator const_iterator;
  typedef typename __table::const_local_iterator local_iterator;
  typedef typename __table::const_local_iterator const_local_iterator;

#if _LIBCPP_STD_VER >= 17
  typedef __set_node_handle<typename __table::__node, allocator_type> node_type;
  typedef __insert_return_type<iterator, node_type> insert_return_type;
#endif

  template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
  friend class _LIBCPP_TEMPLATE_VIS unordered_set;
  template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
  friend class _LIBCPP_TEMPLATE_VIS unordered_multiset;

  _LIBCPP_HIDE_FROM_ABI unordered_set() _NOEXCEPT_(is_nothrow_default_constructible<__table>::value) {}
  explicit _LIBCPP_HIDE_FROM_ABI
  unordered_set(size_type __n, const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
#if _LIBCPP_STD_VER >= 14
  inline _LIBCPP_HIDE_FROM_ABI unordered_set(size_type __n, const allocator_type& __a)
      : unordered_set(__n, hasher(), key_equal(), __a) {}
  inline _LIBCPP_HIDE_FROM_ABI unordered_set(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_set(__n, __hf, key_equal(), __a) {}
#endif
  _LIBCPP_HIDE_FROM_ABI
  unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a);
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI unordered_set(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI
  unordered_set(_InputIterator __first,
                _InputIterator __last,
                size_type __n,
                const hasher& __hf     = hasher(),
                const key_equal& __eql = key_equal());
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI unordered_set(
      _InputIterator __first,
      _InputIterator __last,
      size_type __n,
      const hasher& __hf,
      const key_equal& __eql,
      const allocator_type& __a);

#if _LIBCPP_STD_VER >= 23
  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI unordered_set(
      from_range_t,
      _Range&& __range,
      size_type __n             = /*implementation-defined*/ 0,
      const hasher& __hf        = hasher(),
      const key_equal& __eql    = key_equal(),
      const allocator_type& __a = allocator_type())
      : __table_(__hf, __eql, __a) {
    if (__n > 0) {
      __table_.__rehash_unique(__n);
    }
    insert_range(std::forward<_Range>(__range));
  }
#endif

#if _LIBCPP_STD_VER >= 14
  template <class _InputIterator>
  inline _LIBCPP_HIDE_FROM_ABI
  unordered_set(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_set(__first, __last, __n, hasher(), key_equal(), __a) {}
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI unordered_set(
      _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_set(__first, __last, __n, __hf, key_equal(), __a) {}
#endif

#if _LIBCPP_STD_VER >= 23
  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI unordered_set(from_range_t, _Range&& __range, size_type __n, const allocator_type& __a)
      : unordered_set(from_range, std::forward<_Range>(__range), __n, hasher(), key_equal(), __a) {}

  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI
  unordered_set(from_range_t, _Range&& __range, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_set(from_range, std::forward<_Range>(__range), __n, __hf, key_equal(), __a) {}
#endif

  _LIBCPP_HIDE_FROM_ABI explicit unordered_set(const allocator_type& __a);
  _LIBCPP_HIDE_FROM_ABI unordered_set(const unordered_set& __u);
  _LIBCPP_HIDE_FROM_ABI unordered_set(const unordered_set& __u, const allocator_type& __a);
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_HIDE_FROM_ABI unordered_set(unordered_set&& __u) _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
  _LIBCPP_HIDE_FROM_ABI unordered_set(unordered_set&& __u, const allocator_type& __a);
  _LIBCPP_HIDE_FROM_ABI unordered_set(initializer_list<value_type> __il);
  _LIBCPP_HIDE_FROM_ABI
  unordered_set(initializer_list<value_type> __il,
                size_type __n,
                const hasher& __hf     = hasher(),
                const key_equal& __eql = key_equal());
  _LIBCPP_HIDE_FROM_ABI unordered_set(
      initializer_list<value_type> __il,
      size_type __n,
      const hasher& __hf,
      const key_equal& __eql,
      const allocator_type& __a);
#  if _LIBCPP_STD_VER >= 14
  inline _LIBCPP_HIDE_FROM_ABI
  unordered_set(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_set(__il, __n, hasher(), key_equal(), __a) {}
  inline _LIBCPP_HIDE_FROM_ABI
  unordered_set(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_set(__il, __n, __hf, key_equal(), __a) {}
#  endif
#endif // _LIBCPP_CXX03_LANG
  _LIBCPP_HIDE_FROM_ABI ~unordered_set() {
    static_assert(sizeof(std::__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), "");
  }

  _LIBCPP_HIDE_FROM_ABI unordered_set& operator=(const unordered_set& __u) {
    __table_ = __u.__table_;
    return *this;
  }
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_HIDE_FROM_ABI unordered_set& operator=(unordered_set&& __u)
      _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
  _LIBCPP_HIDE_FROM_ABI unordered_set& operator=(initializer_list<value_type> __il);
#endif // _LIBCPP_CXX03_LANG

  _LIBCPP_HIDE_FROM_ABI allocator_type get_allocator() const _NOEXCEPT {
    return allocator_type(__table_.__node_alloc());
  }

  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI bool empty() const _NOEXCEPT { return __table_.size() == 0; }
  _LIBCPP_HIDE_FROM_ABI size_type size() const _NOEXCEPT { return __table_.size(); }
  _LIBCPP_HIDE_FROM_ABI size_type max_size() const _NOEXCEPT { return __table_.max_size(); }

  _LIBCPP_HIDE_FROM_ABI iterator begin() _NOEXCEPT { return __table_.begin(); }
  _LIBCPP_HIDE_FROM_ABI iterator end() _NOEXCEPT { return __table_.end(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator begin() const _NOEXCEPT { return __table_.begin(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator end() const _NOEXCEPT { return __table_.end(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator cbegin() const _NOEXCEPT { return __table_.begin(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator cend() const _NOEXCEPT { return __table_.end(); }

#ifndef _LIBCPP_CXX03_LANG
  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> emplace(_Args&&... __args) {
    return __table_.__emplace_unique(std::forward<_Args>(__args)...);
  }
  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator emplace_hint(const_iterator, _Args&&... __args) {
    return __table_.__emplace_unique(std::forward<_Args>(__args)...).first;
  }

  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> insert(value_type&& __x) {
    return __table_.__insert_unique(std::move(__x));
  }
  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator, value_type&& __x) { return insert(std::move(__x)).first; }

  _LIBCPP_HIDE_FROM_ABI void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }
#endif // _LIBCPP_CXX03_LANG
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> insert(const value_type& __x) { return __table_.__insert_unique(__x); }

  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator, const value_type& __x) { return insert(__x).first; }
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI void insert(_InputIterator __first, _InputIterator __last);

#if _LIBCPP_STD_VER >= 23
  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI void insert_range(_Range&& __range) {
    for (auto&& __element : __range) {
      __table_.__insert_unique(std::forward<decltype(__element)>(__element));
    }
  }
#endif

  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __p) { return __table_.erase(__p); }
  _LIBCPP_HIDE_FROM_ABI size_type erase(const key_type& __k) { return __table_.__erase_unique(__k); }
  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __first, const_iterator __last) {
    return __table_.erase(__first, __last);
  }
  _LIBCPP_HIDE_FROM_ABI void clear() _NOEXCEPT { __table_.clear(); }

#if _LIBCPP_STD_VER >= 17
  _LIBCPP_HIDE_FROM_ABI insert_return_type insert(node_type&& __nh) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
                                        "node_type with incompatible allocator passed to unordered_set::insert()");
    return __table_.template __node_handle_insert_unique< node_type, insert_return_type>(std::move(__nh));
  }
  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __h, node_type&& __nh) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
                                        "node_type with incompatible allocator passed to unordered_set::insert()");
    return __table_.template __node_handle_insert_unique<node_type>(__h, std::move(__nh));
  }
  _LIBCPP_HIDE_FROM_ABI node_type extract(key_type const& __key) {
    return __table_.template __node_handle_extract<node_type>(__key);
  }
  _LIBCPP_HIDE_FROM_ABI node_type extract(const_iterator __it) {
    return __table_.template __node_handle_extract<node_type>(__it);
  }

  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    __table_.__node_handle_merge_unique(__source.__table_);
  }
  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    __table_.__node_handle_merge_unique(__source.__table_);
  }
  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    __table_.__node_handle_merge_unique(__source.__table_);
  }
  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    __table_.__node_handle_merge_unique(__source.__table_);
  }
#endif

  _LIBCPP_HIDE_FROM_ABI void swap(unordered_set& __u) _NOEXCEPT_(__is_nothrow_swappable_v<__table>) {
    __table_.swap(__u.__table_);
  }

  _LIBCPP_HIDE_FROM_ABI hasher hash_function() const { return __table_.hash_function(); }
  _LIBCPP_HIDE_FROM_ABI key_equal key_eq() const { return __table_.key_eq(); }

  _LIBCPP_HIDE_FROM_ABI iterator find(const key_type& __k) { return __table_.find(__k); }
  _LIBCPP_HIDE_FROM_ABI const_iterator find(const key_type& __k) const { return __table_.find(__k); }
#if _LIBCPP_STD_VER >= 20
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI iterator find(const _K2& __k) {
    return __table_.find(__k);
  }
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI const_iterator find(const _K2& __k) const {
    return __table_.find(__k);
  }
#endif // _LIBCPP_STD_VER >= 20

  _LIBCPP_HIDE_FROM_ABI size_type count(const key_type& __k) const { return __table_.__count_unique(__k); }
#if _LIBCPP_STD_VER >= 20
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI size_type count(const _K2& __k) const {
    return __table_.__count_unique(__k);
  }
#endif // _LIBCPP_STD_VER >= 20

#if _LIBCPP_STD_VER >= 20
  _LIBCPP_HIDE_FROM_ABI bool contains(const key_type& __k) const { return find(__k) != end(); }

  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI bool contains(const _K2& __k) const {
    return find(__k) != end();
  }
#endif // _LIBCPP_STD_VER >= 20

  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const key_type& __k) {
    return __table_.__equal_range_unique(__k);
  }
  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __table_.__equal_range_unique(__k);
  }
#if _LIBCPP_STD_VER >= 20
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const _K2& __k) {
    return __table_.__equal_range_unique(__k);
  }
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
    return __table_.__equal_range_unique(__k);
  }
#endif // _LIBCPP_STD_VER >= 20

  _LIBCPP_HIDE_FROM_ABI size_type bucket_count() const _NOEXCEPT { return __table_.bucket_count(); }
  _LIBCPP_HIDE_FROM_ABI size_type max_bucket_count() const _NOEXCEPT { return __table_.max_bucket_count(); }

  _LIBCPP_HIDE_FROM_ABI size_type bucket_size(size_type __n) const { return __table_.bucket_size(__n); }
  _LIBCPP_HIDE_FROM_ABI size_type bucket(const key_type& __k) const { return __table_.bucket(__k); }

  _LIBCPP_HIDE_FROM_ABI local_iterator begin(size_type __n) { return __table_.begin(__n); }
  _LIBCPP_HIDE_FROM_ABI local_iterator end(size_type __n) { return __table_.end(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator end(size_type __n) const { return __table_.cend(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }

  _LIBCPP_HIDE_FROM_ABI float load_factor() const _NOEXCEPT { return __table_.load_factor(); }
  _LIBCPP_HIDE_FROM_ABI float max_load_factor() const _NOEXCEPT { return __table_.max_load_factor(); }
  _LIBCPP_HIDE_FROM_ABI void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }
  _LIBCPP_HIDE_FROM_ABI void rehash(size_type __n) { __table_.__rehash_unique(__n); }
  _LIBCPP_HIDE_FROM_ABI void reserve(size_type __n) { __table_.__reserve_unique(__n); }
};

#if _LIBCPP_STD_VER >= 17
template <class _InputIterator,
          class _Hash      = hash<__iter_value_type<_InputIterator>>,
          class _Pred      = equal_to<__iter_value_type<_InputIterator>>,
          class _Allocator = allocator<__iter_value_type<_InputIterator>>,
          class            = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class            = enable_if_t<!__is_allocator<_Hash>::value>,
          class            = enable_if_t<!is_integral<_Hash>::value>,
          class            = enable_if_t<!__is_allocator<_Pred>::value>,
          class            = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(_InputIterator,
              _InputIterator,
              typename allocator_traits<_Allocator>::size_type = 0,
              _Hash                                            = _Hash(),
              _Pred                                            = _Pred(),
              _Allocator = _Allocator()) -> unordered_set<__iter_value_type<_InputIterator>, _Hash, _Pred, _Allocator>;

#  if _LIBCPP_STD_VER >= 23
template <ranges::input_range _Range,
          class _Hash      = hash<ranges::range_value_t<_Range>>,
          class _Pred      = equal_to<ranges::range_value_t<_Range>>,
          class _Allocator = allocator<ranges::range_value_t<_Range>>,
          class            = enable_if_t<!__is_allocator<_Hash>::value>,
          class            = enable_if_t<!is_integral<_Hash>::value>,
          class            = enable_if_t<!__is_allocator<_Pred>::value>,
          class            = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(
    from_range_t,
    _Range&&,
    typename allocator_traits<_Allocator>::size_type = 0,
    _Hash                                            = _Hash(),
    _Pred                                            = _Pred(),
    _Allocator = _Allocator()) -> unordered_set<ranges::range_value_t<_Range>, _Hash, _Pred, _Allocator>; // C++23
#  endif

template <class _Tp,
          class _Hash      = hash<_Tp>,
          class _Pred      = equal_to<_Tp>,
          class _Allocator = allocator<_Tp>,
          class            = enable_if_t<!__is_allocator<_Hash>::value>,
          class            = enable_if_t<!is_integral<_Hash>::value>,
          class            = enable_if_t<!__is_allocator<_Pred>::value>,
          class            = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(initializer_list<_Tp>,
              typename allocator_traits<_Allocator>::size_type = 0,
              _Hash                                            = _Hash(),
              _Pred                                            = _Pred(),
              _Allocator = _Allocator()) -> unordered_set<_Tp, _Hash, _Pred, _Allocator>;

template <class _InputIterator,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
    -> unordered_set<__iter_value_type<_InputIterator>,
                     hash<__iter_value_type<_InputIterator>>,
                     equal_to<__iter_value_type<_InputIterator>>,
                     _Allocator>;

template <class _InputIterator,
          class _Hash,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<!__is_allocator<_Hash>::value>,
          class = enable_if_t<!is_integral<_Hash>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
    -> unordered_set<__iter_value_type<_InputIterator>, _Hash, equal_to<__iter_value_type<_InputIterator>>, _Allocator>;

#  if _LIBCPP_STD_VER >= 23

template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Allocator)
    -> unordered_set<ranges::range_value_t<_Range>,
                     hash<ranges::range_value_t<_Range>>,
                     equal_to<ranges::range_value_t<_Range>>,
                     _Allocator>;

template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(from_range_t, _Range&&, _Allocator)
    -> unordered_set<ranges::range_value_t<_Range>,
                     hash<ranges::range_value_t<_Range>>,
                     equal_to<ranges::range_value_t<_Range>>,
                     _Allocator>;

template <ranges::input_range _Range,
          class _Hash,
          class _Allocator,
          class = enable_if_t<!__is_allocator<_Hash>::value>,
          class = enable_if_t<!is_integral<_Hash>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
    -> unordered_set<ranges::range_value_t<_Range>, _Hash, equal_to<ranges::range_value_t<_Range>>, _Allocator>;

#  endif

template <class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Allocator)
    -> unordered_set<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;

template <class _Tp,
          class _Hash,
          class _Allocator,
          class = enable_if_t<!__is_allocator<_Hash>::value>,
          class = enable_if_t<!is_integral<_Hash>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
    -> unordered_set<_Tp, _Hash, equal_to<_Tp>, _Allocator>;
#endif

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_unique(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
    size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a) {
  __table_.__rehash_unique(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(_InputIterator __first, _InputIterator __last) {
  insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
    _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_unique(__n);
  insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
    _InputIterator __first,
    _InputIterator __last,
    size_type __n,
    const hasher& __hf,
    const key_equal& __eql,
    const allocator_type& __a)
    : __table_(__hf, __eql, __a) {
  __table_.__rehash_unique(__n);
  insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(const allocator_type& __a) : __table_(__a) {}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(const unordered_set& __u) : __table_(__u.__table_) {
  __table_.__rehash_unique(__u.bucket_count());
  insert(__u.begin(), __u.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(const unordered_set& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a) {
  __table_.__rehash_unique(__u.bucket_count());
  insert(__u.begin(), __u.end());
}

#ifndef _LIBCPP_CXX03_LANG

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(unordered_set&& __u)
    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)
    : __table_(std::move(__u.__table_)) {}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(unordered_set&& __u, const allocator_type& __a)
    : __table_(std::move(__u.__table_), __a) {
  if (__a != __u.get_allocator()) {
    iterator __i = __u.begin();
    while (__u.size() != 0)
      __table_.__insert_unique(std::move(__u.__table_.remove(__i++)->__get_value()));
  }
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(initializer_list<value_type> __il) {
  insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
    initializer_list<value_type> __il, size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_unique(__n);
  insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
    initializer_list<value_type> __il,
    size_type __n,
    const hasher& __hf,
    const key_equal& __eql,
    const allocator_type& __a)
    : __table_(__hf, __eql, __a) {
  __table_.__rehash_unique(__n);
  insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_set<_Value, _Hash, _Pred, _Alloc>&
unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_set&& __u)
    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value) {
  __table_ = std::move(__u.__table_);
  return *this;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_set<_Value, _Hash, _Pred, _Alloc>&
unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(initializer_list<value_type> __il) {
  __table_.__assign_unique(__il.begin(), __il.end());
  return *this;
}

#endif // _LIBCPP_CXX03_LANG

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline void unordered_set<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first, _InputIterator __last) {
  for (; __first != __last; ++__first)
    __table_.__insert_unique(*__first);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline _LIBCPP_HIDE_FROM_ABI void
swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x, unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
  __x.swap(__y);
}

#if _LIBCPP_STD_VER >= 20
template <class _Value, class _Hash, class _Pred, class _Alloc, class _Predicate>
inline _LIBCPP_HIDE_FROM_ABI typename unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type
erase_if(unordered_set<_Value, _Hash, _Pred, _Alloc>& __c, _Predicate __pred) {
  return std::__libcpp_erase_if_container(__c, __pred);
}
#endif

template <class _Value, class _Hash, class _Pred, class _Alloc>
_LIBCPP_HIDE_FROM_ABI bool operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
                                      const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y) {
  if (__x.size() != __y.size())
    return false;
  typedef typename unordered_set<_Value, _Hash, _Pred, _Alloc>::const_iterator const_iterator;
  for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end(); __i != __ex; ++__i) {
    const_iterator __j = __y.find(*__i);
    if (__j == __ey || !(*__i == *__j))
      return false;
  }
  return true;
}

#if _LIBCPP_STD_VER <= 17

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline _LIBCPP_HIDE_FROM_ABI bool operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
                                             const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y) {
  return !(__x == __y);
}

#endif

template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>, class _Alloc = allocator<_Value> >
class _LIBCPP_TEMPLATE_VIS unordered_multiset {
public:
  // types
  typedef _Value key_type;
  typedef key_type value_type;
  typedef __type_identity_t<_Hash> hasher;
  typedef __type_identity_t<_Pred> key_equal;
  typedef __type_identity_t<_Alloc> allocator_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  static_assert(is_same<value_type, typename allocator_type::value_type>::value,
                "Allocator::value_type must be same type as value_type");

private:
  typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;

  __table __table_;

public:
  typedef typename __table::pointer pointer;
  typedef typename __table::const_pointer const_pointer;
  typedef typename __table::size_type size_type;
  typedef typename __table::difference_type difference_type;

  typedef typename __table::const_iterator iterator;
  typedef typename __table::const_iterator const_iterator;
  typedef typename __table::const_local_iterator local_iterator;
  typedef typename __table::const_local_iterator const_local_iterator;

#if _LIBCPP_STD_VER >= 17
  typedef __set_node_handle<typename __table::__node, allocator_type> node_type;
#endif

  template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
  friend class _LIBCPP_TEMPLATE_VIS unordered_set;
  template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
  friend class _LIBCPP_TEMPLATE_VIS unordered_multiset;

  _LIBCPP_HIDE_FROM_ABI unordered_multiset() _NOEXCEPT_(is_nothrow_default_constructible<__table>::value) {}
  explicit _LIBCPP_HIDE_FROM_ABI
  unordered_multiset(size_type __n, const hasher& __hf = hasher(), const key_equal& __eql = key_equal());
  _LIBCPP_HIDE_FROM_ABI
  unordered_multiset(size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a);
#if _LIBCPP_STD_VER >= 14
  inline _LIBCPP_HIDE_FROM_ABI unordered_multiset(size_type __n, const allocator_type& __a)
      : unordered_multiset(__n, hasher(), key_equal(), __a) {}
  inline _LIBCPP_HIDE_FROM_ABI unordered_multiset(size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multiset(__n, __hf, key_equal(), __a) {}
#endif
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(
      _InputIterator __first,
      _InputIterator __last,
      size_type __n,
      const hasher& __hf     = hasher(),
      const key_equal& __eql = key_equal());
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(
      _InputIterator __first,
      _InputIterator __last,
      size_type __n,
      const hasher& __hf,
      const key_equal& __eql,
      const allocator_type& __a);

#if _LIBCPP_STD_VER >= 23
  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(
      from_range_t,
      _Range&& __range,
      size_type __n             = /*implementation-defined*/ 0,
      const hasher& __hf        = hasher(),
      const key_equal& __eql    = key_equal(),
      const allocator_type& __a = allocator_type())
      : __table_(__hf, __eql, __a) {
    if (__n > 0) {
      __table_.__rehash_multi(__n);
    }
    insert_range(std::forward<_Range>(__range));
  }
#endif

#if _LIBCPP_STD_VER >= 14
  template <class _InputIterator>
  inline _LIBCPP_HIDE_FROM_ABI
  unordered_multiset(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)
      : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a) {}
  template <class _InputIterator>
  inline _LIBCPP_HIDE_FROM_ABI unordered_multiset(
      _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a) {}
#endif

#if _LIBCPP_STD_VER >= 23
  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(from_range_t, _Range&& __range, size_type __n, const allocator_type& __a)
      : unordered_multiset(from_range, std::forward<_Range>(__range), __n, hasher(), key_equal(), __a) {}

  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI
  unordered_multiset(from_range_t, _Range&& __range, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multiset(from_range, std::forward<_Range>(__range), __n, __hf, key_equal(), __a) {}
#endif

  _LIBCPP_HIDE_FROM_ABI explicit unordered_multiset(const allocator_type& __a);
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(const unordered_multiset& __u);
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(const unordered_multiset& __u, const allocator_type& __a);
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(unordered_multiset&& __u)
      _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(unordered_multiset&& __u, const allocator_type& __a);
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(initializer_list<value_type> __il);
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(
      initializer_list<value_type> __il,
      size_type __n,
      const hasher& __hf     = hasher(),
      const key_equal& __eql = key_equal());
  _LIBCPP_HIDE_FROM_ABI unordered_multiset(
      initializer_list<value_type> __il,
      size_type __n,
      const hasher& __hf,
      const key_equal& __eql,
      const allocator_type& __a);
#  if _LIBCPP_STD_VER >= 14
  inline _LIBCPP_HIDE_FROM_ABI
  unordered_multiset(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
      : unordered_multiset(__il, __n, hasher(), key_equal(), __a) {}
  inline _LIBCPP_HIDE_FROM_ABI
  unordered_multiset(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)
      : unordered_multiset(__il, __n, __hf, key_equal(), __a) {}
#  endif
#endif // _LIBCPP_CXX03_LANG
  _LIBCPP_HIDE_FROM_ABI ~unordered_multiset() {
    static_assert(sizeof(std::__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), "");
  }

  _LIBCPP_HIDE_FROM_ABI unordered_multiset& operator=(const unordered_multiset& __u) {
    __table_ = __u.__table_;
    return *this;
  }
#ifndef _LIBCPP_CXX03_LANG
  _LIBCPP_HIDE_FROM_ABI unordered_multiset& operator=(unordered_multiset&& __u)
      _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
  _LIBCPP_HIDE_FROM_ABI unordered_multiset& operator=(initializer_list<value_type> __il);
#endif // _LIBCPP_CXX03_LANG

  _LIBCPP_HIDE_FROM_ABI allocator_type get_allocator() const _NOEXCEPT {
    return allocator_type(__table_.__node_alloc());
  }

  _LIBCPP_NODISCARD _LIBCPP_HIDE_FROM_ABI bool empty() const _NOEXCEPT { return __table_.size() == 0; }
  _LIBCPP_HIDE_FROM_ABI size_type size() const _NOEXCEPT { return __table_.size(); }
  _LIBCPP_HIDE_FROM_ABI size_type max_size() const _NOEXCEPT { return __table_.max_size(); }

  _LIBCPP_HIDE_FROM_ABI iterator begin() _NOEXCEPT { return __table_.begin(); }
  _LIBCPP_HIDE_FROM_ABI iterator end() _NOEXCEPT { return __table_.end(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator begin() const _NOEXCEPT { return __table_.begin(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator end() const _NOEXCEPT { return __table_.end(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator cbegin() const _NOEXCEPT { return __table_.begin(); }
  _LIBCPP_HIDE_FROM_ABI const_iterator cend() const _NOEXCEPT { return __table_.end(); }

#ifndef _LIBCPP_CXX03_LANG
  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator emplace(_Args&&... __args) {
    return __table_.__emplace_multi(std::forward<_Args>(__args)...);
  }
  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator emplace_hint(const_iterator __p, _Args&&... __args) {
    return __table_.__emplace_hint_multi(__p, std::forward<_Args>(__args)...);
  }

  _LIBCPP_HIDE_FROM_ABI iterator insert(value_type&& __x) { return __table_.__insert_multi(std::move(__x)); }
  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __p, value_type&& __x) {
    return __table_.__insert_multi(__p, std::move(__x));
  }
  _LIBCPP_HIDE_FROM_ABI void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }
#endif // _LIBCPP_CXX03_LANG

  _LIBCPP_HIDE_FROM_ABI iterator insert(const value_type& __x) { return __table_.__insert_multi(__x); }

  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __p, const value_type& __x) {
    return __table_.__insert_multi(__p, __x);
  }

  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI void insert(_InputIterator __first, _InputIterator __last);

#if _LIBCPP_STD_VER >= 23
  template <_ContainerCompatibleRange<value_type> _Range>
  _LIBCPP_HIDE_FROM_ABI void insert_range(_Range&& __range) {
    for (auto&& __element : __range) {
      __table_.__insert_multi(std::forward<decltype(__element)>(__element));
    }
  }
#endif

#if _LIBCPP_STD_VER >= 17
  _LIBCPP_HIDE_FROM_ABI iterator insert(node_type&& __nh) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
                                        "node_type with incompatible allocator passed to unordered_multiset::insert()");
    return __table_.template __node_handle_insert_multi<node_type>(std::move(__nh));
  }
  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator __hint, node_type&& __nh) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(__nh.empty() || __nh.get_allocator() == get_allocator(),
                                        "node_type with incompatible allocator passed to unordered_multiset::insert()");
    return __table_.template __node_handle_insert_multi<node_type>(__hint, std::move(__nh));
  }
  _LIBCPP_HIDE_FROM_ABI node_type extract(const_iterator __position) {
    return __table_.template __node_handle_extract<node_type>(__position);
  }
  _LIBCPP_HIDE_FROM_ABI node_type extract(key_type const& __key) {
    return __table_.template __node_handle_extract<node_type>(__key);
  }

  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    return __table_.__node_handle_merge_multi(__source.__table_);
  }
  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    return __table_.__node_handle_merge_multi(__source.__table_);
  }
  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    return __table_.__node_handle_merge_multi(__source.__table_);
  }
  template <class _H2, class _P2>
  _LIBCPP_HIDE_FROM_ABI void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source) {
    _LIBCPP_ASSERT_COMPATIBLE_ALLOCATOR(
        __source.get_allocator() == get_allocator(), "merging container with incompatible allocator");
    return __table_.__node_handle_merge_multi(__source.__table_);
  }
#endif

  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __p) { return __table_.erase(__p); }
  _LIBCPP_HIDE_FROM_ABI size_type erase(const key_type& __k) { return __table_.__erase_multi(__k); }
  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __first, const_iterator __last) {
    return __table_.erase(__first, __last);
  }
  _LIBCPP_HIDE_FROM_ABI void clear() _NOEXCEPT { __table_.clear(); }

  _LIBCPP_HIDE_FROM_ABI void swap(unordered_multiset& __u) _NOEXCEPT_(__is_nothrow_swappable_v<__table>) {
    __table_.swap(__u.__table_);
  }

  _LIBCPP_HIDE_FROM_ABI hasher hash_function() const { return __table_.hash_function(); }
  _LIBCPP_HIDE_FROM_ABI key_equal key_eq() const { return __table_.key_eq(); }

  _LIBCPP_HIDE_FROM_ABI iterator find(const key_type& __k) { return __table_.find(__k); }
  _LIBCPP_HIDE_FROM_ABI const_iterator find(const key_type& __k) const { return __table_.find(__k); }
#if _LIBCPP_STD_VER >= 20
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI iterator find(const _K2& __k) {
    return __table_.find(__k);
  }
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI const_iterator find(const _K2& __k) const {
    return __table_.find(__k);
  }
#endif // _LIBCPP_STD_VER >= 20

  _LIBCPP_HIDE_FROM_ABI size_type count(const key_type& __k) const { return __table_.__count_multi(__k); }
#if _LIBCPP_STD_VER >= 20
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI size_type count(const _K2& __k) const {
    return __table_.__count_multi(__k);
  }
#endif // _LIBCPP_STD_VER >= 20

#if _LIBCPP_STD_VER >= 20
  _LIBCPP_HIDE_FROM_ABI bool contains(const key_type& __k) const { return find(__k) != end(); }

  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI bool contains(const _K2& __k) const {
    return find(__k) != end();
  }
#endif // _LIBCPP_STD_VER >= 20

  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const key_type& __k) {
    return __table_.__equal_range_multi(__k);
  }
  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __table_.__equal_range_multi(__k);
  }
#if _LIBCPP_STD_VER >= 20
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> equal_range(const _K2& __k) {
    return __table_.__equal_range_multi(__k);
  }
  template <class _K2, enable_if_t<__is_transparent_v<hasher, _K2> && __is_transparent_v<key_equal, _K2>>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
    return __table_.__equal_range_multi(__k);
  }
#endif // _LIBCPP_STD_VER >= 20

  _LIBCPP_HIDE_FROM_ABI size_type bucket_count() const _NOEXCEPT { return __table_.bucket_count(); }
  _LIBCPP_HIDE_FROM_ABI size_type max_bucket_count() const _NOEXCEPT { return __table_.max_bucket_count(); }

  _LIBCPP_HIDE_FROM_ABI size_type bucket_size(size_type __n) const { return __table_.bucket_size(__n); }
  _LIBCPP_HIDE_FROM_ABI size_type bucket(const key_type& __k) const { return __table_.bucket(__k); }

  _LIBCPP_HIDE_FROM_ABI local_iterator begin(size_type __n) { return __table_.begin(__n); }
  _LIBCPP_HIDE_FROM_ABI local_iterator end(size_type __n) { return __table_.end(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator begin(size_type __n) const { return __table_.cbegin(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator end(size_type __n) const { return __table_.cend(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator cbegin(size_type __n) const { return __table_.cbegin(__n); }
  _LIBCPP_HIDE_FROM_ABI const_local_iterator cend(size_type __n) const { return __table_.cend(__n); }

  _LIBCPP_HIDE_FROM_ABI float load_factor() const _NOEXCEPT { return __table_.load_factor(); }
  _LIBCPP_HIDE_FROM_ABI float max_load_factor() const _NOEXCEPT { return __table_.max_load_factor(); }
  _LIBCPP_HIDE_FROM_ABI void max_load_factor(float __mlf) { __table_.max_load_factor(__mlf); }
  _LIBCPP_HIDE_FROM_ABI void rehash(size_type __n) { __table_.__rehash_multi(__n); }
  _LIBCPP_HIDE_FROM_ABI void reserve(size_type __n) { __table_.__reserve_multi(__n); }
};

#if _LIBCPP_STD_VER >= 17
template <class _InputIterator,
          class _Hash      = hash<__iter_value_type<_InputIterator>>,
          class _Pred      = equal_to<__iter_value_type<_InputIterator>>,
          class _Allocator = allocator<__iter_value_type<_InputIterator>>,
          class            = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class            = enable_if_t<!__is_allocator<_Hash>::value>,
          class            = enable_if_t<!is_integral<_Hash>::value>,
          class            = enable_if_t<!__is_allocator<_Pred>::value>,
          class            = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(
    _InputIterator,
    _InputIterator,
    typename allocator_traits<_Allocator>::size_type = 0,
    _Hash                                            = _Hash(),
    _Pred                                            = _Pred(),
    _Allocator = _Allocator()) -> unordered_multiset<__iter_value_type<_InputIterator>, _Hash, _Pred, _Allocator>;

#  if _LIBCPP_STD_VER >= 23
template <ranges::input_range _Range,
          class _Hash      = hash<ranges::range_value_t<_Range>>,
          class _Pred      = equal_to<ranges::range_value_t<_Range>>,
          class _Allocator = allocator<ranges::range_value_t<_Range>>,
          class            = enable_if_t<!__is_allocator<_Hash>::value>,
          class            = enable_if_t<!is_integral<_Hash>::value>,
          class            = enable_if_t<!__is_allocator<_Pred>::value>,
          class            = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(
    from_range_t,
    _Range&&,
    typename allocator_traits<_Allocator>::size_type = 0,
    _Hash                                            = _Hash(),
    _Pred                                            = _Pred(),
    _Allocator = _Allocator()) -> unordered_multiset<ranges::range_value_t<_Range>, _Hash, _Pred, _Allocator>; // C++23
#  endif

template <class _Tp,
          class _Hash      = hash<_Tp>,
          class _Pred      = equal_to<_Tp>,
          class _Allocator = allocator<_Tp>,
          class            = enable_if_t<!__is_allocator<_Hash>::value>,
          class            = enable_if_t<!is_integral<_Hash>::value>,
          class            = enable_if_t<!__is_allocator<_Pred>::value>,
          class            = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(initializer_list<_Tp>,
                   typename allocator_traits<_Allocator>::size_type = 0,
                   _Hash                                            = _Hash(),
                   _Pred                                            = _Pred(),
                   _Allocator = _Allocator()) -> unordered_multiset<_Tp, _Hash, _Pred, _Allocator>;

template <class _InputIterator,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
    -> unordered_multiset<__iter_value_type<_InputIterator>,
                          hash<__iter_value_type<_InputIterator>>,
                          equal_to<__iter_value_type<_InputIterator>>,
                          _Allocator>;

template <class _InputIterator,
          class _Hash,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<!__is_allocator<_Hash>::value>,
          class = enable_if_t<!is_integral<_Hash>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
    -> unordered_multiset<__iter_value_type<_InputIterator>,
                          _Hash,
                          equal_to<__iter_value_type<_InputIterator>>,
                          _Allocator>;

#  if _LIBCPP_STD_VER >= 23

template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Allocator)
    -> unordered_multiset<ranges::range_value_t<_Range>,
                          hash<ranges::range_value_t<_Range>>,
                          equal_to<ranges::range_value_t<_Range>>,
                          _Allocator>;

template <ranges::input_range _Range, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(from_range_t, _Range&&, _Allocator)
    -> unordered_multiset<ranges::range_value_t<_Range>,
                          hash<ranges::range_value_t<_Range>>,
                          equal_to<ranges::range_value_t<_Range>>,
                          _Allocator>;

template <ranges::input_range _Range,
          class _Hash,
          class _Allocator,
          class = enable_if_t<!__is_allocator<_Hash>::value>,
          class = enable_if_t<!is_integral<_Hash>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(from_range_t, _Range&&, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
    -> unordered_multiset<ranges::range_value_t<_Range>, _Hash, equal_to<ranges::range_value_t<_Range>>, _Allocator>;

#  endif

template <class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Allocator)
    -> unordered_multiset<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;

template <class _Tp,
          class _Hash,
          class _Allocator,
          class = enable_if_t<!__is_allocator<_Hash>::value>,
          class = enable_if_t<!is_integral<_Hash>::value>,
          class = enable_if_t<__is_allocator<_Allocator>::value>>
unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
    -> unordered_multiset<_Tp, _Hash, equal_to<_Tp>, _Allocator>;
#endif

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_multi(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    size_type __n, const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
    : __table_(__hf, __eql, __a) {
  __table_.__rehash_multi(__n);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(_InputIterator __first, _InputIterator __last) {
  insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    _InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_multi(__n);
  insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    _InputIterator __first,
    _InputIterator __last,
    size_type __n,
    const hasher& __hf,
    const key_equal& __eql,
    const allocator_type& __a)
    : __table_(__hf, __eql, __a) {
  __table_.__rehash_multi(__n);
  insert(__first, __last);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(const allocator_type& __a)
    : __table_(__a) {}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(const unordered_multiset& __u)
    : __table_(__u.__table_) {
  __table_.__rehash_multi(__u.bucket_count());
  insert(__u.begin(), __u.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    const unordered_multiset& __u, const allocator_type& __a)
    : __table_(__u.__table_, __a) {
  __table_.__rehash_multi(__u.bucket_count());
  insert(__u.begin(), __u.end());
}

#ifndef _LIBCPP_CXX03_LANG

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(unordered_multiset&& __u)
    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)
    : __table_(std::move(__u.__table_)) {}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    unordered_multiset&& __u, const allocator_type& __a)
    : __table_(std::move(__u.__table_), __a) {
  if (__a != __u.get_allocator()) {
    iterator __i = __u.begin();
    while (__u.size() != 0)
      __table_.__insert_multi(std::move(__u.__table_.remove(__i++)->__get_value()));
  }
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(initializer_list<value_type> __il) {
  insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    initializer_list<value_type> __il, size_type __n, const hasher& __hf, const key_equal& __eql)
    : __table_(__hf, __eql) {
  __table_.__rehash_multi(__n);
  insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
    initializer_list<value_type> __il,
    size_type __n,
    const hasher& __hf,
    const key_equal& __eql,
    const allocator_type& __a)
    : __table_(__hf, __eql, __a) {
  __table_.__rehash_multi(__n);
  insert(__il.begin(), __il.end());
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_multiset&& __u)
    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value) {
  __table_ = std::move(__u.__table_);
  return *this;
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(initializer_list<value_type> __il) {
  __table_.__assign_multi(__il.begin(), __il.end());
  return *this;
}

#endif // _LIBCPP_CXX03_LANG

template <class _Value, class _Hash, class _Pred, class _Alloc>
template <class _InputIterator>
inline void unordered_multiset<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first, _InputIterator __last) {
  for (; __first != __last; ++__first)
    __table_.__insert_multi(*__first);
}

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline _LIBCPP_HIDE_FROM_ABI void
swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x, unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
  __x.swap(__y);
}

#if _LIBCPP_STD_VER >= 20
template <class _Value, class _Hash, class _Pred, class _Alloc, class _Predicate>
inline _LIBCPP_HIDE_FROM_ABI typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::size_type
erase_if(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __c, _Predicate __pred) {
  return std::__libcpp_erase_if_container(__c, __pred);
}
#endif

template <class _Value, class _Hash, class _Pred, class _Alloc>
_LIBCPP_HIDE_FROM_ABI bool operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
                                      const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y) {
  if (__x.size() != __y.size())
    return false;
  typedef typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::const_iterator const_iterator;
  typedef pair<const_iterator, const_iterator> _EqRng;
  for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;) {
    _EqRng __xeq = __x.equal_range(*__i);
    _EqRng __yeq = __y.equal_range(*__i);
    if (std::distance(__xeq.first, __xeq.second) != std::distance(__yeq.first, __yeq.second) ||
        !std::is_permutation(__xeq.first, __xeq.second, __yeq.first))
      return false;
    __i = __xeq.second;
  }
  return true;
}

#if _LIBCPP_STD_VER <= 17

template <class _Value, class _Hash, class _Pred, class _Alloc>
inline _LIBCPP_HIDE_FROM_ABI bool operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
                                             const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y) {
  return !(__x == __y);
}

#endif

_LIBCPP_END_NAMESPACE_STD

#if _LIBCPP_STD_VER >= 17
_LIBCPP_BEGIN_NAMESPACE_STD
namespace pmr {
template <class _KeyT, class _HashT = std::hash<_KeyT>, class _PredT = std::equal_to<_KeyT>>
using unordered_set _LIBCPP_AVAILABILITY_PMR = std::unordered_set<_KeyT, _HashT, _PredT, polymorphic_allocator<_KeyT>>;

template <class _KeyT, class _HashT = std::hash<_KeyT>, class _PredT = std::equal_to<_KeyT>>
using unordered_multiset _LIBCPP_AVAILABILITY_PMR =
    std::unordered_multiset<_KeyT, _HashT, _PredT, polymorphic_allocator<_KeyT>>;
} // namespace pmr
_LIBCPP_END_NAMESPACE_STD
#endif

_LIBCPP_POP_MACROS

#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
#  include <concepts>
#  include <cstdlib>
#  include <functional>
#  include <iterator>
#  include <stdexcept>
#  include <type_traits>
#endif

#endif // _LIBCPP_UNORDERED_SET
