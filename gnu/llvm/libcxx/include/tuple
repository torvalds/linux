// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_TUPLE
#define _LIBCPP_TUPLE

// clang-format off

/*
    tuple synopsis

namespace std
{

template <class... T>
class tuple {
public:
    explicit(see-below) constexpr tuple();
    explicit(see-below) tuple(const T&...);  // constexpr in C++14
    template <class... U>
        explicit(see-below) tuple(U&&...);  // constexpr in C++14
    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template<class... UTypes>
        constexpr explicit(see-below) tuple(tuple<UTypes...>&);  // C++23
    template <class... U>
        explicit(see-below) tuple(const tuple<U...>&);  // constexpr in C++14
    template <class... U>
        explicit(see-below) tuple(tuple<U...>&&);  // constexpr in C++14
    template<class... UTypes>
        constexpr explicit(see-below) tuple(const tuple<UTypes...>&&); // C++23

    template<class U1, class U2>
        constexpr explicit(see-below) tuple(pair<U1, U2>&);  // iff sizeof...(Types) == 2 // C++23
    template <class U1, class U2>
        explicit(see-below) tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
    template <class U1, class U2>
        explicit(see-below) tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14
    template<class U1, class U2>
        constexpr explicit(see-below) tuple(const pair<U1, U2>&&);  // iff sizeof...(Types) == 2 // C++23

    // allocator-extended constructors
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a);
    template <class Alloc>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const T&...);          // constexpr in C++20
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, U&&...);               // constexpr in C++20
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, const tuple&);                             // constexpr in C++20
    template <class Alloc>
        tuple(allocator_arg_t, const Alloc& a, tuple&&);                                  // constexpr in C++20
    template<class Alloc, class... UTypes>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);                      // C++23
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);   // constexpr in C++20
    template <class Alloc, class... U>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);        // constexpr in C++20
    template<class Alloc, class... UTypes>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);               // C++23
    template<class Alloc, class U1, class U2>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);                          // C++23
    template <class Alloc, class U1, class U2>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);  // constexpr in C++20
    template <class Alloc, class U1, class U2>
        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);       // constexpr in C++20
    template<class Alloc, class U1, class U2>
        constexpr explicit(see-below)
          tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);                   // C++23

    tuple& operator=(const tuple&);                                                       // constexpr in C++20
    constexpr const tuple& operator=(const tuple&) const;                                 // C++23
    tuple& operator=(tuple&&) noexcept(is_nothrow_move_assignable_v<T> && ...);           // constexpr in C++20
    constexpr const tuple& operator=(tuple&&) const;                                      // C++23
    template <class... U>
        tuple& operator=(const tuple<U...>&);                                             // constexpr in C++20
    template<class... UTypes>
        constexpr const tuple& operator=(const tuple<UTypes...>&) const;                  // C++23
    template <class... U>
        tuple& operator=(tuple<U...>&&);                                                  // constexpr in C++20
    template<class... UTypes>
        constexpr const tuple& operator=(tuple<UTypes...>&&) const;                       // C++23
    template <class U1, class U2>
        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2                   // constexpr in C++20
    template<class U1, class U2>
        constexpr const tuple& operator=(const pair<U1, U2>&) const;   // iff sizeof...(Types) == 2 // C++23
    template <class U1, class U2>
        tuple& operator=(pair<U1, U2>&&); // iff sizeof...(T) == 2                        // constexpr in C++20
    template<class U1, class U2>
        constexpr const tuple& operator=(pair<U1, U2>&&) const;  // iff sizeof...(Types) == 2 // C++23

    template<class U, size_t N>
        tuple& operator=(array<U, N> const&) // iff sizeof...(T) == N, EXTENSION
    template<class U, size_t N>
        tuple& operator=(array<U, N>&&) // iff sizeof...(T) == N, EXTENSION

    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));               // constexpr in C++20
    constexpr void swap(const tuple&) const noexcept(see-below);                          // C++23
};


template<class... TTypes, class... UTypes, template<class> class TQual, template<class> class UQual> // since C++23
  requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
  using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
};

template<class... TTypes, class... UTypes>                                // since C++23
  requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
struct common_type<tuple<TTypes...>, tuple<UTypes...>> {
  using type = tuple<common_type_t<TTypes, UTypes>...>;
};

template <class ...T>
tuple(T...) -> tuple<T...>;                                         // since C++17
template <class T1, class T2>
tuple(pair<T1, T2>) -> tuple<T1, T2>;                               // since C++17
template <class Alloc, class ...T>
tuple(allocator_arg_t, Alloc, T...) -> tuple<T...>;                 // since C++17
template <class Alloc, class T1, class T2>
tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;       // since C++17
template <class Alloc, class ...T>
tuple(allocator_arg_t, Alloc, tuple<T...>) -> tuple<T...>;          // since C++17

struct ignore-type { // exposition only                             // Since C++26
  constexpr const ignore-type&
    operator=(const auto &) const noexcept
      { return *this; }
};
inline constexpr ignore-type ignore;

template <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
template <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
template <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
template <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14

// [tuple.apply], calling a function with a tuple of arguments:
template <class F, class Tuple>
  constexpr decltype(auto) apply(F&& f, Tuple&& t) noexcept(see below);  // C++17 noexcept since C++23
template <class T, class Tuple>
  constexpr T make_from_tuple(Tuple&& t); // C++17

// 20.4.1.4, tuple helper classes:
template <class T> struct tuple_size; // undefined
template <class... T> struct tuple_size<tuple<T...>>;
template <class T>
 inline constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17
template <size_t I, class T> struct tuple_element; // undefined
template <size_t I, class... T> struct tuple_element<I, tuple<T...>>;
template <size_t I, class T>
  using tuple_element_t = typename tuple_element <I, T>::type; // C++14

// 20.4.1.5, element access:
template <size_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&
    get(tuple<T...>&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    const typename tuple_element<I, tuple<T...>>::type&
    get(const tuple<T...>&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    typename tuple_element<I, tuple<T...>>::type&&
    get(tuple<T...>&&) noexcept; // constexpr in C++14
template <size_t I, class... T>
    const typename tuple_element<I, tuple<T...>>::type&&
    get(const tuple<T...>&&) noexcept; // constexpr in C++14

template <class T1, class... T>
    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
template <class T1, class... T>
    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14
template <class T1, class... T>
    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14
template <class T1, class... T>
    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14

// 20.4.1.6, relational operators:
template<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
template<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
template<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
template<class... T, class... U>
  constexpr common_comparison_category_t<synth-three-way-result<T, U>...>
    operator<=>(const tuple<T...>&, const tuple<U...>&);                                  // since C++20

template <class... Types, class Alloc>
  struct uses_allocator<tuple<Types...>, Alloc>;

template <class... Types>
  void
  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));

template <class... Types>
  constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(see-below);   // C++23

}  // std

*/

// clang-format on

#include <__compare/common_comparison_category.h>
#include <__compare/synth_three_way.h>
#include <__config>
#include <__functional/invoke.h>
#include <__fwd/array.h>
#include <__fwd/pair.h>
#include <__fwd/tuple.h>
#include <__memory/allocator_arg_t.h>
#include <__memory/uses_allocator.h>
#include <__tuple/find_index.h>
#include <__tuple/ignore.h>
#include <__tuple/make_tuple_types.h>
#include <__tuple/sfinae_helpers.h>
#include <__tuple/tuple_element.h>
#include <__tuple/tuple_indices.h>
#include <__tuple/tuple_like_ext.h>
#include <__tuple/tuple_size.h>
#include <__tuple/tuple_types.h>
#include <__type_traits/common_reference.h>
#include <__type_traits/common_type.h>
#include <__type_traits/conditional.h>
#include <__type_traits/conjunction.h>
#include <__type_traits/copy_cvref.h>
#include <__type_traits/disjunction.h>
#include <__type_traits/is_arithmetic.h>
#include <__type_traits/is_assignable.h>
#include <__type_traits/is_constructible.h>
#include <__type_traits/is_convertible.h>
#include <__type_traits/is_empty.h>
#include <__type_traits/is_final.h>
#include <__type_traits/is_implicitly_default_constructible.h>
#include <__type_traits/is_nothrow_assignable.h>
#include <__type_traits/is_nothrow_constructible.h>
#include <__type_traits/is_reference.h>
#include <__type_traits/is_same.h>
#include <__type_traits/is_swappable.h>
#include <__type_traits/is_trivially_relocatable.h>
#include <__type_traits/lazy.h>
#include <__type_traits/maybe_const.h>
#include <__type_traits/nat.h>
#include <__type_traits/negation.h>
#include <__type_traits/remove_cvref.h>
#include <__type_traits/remove_reference.h>
#include <__type_traits/unwrap_ref.h>
#include <__utility/forward.h>
#include <__utility/integer_sequence.h>
#include <__utility/move.h>
#include <__utility/piecewise_construct.h>
#include <__utility/swap.h>
#include <cstddef>
#include <version>

// standard-mandated includes

// [tuple.syn]
#include <compare>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

#ifndef _LIBCPP_CXX03_LANG

// __tuple_leaf

template <size_t _Ip, class _Hp, bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value >
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y) noexcept(__is_nothrow_swappable_v<_Hp>) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool _Ep>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x,
     const __tuple_leaf<_Ip, _Hp, _Ep>& __y) noexcept(__is_nothrow_swappable_v<const _Hp>) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool>
class __tuple_leaf {
  _Hp __value_;

  template <class _Tp>
  static _LIBCPP_HIDE_FROM_ABI constexpr bool __can_bind_reference() {
#  if __has_keyword(__reference_binds_to_temporary)
    return !__reference_binds_to_temporary(_Hp, _Tp);
#  else
    return true;
#  endif
  }

public:
  _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_leaf& operator=(const __tuple_leaf&) = delete;

  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf() noexcept(is_nothrow_default_constructible<_Hp>::value) : __value_() {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) : __value_() {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
      : __value_(allocator_arg_t(), __a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : __value_(__a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to default construct a reference element in a tuple");
  }

  template <
      class _Tp,
      __enable_if_t<_And<_IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(_Tp&& __t) noexcept(is_nothrow_constructible<_Hp, _Tp>::value)
      : __value_(std::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp&&>(),
                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
      : __value_(std::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp&&>(),
                  "Attempted construction of reference element binds to a temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
      : __value_(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {
    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
  }

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
      : __value_(std::forward<_Tp>(__t), __a) {
    static_assert(!is_reference<_Hp>::value, "Attempted to uses-allocator construct a reference element in a tuple");
  }

  _LIBCPP_HIDE_FROM_ABI __tuple_leaf(const __tuple_leaf& __t) = default;
  _LIBCPP_HIDE_FROM_ABI __tuple_leaf(__tuple_leaf&& __t)      = default;

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int
  swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable_v<__tuple_leaf>) {
    std::swap(*this, __t);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(const __tuple_leaf& __t) const
      noexcept(__is_nothrow_swappable_v<const __tuple_leaf>) {
    std::swap(*this, __t);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 _Hp& get() _NOEXCEPT { return __value_; }
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT { return __value_; }
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true> : private _Hp {
public:
  _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_leaf& operator=(const __tuple_leaf&) = delete;

  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf() noexcept(is_nothrow_default_constructible<_Hp>::value) {}

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
      : _Hp(allocator_arg_t(), __a) {}

  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a) : _Hp(__a) {}

  template <class _Tp,
            __enable_if_t< _And< _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>, is_constructible<_Hp, _Tp> >::value,
                           int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_leaf(_Tp&& __t) noexcept(is_nothrow_constructible<_Hp, _Tp>::value)
      : _Hp(std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
      : _Hp(std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
      : _Hp(allocator_arg_t(), __a, std::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
      : _Hp(std::forward<_Tp>(__t), __a) {}

  __tuple_leaf(__tuple_leaf const&) = default;
  __tuple_leaf(__tuple_leaf&&)      = default;

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int
  swap(__tuple_leaf& __t) noexcept(__is_nothrow_swappable_v<__tuple_leaf>) {
    std::swap(*this, __t);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 int swap(const __tuple_leaf& __rhs) const
      noexcept(__is_nothrow_swappable_v<const __tuple_leaf>) {
    std::swap(*this, __rhs);
    return 0;
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 _Hp& get() _NOEXCEPT { return static_cast<_Hp&>(*this); }
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT {
    return static_cast<const _Hp&>(*this);
  }
};

template <class... _Tp>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void __swallow(_Tp&&...) _NOEXCEPT {}

template <class _Tp>
struct __all_default_constructible;

template <class... _Tp>
struct __all_default_constructible<__tuple_types<_Tp...>> : __all<is_default_constructible<_Tp>::value...> {};

// __tuple_impl

template <class _Indx, class... _Tp>
struct __tuple_impl;

template <size_t... _Indx, class... _Tp>
struct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>... {
  _LIBCPP_HIDE_FROM_ABI constexpr __tuple_impl() noexcept(
      __all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

  template <size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_impl(
      __tuple_indices<_Uf...>,
      __tuple_types<_Tf...>,
      __tuple_indices<_Ul...>,
      __tuple_types<_Tl...>,
      _Up&&... __u) noexcept(__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&
                             __all<is_nothrow_default_constructible<_Tl>::value...>::value)
      : __tuple_leaf<_Uf, _Tf>(std::forward<_Up>(__u))..., __tuple_leaf<_Ul, _Tl>()... {}

  template <class _Alloc, size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl, class... _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit __tuple_impl(
      allocator_arg_t,
      const _Alloc& __a,
      __tuple_indices<_Uf...>,
      __tuple_types<_Tf...>,
      __tuple_indices<_Ul...>,
      __tuple_types<_Tl...>,
      _Up&&... __u)
      : __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a, std::forward<_Up>(__u))...,
        __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)... {}

  template <class _Tuple, __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_impl(_Tuple&& __t) noexcept(
      (__all<is_nothrow_constructible<
           _Tp,
           typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
      : __tuple_leaf<_Indx, _Tp>(
            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::get<_Indx>(__t)))... {}

  template <class _Alloc, class _Tuple, __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
      : __tuple_leaf<_Indx, _Tp>(
            __uses_alloc_ctor<_Tp,
                              _Alloc,
                              typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(),
            __a,
            std::forward<typename tuple_element<_Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::get<_Indx>(__t)))... {}

  __tuple_impl(const __tuple_impl&) = default;
  __tuple_impl(__tuple_impl&&)      = default;

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
  swap(__tuple_impl& __t) noexcept(__all<__is_nothrow_swappable_v<_Tp>...>::value) {
    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
  }

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void swap(const __tuple_impl& __t) const
      noexcept(__all<__is_nothrow_swappable_v<const _Tp>...>::value) {
    std::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
  }
};

template <class _Dest, class _Source, size_t... _Np>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
__memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
  std::__swallow(((std::get<_Np>(__dest) = std::get<_Np>(__source)), void(), 0)...);
}

template <class _Dest, class _Source, class... _Up, size_t... _Np>
_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 void
__memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
  std::__swallow(((std::get<_Np>(__dest) = std::forward<_Up>(std::get<_Np>(__source))), void(), 0)...);
}

template <class... _Tp>
class _LIBCPP_TEMPLATE_VIS tuple {
  typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;

  _BaseT __base_;

  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;
  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Jp, tuple<_Up...> >::type&
  get(const tuple<_Up...>&) _NOEXCEPT;
  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Jp, tuple<_Up...> >::type&&
  get(tuple<_Up...>&&) _NOEXCEPT;
  template <size_t _Jp, class... _Up>
  friend _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Jp, tuple<_Up...> >::type&&
  get(const tuple<_Up...>&&) _NOEXCEPT;

public:
  using __trivially_relocatable = __conditional_t<_And<__libcpp_is_trivially_relocatable<_Tp>...>::value, tuple, void>;

  // [tuple.cnstr]

  // tuple() constructors (including allocator_arg_t variants)
  template <template <class...> class _IsImpDefault                = __is_implicitly_default_constructible,
            template <class...> class _IsDefault                   = is_default_constructible,
            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value)
      tuple() noexcept(_And<is_nothrow_default_constructible<_Tp>...>::value) {}

  template <class _Alloc,
            template <class...> class _IsImpDefault                = __is_implicitly_default_constructible,
            template <class...> class _IsDefault                   = is_default_constructible,
            __enable_if_t< _And< _IsDefault<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, _IsImpDefault<_Tp>...> >::value)
      tuple(allocator_arg_t, _Alloc const& __a)
      : __base_(allocator_arg_t(),
                __a,
                __tuple_indices<>(),
                __tuple_types<>(),
                typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                __tuple_types<_Tp...>()) {}

  // tuple(const T&...) constructors (including allocator_arg_t variants)
  template <template <class...> class _And = _And,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value)
      tuple(const _Tp&... __t) noexcept(_And<is_nothrow_copy_constructible<_Tp>...>::value)
      : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...) {}

  template <class _Alloc,
            template <class...> class _And = _And,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) >= 1>, is_copy_constructible<_Tp>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const _Tp&... __t)
      : __base_(allocator_arg_t(),
                __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(),
                __t...) {}

  // tuple(U&& ...) constructors (including allocator_arg_t variants)
  template <class... _Up>
  struct _IsThisTuple : false_type {};
  template <class _Up>
  struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> {};

  template <class... _Up>
  struct _EnableUTypesCtor
      : _And< _BoolConstant<sizeof...(_Tp) >= 1>,
              _Not<_IsThisTuple<_Up...> >, // extension to allow mis-behaved user constructors
              is_constructible<_Tp, _Up>... > {};

  template <class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
                           int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(_Up&&... __u) noexcept(_And<is_nothrow_constructible<_Tp, _Up>...>::value)
      : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                std::forward<_Up>(__u)...) {}

  template <class _Alloc,
            class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>, _EnableUTypesCtor<_Up...> >::value,
                           int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
      : __base_(allocator_arg_t(),
                __a,
                typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
                std::forward<_Up>(__u)...) {}

  // Copy and move constructors (including the allocator_arg_t variants)
  tuple(const tuple&) = default;
  tuple(tuple&&)      = default;

  template <class _Alloc,
            template <class...> class _And                                  = _And,
            __enable_if_t< _And<is_copy_constructible<_Tp>...>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
      : __base_(allocator_arg_t(), __alloc, __t) {}

  template <class _Alloc,
            template <class...> class _And                                  = _And,
            __enable_if_t< _And<is_move_constructible<_Tp>...>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}

  // tuple(const tuple<U...>&) constructors (including allocator_arg_t variants)

  template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
  struct _EnableCtorFromUTypesTuple : false_type {};

  template <class _OtherTuple, class... _Up>
  struct _EnableCtorFromUTypesTuple<
      _OtherTuple,
      tuple<_Up...>,
      // the length of the packs needs to checked first otherwise the 2 packs cannot be expanded simultaneously below
      __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>>
      : _And<
            // the two conditions below are not in spec. The purpose is to disable the UTypes Ctor when copy/move Ctor
            // can work. Otherwise, is_constructible can trigger hard error in those cases
            // https://godbolt.org/z/M94cGdKcE
            _Not<is_same<_OtherTuple, const tuple&> >,
            _Not<is_same<_OtherTuple, tuple&&> >,
            is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
            _Lazy<_Or,
                  _BoolConstant<sizeof...(_Tp) != 1>,
                  // _Tp and _Up are 1-element packs - the pack expansions look
                  // weird to avoid tripping up the type traits in degenerate cases
                  _Lazy<_And,
                        _Not<is_same<_Tp, _Up> >...,
                        _Not<is_convertible<_OtherTuple, _Tp> >...,
                        _Not<is_constructible<_Tp, _OtherTuple> >... > > > {};

  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value)
      tuple(const tuple<_Up...>& __t) noexcept(_And<is_nothrow_constructible<_Tp, const _Up&>...>::value)
      : __base_(__t) {}

  template <class... _Up,
            class _Alloc,
            __enable_if_t< _And< _EnableCtorFromUTypesTuple<const tuple<_Up...>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
      : __base_(allocator_arg_t(), __a, __t) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(tuple<U...>&) constructors (including allocator_arg_t variants)

  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value) tuple(tuple<_Up...>& __t)
      : __base_(__t) {}

  template <class _Alloc, class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<_Up&, _Tp>...>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, tuple<_Up...>& __t)
      : __base_(allocator_arg_t(), __alloc, __t) {}
#  endif // _LIBCPP_STD_VER >= 23

  // tuple(tuple<U...>&&) constructors (including allocator_arg_t variants)
  template <class... _Up, __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(tuple<_Up...>&& __t) noexcept(_And<is_nothrow_constructible<_Tp, _Up>...>::value)
      : __base_(std::move(__t)) {}

  template <class _Alloc,
            class... _Up,
            __enable_if_t< _And< _EnableCtorFromUTypesTuple<tuple<_Up...>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_Lazy<_And, is_convertible<_Up, _Tp>...> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
      : __base_(allocator_arg_t(), __a, std::move(__t)) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(const tuple<U...>&&) constructors (including allocator_arg_t variants)

  template <class... _Up, enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
      tuple(const tuple<_Up...>&& __t)
      : __base_(std::move(__t)) {}

  template <class _Alloc,
            class... _Up,
            enable_if_t< _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_Lazy<_And, is_convertible<const _Up&&, _Tp>...>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, const tuple<_Up...>&& __t)
      : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}
#  endif // _LIBCPP_STD_VER >= 23

  // tuple(const pair<U1, U2>&) constructors (including allocator_arg_t variants)

  template <template <class...> class _Pred,
            class _Pair,
            class _DecayedPair = __remove_cvref_t<_Pair>,
            class _Tuple       = tuple>
  struct _CtorPredicateFromPair : false_type {};

  template <template <class...> class _Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _CtorPredicateFromPair<_Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And< _Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >, _Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> > > {};

  template <class _Pair>
  struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair> {};

  template <class _Pair>
  struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair> {};

  template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
  struct _BothImplicitlyConvertible : false_type {};

  template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And< is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>, is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2> > {};

  template <class _Up1,
            class _Up2,
            template <class...> class _And                                                   = _And,
            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value)
      tuple(const pair<_Up1, _Up2>& __p) noexcept(_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value)
      : __base_(__p) {}

  template <class _Alloc,
            class _Up1,
            class _Up2,
            template <class...> class _And                                                   = _And,
            __enable_if_t< _And< _EnableCtorFromPair<const pair<_Up1, _Up2>&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
      : __base_(allocator_arg_t(), __a, __p) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(pair<U1, U2>&) constructors (including allocator_arg_t variants)

  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<pair<_U1, _U2>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
      tuple(pair<_U1, _U2>& __p)
      : __base_(__p) {}

  template <class _Alloc,
            class _U1,
            class _U2,
            enable_if_t< _EnableCtorFromPair<std::pair<_U1, _U2>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, pair<_U1, _U2>& __p)
      : __base_(allocator_arg_t(), __alloc, __p) {}
#  endif

  // tuple(pair<U1, U2>&&) constructors (including allocator_arg_t variants)

  template <class _Up1,
            class _Up2,
            template <class...> class _And                                              = _And,
            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX14 explicit(_Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value)
      tuple(pair<_Up1, _Up2>&& __p) noexcept(_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value)
      : __base_(std::move(__p)) {}

  template <class _Alloc,
            class _Up1,
            class _Up2,
            template <class...> class _And                                              = _And,
            __enable_if_t< _And< _EnableCtorFromPair<pair<_Up1, _Up2>&&> >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_CONSTEXPR_SINCE_CXX20 explicit(_Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> >::value)
      tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
      : __base_(allocator_arg_t(), __a, std::move(__p)) {}

#  if _LIBCPP_STD_VER >= 23
  // tuple(const pair<U1, U2>&&) constructors (including allocator_arg_t variants)

  template <class _U1, class _U2, enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
      tuple(const pair<_U1, _U2>&& __p)
      : __base_(std::move(__p)) {}

  template <class _Alloc,
            class _U1,
            class _U2,
            enable_if_t< _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
      tuple(allocator_arg_t, const _Alloc& __alloc, const pair<_U1, _U2>&& __p)
      : __base_(allocator_arg_t(), __alloc, std::move(__p)) {}
#  endif // _LIBCPP_STD_VER >= 23

  // [tuple.assign]
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple&
  operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
      noexcept(_And<is_nothrow_copy_assignable<_Tp>...>::value) {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

#  if _LIBCPP_STD_VER >= 23
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple const& __tuple) const
    requires(_And<is_copy_assignable<const _Tp>...>::value)
  {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple&& __tuple) const
    requires(_And<is_assignable<const _Tp&, _Tp>...>::value)
  {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }
#  endif // _LIBCPP_STD_VER >= 23

  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple&
  operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
      noexcept(_And<is_nothrow_move_assignable<_Tp>...>::value) {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Tp...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <
      class... _Up,
      __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up const&>... >::value,
                     int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(tuple<_Up...> const& __tuple)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value) {
    std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <class... _Up,
            __enable_if_t< _And< _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>, is_assignable<_Tp&, _Up>... >::value,
                           int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(tuple<_Up...>&& __tuple)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up>...>::value) {
    std::__memberwise_forward_assign(
        *this, std::move(__tuple), __tuple_types<_Up...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

#  if _LIBCPP_STD_VER >= 23
  template <class... _UTypes,
            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
                              is_assignable<const _Tp&, const _UTypes&>...>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(const tuple<_UTypes...>& __u) const {
    std::__memberwise_copy_assign(*this, __u, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  template <class... _UTypes,
            enable_if_t< _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
                              is_assignable<const _Tp&, _UTypes>...>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(tuple<_UTypes...>&& __u) const {
    std::__memberwise_forward_assign(
        *this, __u, __tuple_types<_UTypes...>(), typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }
#  endif // _LIBCPP_STD_VER >= 23

  template <template <class...> class _Pred,
            bool _Const,
            class _Pair,
            class _DecayedPair = __remove_cvref_t<_Pair>,
            class _Tuple       = tuple>
  struct _AssignPredicateFromPair : false_type {};

  template <template <class...> class _Pred, bool _Const, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
  struct _AssignPredicateFromPair<_Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> >
      : _And<_Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
             _Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> > > {};

  template <bool _Const, class _Pair>
  struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};

  template <bool _Const, class _Pair>
  struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};

#  if _LIBCPP_STD_VER >= 23
  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, const pair<_U1, _U2>&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(const pair<_U1, _U2>& __pair) const
      noexcept(_NothrowAssignFromPair<true, const pair<_U1, _U2>&>::value) {
    std::get<0>(*this) = __pair.first;
    std::get<1>(*this) = __pair.second;
    return *this;
  }

  template <class _U1, class _U2, enable_if_t< _EnableAssignFromPair<true, pair<_U1, _U2>&&>::value>* = nullptr>
  _LIBCPP_HIDE_FROM_ABI constexpr const tuple& operator=(pair<_U1, _U2>&& __pair) const
      noexcept(_NothrowAssignFromPair<true, pair<_U1, _U2>&&>::value) {
    std::get<0>(*this) = std::move(__pair.first);
    std::get<1>(*this) = std::move(__pair.second);
    return *this;
  }
#  endif // _LIBCPP_STD_VER >= 23

  template <class _Up1,
            class _Up2,
            __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(pair<_Up1, _Up2> const& __pair)
      noexcept(_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value) {
    std::get<0>(*this) = __pair.first;
    std::get<1>(*this) = __pair.second;
    return *this;
  }

  template <class _Up1, class _Up2, __enable_if_t< _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(pair<_Up1, _Up2>&& __pair)
      noexcept(_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value) {
    std::get<0>(*this) = std::forward<_Up1>(__pair.first);
    std::get<1>(*this) = std::forward<_Up2>(__pair.second);
    return *this;
  }

  // EXTENSION
  template <
      class _Up,
      size_t _Np,
      __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up const&>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(array<_Up, _Np> const& __array)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value) {
    std::__memberwise_copy_assign(*this, __array, typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  // EXTENSION
  template <class _Up,
            size_t _Np,
            class = void,
            __enable_if_t< _And< _BoolConstant<_Np == sizeof...(_Tp)>, is_assignable<_Tp&, _Up>... >::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple& operator=(array<_Up, _Np>&& __array)
      noexcept(_And<is_nothrow_assignable<_Tp&, _Up>...>::value) {
    std::__memberwise_forward_assign(
        *this,
        std::move(__array),
        __tuple_types<_If<true, _Up, _Tp>...>(),
        typename __make_tuple_indices<sizeof...(_Tp)>::type());
    return *this;
  }

  // [tuple.swap]
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple& __t)
      noexcept(__all<__is_nothrow_swappable_v<_Tp>...>::value) {
    __base_.swap(__t.__base_);
  }

#  if _LIBCPP_STD_VER >= 23
  _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple& __t) const
      noexcept(__all<is_nothrow_swappable_v<const _Tp&>...>::value) {
    __base_.swap(__t.__base_);
  }
#  endif // _LIBCPP_STD_VER >= 23
};

template <>
class _LIBCPP_TEMPLATE_VIS tuple<> {
public:
  constexpr tuple() _NOEXCEPT = default;
  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}
  template <class _Alloc>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}
  template <class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(array<_Up, 0>) _NOEXCEPT {}
  template <class _Alloc, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple&) _NOEXCEPT {}
#  if _LIBCPP_STD_VER >= 23
  _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple&) const noexcept {}
#  endif
};

#  if _LIBCPP_STD_VER >= 23
template <class... _TTypes, class... _UTypes, template <class> class _TQual, template <class> class _UQual>
  requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
  using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
};

template <class... _TTypes, class... _UTypes>
  requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
  using type = tuple<common_type_t<_TTypes, _UTypes>...>;
};
#  endif // _LIBCPP_STD_VER >= 23

#  if _LIBCPP_STD_VER >= 17
template <class... _Tp>
tuple(_Tp...) -> tuple<_Tp...>;
template <class _Tp1, class _Tp2>
tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class... _Tp>
tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
template <class _Alloc, class _Tp1, class _Tp2>
tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
template <class _Alloc, class... _Tp>
tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;
#  endif

template <class... _Tp, __enable_if_t<__all<__is_swappable_v<_Tp>...>::value, int> = 0>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
    noexcept(__all<__is_nothrow_swappable_v<_Tp>...>::value) {
  __t.swap(__u);
}

#  if _LIBCPP_STD_VER >= 23
template <class... _Tp>
_LIBCPP_HIDE_FROM_ABI constexpr enable_if_t<__all<is_swappable_v<const _Tp>...>::value, void>
swap(const tuple<_Tp...>& __lhs,
     const tuple<_Tp...>& __rhs) noexcept(__all<is_nothrow_swappable_v<const _Tp>...>::value) {
  __lhs.swap(__rhs);
}
#  endif

// get

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(tuple<_Tp...>& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Ip, tuple<_Tp...> >::type&
get(const tuple<_Tp...>& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(tuple<_Tp...>&& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<type&&>(static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

template <size_t _Ip, class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
get(const tuple<_Tp...>&& __t) _NOEXCEPT {
  typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
  return static_cast<const type&&>(static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
}

#  if _LIBCPP_STD_VER >= 14

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1& get(tuple<_Args...>& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}

template <class _T1, class... _Args>
inline _LIBCPP_HIDE_FROM_ABI constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept {
  return std::get<__find_exactly_one_t<_T1, _Args...>::value>(std::move(__tup));
}

#  endif

// tie

template <class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<_Tp&...> tie(_Tp&... __t) _NOEXCEPT {
  return tuple<_Tp&...>(__t...);
}

template <class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp&&... __t) {
  return tuple<typename __unwrap_ref_decay<_Tp>::type...>(std::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<_Tp&&...> forward_as_tuple(_Tp&&... __t) _NOEXCEPT {
  return tuple<_Tp&&...>(std::forward<_Tp>(__t)...);
}

template <size_t _Ip>
struct __tuple_equal {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp& __x, const _Up& __y) {
    return __tuple_equal<_Ip - 1>()(__x, __y) && std::get<_Ip - 1>(__x) == std::get<_Ip - 1>(__y);
  }
};

template <>
struct __tuple_equal<0> {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp&, const _Up&) {
    return true;
  }
};

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  static_assert(sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
  return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

#  if _LIBCPP_STD_VER >= 20

// operator<=>

template <class... _Tp, class... _Up, size_t... _Is>
_LIBCPP_HIDE_FROM_ABI constexpr auto
__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
  common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
  static_cast<void>(
      ((__result = std::__synth_three_way(std::get<_Is>(__x), std::get<_Is>(__y)), __result != 0) || ...));
  return __result;
}

template <class... _Tp, class... _Up>
  requires(sizeof...(_Tp) == sizeof...(_Up))
_LIBCPP_HIDE_FROM_ABI constexpr common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return std::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
}

#  else // _LIBCPP_STD_VER >= 20

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return !(__x == __y);
}

template <size_t _Ip>
struct __tuple_less {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp& __x, const _Up& __y) {
    const size_t __idx = tuple_size<_Tp>::value - _Ip;
    if (std::get<__idx>(__x) < std::get<__idx>(__y))
      return true;
    if (std::get<__idx>(__y) < std::get<__idx>(__x))
      return false;
    return __tuple_less<_Ip - 1>()(__x, __y);
  }
};

template <>
struct __tuple_less<0> {
  template <class _Tp, class _Up>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool operator()(const _Tp&, const _Up&) {
    return false;
  }
};

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  static_assert(sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
  return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return __y < __x;
}

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return !(__x < __y);
}

template <class... _Tp, class... _Up>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 bool
operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y) {
  return !(__y < __x);
}

#  endif // _LIBCPP_STD_VER >= 20

// tuple_cat

template <class _Tp, class _Up>
struct __tuple_cat_type;

template <class... _Ttypes, class... _Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> > {
  typedef _LIBCPP_NODEBUG tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class... _Tuples>
struct __tuple_cat_return_1 {};

template <class... _Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0> {
  using type _LIBCPP_NODEBUG =
      typename __tuple_cat_type< tuple<_Types...>,
                                 typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type;
};

template <class... _Types, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_1<
          typename __tuple_cat_type< tuple<_Types...>,
                                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type >::type,
          __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
          _Tuple1,
          _Tuples...> {};

template <class... _Tuples>
struct __tuple_cat_return;

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<tuple<>,
                                  __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value,
                                  _Tuple0,
                                  _Tuples...> {};

template <>
struct __tuple_cat_return<> {
  typedef _LIBCPP_NODEBUG tuple<> type;
};

inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 tuple<> tuple_cat() { return tuple<>(); }

template <class _Rp, class _Indices, class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref_imp;

template <class... _Types, size_t... _I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0> {
  typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
  typedef tuple<_Types..., __copy_cvref_t<_Tuple0, typename tuple_element<_I0, _T0>::type>&&...> type;
};

template <class... _Types, size_t... _I0, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
          tuple<_Types...,
                __copy_cvref_t<_Tuple0, typename tuple_element<_I0, __libcpp_remove_reference_t<_Tuple0>>::type>&&...>,
          typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
          _Tuple1,
          _Tuples...> {};

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<
          tuple<>,
          typename __make_tuple_indices< tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value >::type,
          _Tuple0,
          _Tuples...> {};

template <class _Types, class _I0, class _J0>
struct __tuple_cat;

template <class... _Types, size_t... _I0, size_t... _J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> > {
  template <class _Tuple0>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
  typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
  operator()(tuple<_Types...> __t, _Tuple0&& __t0) {
    (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
    return std::forward_as_tuple(
        std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...);
  }

  template <class _Tuple0, class _Tuple1, class... _Tuples>
  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
  typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
  operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&&... __tpls) {
    (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple1> _T1;
    return __tuple_cat<tuple<_Types..., __copy_cvref_t<_Tuple0, typename tuple_element<_J0, _T0>::type>&&...>,
                       typename __make_tuple_indices<sizeof...(_Types) + tuple_size<_T0>::value>::type,
                       typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        std::forward_as_tuple(
            std::forward<_Types>(std::get<_I0>(__t))..., std::get<_J0>(std::forward<_Tuple0>(__t0))...),
        std::forward<_Tuple1>(__t1),
        std::forward<_Tuples>(__tpls)...);
  }
};

template <class _Tuple0, class... _Tuples>
inline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14 typename __tuple_cat_return<_Tuple0, _Tuples...>::type
tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls) {
  typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
  return __tuple_cat<tuple<>, __tuple_indices<>, typename __make_tuple_indices<tuple_size<_T0>::value>::type>()(
      tuple<>(), std::forward<_Tuple0>(__t0), std::forward<_Tuples>(__tpls)...);
}

template <class... _Tp, class _Alloc>
struct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc> : true_type {};

#  if _LIBCPP_STD_VER >= 17
#    define _LIBCPP_NOEXCEPT_RETURN(...)                                                                               \
      noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }

// The _LIBCPP_NOEXCEPT_RETURN macro breaks formatting.
// clang-format off
template <class _Fn, class _Tuple, size_t... _Id>
inline _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto)
__apply_tuple_impl(_Fn&& __f, _Tuple&& __t, __tuple_indices<_Id...>)
    _LIBCPP_NOEXCEPT_RETURN(std::__invoke(std::forward<_Fn>(__f), std::get<_Id>(std::forward<_Tuple>(__t))...))

template <class _Fn, class _Tuple>
inline _LIBCPP_HIDE_FROM_ABI constexpr decltype(auto) apply(_Fn&& __f, _Tuple&& __t)
    _LIBCPP_NOEXCEPT_RETURN(std::__apply_tuple_impl(
        std::forward<_Fn>(__f),
        std::forward<_Tuple>(__t),
        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))

#if _LIBCPP_STD_VER >= 20
template <class _Tp, class _Tuple, size_t... _Idx>
inline _LIBCPP_HIDE_FROM_ABI constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
  noexcept(noexcept(_Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...)))
  requires is_constructible_v<_Tp, decltype(std::get<_Idx>(std::forward<_Tuple>(__t)))...> {
  return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...);
}
#else
template <class _Tp, class _Tuple, size_t... _Idx>
inline _LIBCPP_HIDE_FROM_ABI constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>,
    enable_if_t<is_constructible_v<_Tp, decltype(std::get<_Idx>(std::forward<_Tuple>(__t)))...>> * = nullptr)
    _LIBCPP_NOEXCEPT_RETURN(_Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...))
#endif // _LIBCPP_STD_VER >= 20

template <class _Tp, class _Tuple,
          class _Seq = typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type, class = void>
inline constexpr bool __can_make_from_tuple = false;

template <class _Tp, class _Tuple, size_t... _Idx>
inline constexpr bool __can_make_from_tuple<_Tp, _Tuple, __tuple_indices<_Idx...>,
    enable_if_t<is_constructible_v<_Tp, decltype(std::get<_Idx>(std::declval<_Tuple>()))...>>> = true;

// Based on LWG3528(https://wg21.link/LWG3528) and http://eel.is/c++draft/description#structure.requirements-9,
// the standard allows to impose requirements, we constraint std::make_from_tuple to make std::make_from_tuple
// SFINAE friendly and also avoid worse diagnostic messages. We still keep the constraints of std::__make_from_tuple_impl
// so that std::__make_from_tuple_impl will have the same advantages when used alone.
#if _LIBCPP_STD_VER >= 20
template <class _Tp, class _Tuple>
  requires __can_make_from_tuple<_Tp, _Tuple> // strengthen
#else
template <class _Tp, class _Tuple, class = enable_if_t<__can_make_from_tuple<_Tp, _Tuple>>> // strengthen
#endif // _LIBCPP_STD_VER >= 20
inline _LIBCPP_HIDE_FROM_ABI constexpr _Tp make_from_tuple(_Tuple&& __t)
    _LIBCPP_NOEXCEPT_RETURN(std::__make_from_tuple_impl<_Tp>(
        std::forward<_Tuple>(__t), typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{}))
#    undef _LIBCPP_NOEXCEPT_RETURN

#  endif // _LIBCPP_STD_VER >= 17

#endif // !defined(_LIBCPP_CXX03_LANG)

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

// clang-format on

#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
#  include <exception>
#  include <iosfwd>
#  include <new>
#  include <type_traits>
#  include <typeinfo>
#  include <utility>
#endif

#endif // _LIBCPP_TUPLE
