//===- X86GenRegisterBankInfo.def ----------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file defines all the static objects used by X86RegisterBankInfo.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#ifdef GET_TARGET_REGBANK_INFO_IMPL
RegisterBankInfo::PartialMapping X86GenRegisterBankInfo::PartMappings[]{
    /* StartIdx, Length, RegBank */
    // GPR value
    {0, 8, X86::GPRRegBank},   // :0
    {0, 16, X86::GPRRegBank},  // :1
    {0, 32, X86::GPRRegBank},  // :2
    {0, 64, X86::GPRRegBank},  // :3
    // FR32/64 , xmm registers
    {0, 32, X86::VECRRegBank},  // :4
    {0, 64, X86::VECRRegBank},  // :5
    // VR128/256/512
    {0, 128, X86::VECRRegBank}, // :6
    {0, 256, X86::VECRRegBank}, // :7
    {0, 512, X86::VECRRegBank}, // :8   
    // RFP32/64/80
    {0, 32, X86::PSRRegBank},   // :9
    {0, 64, X86::PSRRegBank},   // :10
    {0, 80, X86::PSRRegBank},   // :11
};
#endif // GET_TARGET_REGBANK_INFO_IMPL

#ifdef GET_TARGET_REGBANK_INFO_CLASS
enum PartialMappingIdx {
  PMI_None = -1,
  PMI_GPR8,
  PMI_GPR16,
  PMI_GPR32,
  PMI_GPR64,
  PMI_FP32,
  PMI_FP64,
  PMI_VEC128,
  PMI_VEC256,
  PMI_VEC512,
  PMI_PSR32,
  PMI_PSR64,
  PMI_PSR80
};
#endif // GET_TARGET_REGBANK_INFO_CLASS

#ifdef GET_TARGET_REGBANK_INFO_IMPL
#define INSTR_3OP(INFO) INFO, INFO, INFO,
#define BREAKDOWN(INDEX, NUM)                                                  \
  { &X86GenRegisterBankInfo::PartMappings[INDEX], NUM }
// ValueMappings.
RegisterBankInfo::ValueMapping X86GenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 3-operands instructions (all binary operations should end up with one of
    // those mapping).
    INSTR_3OP(BREAKDOWN(PMI_GPR8, 1))  // 0: GPR_8
    INSTR_3OP(BREAKDOWN(PMI_GPR16, 1)) // 3: GPR_16
    INSTR_3OP(BREAKDOWN(PMI_GPR32, 1)) // 6: GPR_32
    INSTR_3OP(BREAKDOWN(PMI_GPR64, 1)) // 9: GPR_64    
    INSTR_3OP(BREAKDOWN(PMI_FP32, 1))   // 12: Fp32
    INSTR_3OP(BREAKDOWN(PMI_FP64, 1))   // 15: Fp64
    INSTR_3OP(BREAKDOWN(PMI_VEC128, 1)) // 18: Vec128
    INSTR_3OP(BREAKDOWN(PMI_VEC256, 1)) // 21: Vec256
    INSTR_3OP(BREAKDOWN(PMI_VEC512, 1)) // 24: Vec512    
    INSTR_3OP(BREAKDOWN(PMI_PSR32, 1))  // 25: Rfp32
    INSTR_3OP(BREAKDOWN(PMI_PSR64, 1))  // 26: Rfp64
    INSTR_3OP(BREAKDOWN(PMI_PSR80, 1))  // 27: Rfp80
};
#undef INSTR_3OP
#undef BREAKDOWN
#endif // GET_TARGET_REGBANK_INFO_IMPL

#ifdef GET_TARGET_REGBANK_INFO_CLASS
enum ValueMappingIdx {
  VMI_None = -1,
  VMI_3OpsGpr8Idx =  PMI_GPR8  * 3,
  VMI_3OpsGpr16Idx = PMI_GPR16 * 3,
  VMI_3OpsGpr32Idx = PMI_GPR32 * 3,
  VMI_3OpsGpr64Idx = PMI_GPR64 * 3,  
  VMI_3OpsFp32Idx = PMI_FP32 * 3,
  VMI_3OpsFp64Idx = PMI_FP64 * 3,
  VMI_3OpsVec128Idx = PMI_VEC128 * 3,
  VMI_3OpsVec256Idx = PMI_VEC256 * 3,
  VMI_3OpsVec512Idx = PMI_VEC512 * 3,
  VMI_3OpsPs32Idx = PMI_PSR32 * 3,
  VMI_3OpsPs64Idx = PMI_PSR64 * 3,
  VMI_3OpsPs80Idx = PMI_PSR80 * 3,
};
#undef GET_TARGET_REGBANK_INFO_CLASS
#endif // GET_TARGET_REGBANK_INFO_CLASS

#ifdef GET_TARGET_REGBANK_INFO_IMPL
#undef GET_TARGET_REGBANK_INFO_IMPL
const RegisterBankInfo::ValueMapping *
X86GenRegisterBankInfo::getValueMapping(PartialMappingIdx Idx,
                                        unsigned NumOperands) {
  
  // We can use VMI_3Ops Mapping for all the cases.
  if (NumOperands <= 3 && (Idx >= PMI_GPR8 && Idx <= PMI_PSR80))
    return &ValMappings[(unsigned)Idx * 3];
  
  llvm_unreachable("Unsupported PartialMappingIdx.");
}

#endif // GET_TARGET_REGBANK_INFO_IMPL

