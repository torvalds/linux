//===- PPCGenRegisterBankInfo.def -------------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file defines all the static objects used by PPCRegisterBankInfo.
/// \todo This should be generated by TableGen, because the logic here can be
///  derived from register bank definition. Not yet implemented.
//===----------------------------------------------------------------------===//

namespace llvm {
const RegisterBankInfo::PartialMapping PPCGenRegisterBankInfo::PartMappings[]{
    /* StartIdx, Length, RegBank */
    // 0: GPR 32-bit value.
    {0, 32, PPC::GPRRegBank},
    // 1: GPR 64-bit value.
    {0, 64, PPC::GPRRegBank},
    // 2: FPR 32-bit value
    {0, 32, PPC::FPRRegBank},
    // 3: FPR 64-bit value
    {0, 64, PPC::FPRRegBank},
    // 4: 128-bit vector (VSX, Altivec)
    {0, 128, PPC::VECRegBank},
    // 5: CR 4-bit value
    {0, 4, PPC::CRRegBank},
};

// ValueMappings.
// Pointers to the entries in this array are returned by getValueMapping() and
// getCopyMapping().
//
// The array has the following structure:
// - At index 0 is the invalid entry.
// - After that, the mappings for the register types from PartialMappingIdx
//   follow. Each mapping consists of 3 entries, which is needed to cover
//   3-operands instructions.
// - Last, mappings for cross-register bank moves follow. Since COPY has only
//   2 operands, a mapping consists of 2 entries.
const RegisterBankInfo::ValueMapping PPCGenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 1: GPR 32-bit value.
    {&PPCGenRegisterBankInfo::PartMappings[PMI_GPR32 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_GPR32 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_GPR32 - PMI_Min], 1},
    // 4: GPR 64-bit value.
    {&PPCGenRegisterBankInfo::PartMappings[PMI_GPR64 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_GPR64 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_GPR64 - PMI_Min], 1},
    // 7: FPR 32-bit value.
    {&PPCGenRegisterBankInfo::PartMappings[PMI_FPR32 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_FPR32 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_FPR32 - PMI_Min], 1},
    // 10: FPR 64-bit value.
    {&PPCGenRegisterBankInfo::PartMappings[PMI_FPR64 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_FPR64 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_FPR64 - PMI_Min], 1},
    // 13: 128-bit vector.
    {&PPCGenRegisterBankInfo::PartMappings[PMI_VEC128 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_VEC128 - PMI_Min], 1},
    {&PPCGenRegisterBankInfo::PartMappings[PMI_VEC128 - PMI_Min], 1},
    // 16: CR 4-bit value.
    {&PPCGenRegisterBankInfo::PartMappings[PMI_CR - PMI_Min], 1},
};

// TODO Too simple!
const RegisterBankInfo::ValueMapping *
PPCGenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx) {
  assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");

  unsigned ValMappingIdx = RBIdx - PMI_Min;

  return &ValMappings[1 + 3 * ValMappingIdx];
}

const PPCGenRegisterBankInfo::PartialMappingIdx
  PPCGenRegisterBankInfo::BankIDToCopyMapIdx[]{
    PMI_None,
    PMI_FPR64,  // FPR
    PMI_GPR64,  // GPR
    PMI_VEC128, // VEC
};

// TODO Too simple!
const RegisterBankInfo::ValueMapping *
PPCGenRegisterBankInfo::getCopyMapping(unsigned DstBankID, unsigned SrcBankID,
                                       unsigned Size) {
  assert(DstBankID < PPC::NumRegisterBanks && "Invalid bank ID");
  assert(SrcBankID < PPC::NumRegisterBanks && "Invalid bank ID");
  PartialMappingIdx DstRBIdx = BankIDToCopyMapIdx[DstBankID];
  PartialMappingIdx SrcRBIdx = BankIDToCopyMapIdx[SrcBankID];
  assert(DstRBIdx != PMI_None && "No such mapping");
  assert(SrcRBIdx != PMI_None && "No such mapping");

  if (DstRBIdx == SrcRBIdx)
    return getValueMapping(DstRBIdx);

  assert(Size <= 128 && "Can currently handle types up to 128 bits (vectors)!");
  // TODO: This function needs to be updated to handle all cases for
  //       GPRs, FPRs and vectors. It currently only handles bitcasting to
  //       the same type and has only mainly been tested for bitcasting
  //       between different vector types.
  unsigned ValMappingIdx = DstRBIdx - PMI_Min;

  return &ValMappings[1 + 3 * ValMappingIdx];
}

} // namespace llvm
