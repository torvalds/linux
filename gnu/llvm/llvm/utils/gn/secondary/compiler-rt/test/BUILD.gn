import("//compiler-rt/target.gni")
import("//compiler-rt/test/test.gni")
import("//llvm/lib/DebugInfo/PDB/enable_dia.gni")
import("//llvm/triples.gni")
import("//llvm/utils/gn/build/buildflags.gni")
import("//llvm/utils/gn/build/libs/zlib/enable.gni")
import("//llvm/utils/gn/build/toolchain/compiler.gni")
import("//llvm/utils/gn/build/write_cmake_config.gni")
import("//llvm/version.gni")

ext = ""
if (host_os == "win") {
  ext = ".exe"
}

write_cmake_config("lit_common_configured") {
  input = "lit.common.configured.in"
  output = "$target_gen_dir/lit.common.configured"

  values = [
    "LIT_SITE_CFG_IN_HEADER=## Autogenerated from $input, do not edit",

    "COMPILER_RT_DEFAULT_TARGET_TRIPLE=$llvm_current_triple",
    "COMPILER_RT_DEFAULT_TARGET_ARCH=$crt_current_target_arch",

    "COMPILER_RT_TEST_COMPILER_CFLAGS=$target_flags_string",
    "LLVM_BUILD_MODE=.",
    "LLVM_MAIN_SRC_DIR=" + rebase_path("//llvm"),
    "LLVM_BINARY_DIR=" + rebase_path(root_build_dir),
    "COMPILER_RT_SOURCE_DIR=" + rebase_path("//compiler-rt"),

    # This is only used by tsan to find the path to an instrumented libc++.
    # Since we don't currently support running the tsan tests, leave it empty
    # for now. Eventually it should probably be replaced with some mechanism
    # where the libraries are found in a toolchain dir.
    "COMPILER_RT_BINARY_DIR=",

    # We don't currently support the multiarch runtime layout.
    "LLVM_ENABLE_PER_TARGET_RUNTIME_DIR_PYBOOL=False",

    "LLVM_LIT_TOOLS_DIR=",  # Intentionally empty, matches cmake build.
    "LLVM_TOOLS_DIR=" + rebase_path("$root_build_dir/bin"),
    "LLVM_LIBRARY_OUTPUT_INTDIR=" + rebase_path("$root_build_dir/lib"),

    "LLVM_LIBCXX_USED=0",

    "GOLD_EXECUTABLE=ld",
    "GNU_LD_EXECUTABLE=ld",
    "COMPILER_RT_RESOLVED_TEST_COMPILER=" +
        rebase_path("$root_build_dir/bin/clang") + ext,
    "COMPILER_RT_TEST_COMPILER_ID=Clang",
    "Python3_EXECUTABLE=$python_path",
    "COMPILER_RT_BUILD_STANDALONE_LIBATOMIC_PYBOOL=False",
    "COMPILER_RT_DEBUG_PYBOOL=False",
    "COMPILER_RT_ENABLE_INTERNAL_SYMBOLIZER_PYBOOL=False",
    "COMPILER_RT_INTERCEPT_LIBDISPATCH_PYBOOL=False",
    "COMPILER_RT_RESOLVED_LIBRARY_OUTPUT_DIR=" +
        rebase_path(crt_current_out_dir),
    "COMPILER_RT_RESOLVED_OUTPUT_DIR=" + rebase_path(crt_current_out_dir),
    "COMPILER_RT_EMULATOR=",
    "COMPILER_RT_ASAN_SHADOW_SCALE=",
    "COMPILER_RT_MEMPROF_SHADOW_SCALE=",
    "COMPILER_RT_TEST_STANDALONE_BUILD_LIBS_PYBOOL=False",
    "COMPILER_RT_TEST_USE_LLD_PYBOOL=False",  # FIXME: base off use_lld?
    "SANITIZER_CAN_USE_CXXABI_PYBOOL=True",
    "SANITIZER_USE_STATIC_CXX_ABI_PYBOOL=False",
    "SANITIZER_USE_STATIC_LLVM_UNWINDER_PYBOOL=False",
    "COMPILER_RT_HAS_AARCH64_SME_PYBOOL=False",
    "COMPILER_RT_DARWIN_LINKER_VERSION=",
    "COMPILER_RT_HAS_LLD_PYBOOL=True",
    "COMPILER_RT_HAS_GWP_ASAN_PYBOOL=False",
    "HAVE_RPC_XDR_H=0",
    "ANDROID_API_LEVEL=$android_api_level",
    "ANDROID_SERIAL_FOR_TESTING=$android_serial_for_testing",
  ]

  if (llvm_enable_expensive_checks) {
    values += [ "LLVM_ENABLE_EXPENSIVE_CHECKS_PYBOOL=True" ]
  } else {
    values += [ "LLVM_ENABLE_EXPENSIVE_CHECKS_PYBOOL=False" ]
  }

  if (host_cpu == "x64") {
    values += [ "HOST_ARCH=x86_64" ]
  } else if (host_cpu == "arm64") {
    values += [ "HOST_ARCH=aarch64" ]
  } else {
    assert(false, "unimplemented host_cpu " + host_cpu)
  }

  if (host_os == "mac") {
    values += [ "HOST_OS=Darwin" ]
  } else if (host_os == "linux") {
    values += [ "HOST_OS=Linux" ]
  } else if (host_os == "win") {
    values += [ "HOST_OS=Windows" ]
  } else {
    assert(false, "unsupported host_os " + host_os)
  }

  if (current_os != "win" || llvm_enable_dia_sdk) {
    values += [ "CAN_SYMBOLIZE=1" ]
  } else {
    values += [ "CAN_SYMBOLIZE=0" ]
  }

  if (current_os == "android") {
    values += [ "ANDROID_PYBOOL=True" ]
  } else {
    values += [ "ANDROID_PYBOOL=False" ]
  }

  if (llvm_enable_zlib) {
    values += [ "ZLIB_FOUND_PYBOOL=1" ]
  } else {
    values += [ "ZLIB_FOUND_PYBOOL=0" ]
  }
}
