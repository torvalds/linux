#! /usr/bin/env python3
import sys, os, re, urllib.request

latest_release = 18

clang_www_dir = os.path.dirname(__file__)
default_issue_list_path = os.path.join(clang_www_dir, 'cwg_index.html')
issue_list_url = "https://raw.githubusercontent.com/cplusplus/CWG/gh-pages/issues/cwg_index.html"
output = os.path.join(clang_www_dir, 'cxx_dr_status.html')
dr_test_dir = os.path.join(clang_www_dir, '../test/CXX/drs')

class DR:
  def __init__(self, section, issue, url, status, title):
    self.section, self.issue, self.url, self.status, self.title = \
        section, issue, url, status, title
  def __repr__(self):
    return '%s (%s): %s' % (self.issue, self.status, self.title)

def parse(dr):
  try:
    section, issue_link, status, liaison, title = [
        col.split('>', 1)[1].split('</TD>')[0]
        for col in dr.split('</TR>', 1)[0].split('<TD')[1:]
    ]
  except Exception as ex:
    print(f"Parse error: {ex}\n{dr}", file=sys.stderr)
    sys.exit(1)
  _, url, issue = issue_link.split('"', 2)
  url = url.strip()
  issue = int(issue.split('>', 1)[1].split('<', 1)[0])
  title = title.replace('<issue_title>', '').replace('</issue_title>', '').replace('\r\n', '\n').strip()
  return DR(section, issue, url, status, title)

def collect_tests():
  status_re = re.compile(r'\bcwg([0-9]+): (.*)')
  status_map = {}
  for test_cpp in os.listdir(dr_test_dir):
    if not test_cpp.endswith('.cpp'):
      continue
    test_cpp = os.path.join(dr_test_dir, test_cpp)
    found_any = False;
    for match in re.finditer(status_re, open(test_cpp, 'r').read()):
      dr_number = int(match.group(1))
      if dr_number in status_map:
        print("error: Comment for cwg{} encountered more than once. Duplicate found in {}".format(dr_number, test_cpp))
        sys.exit(1)
      status_map[dr_number] = match.group(2)
      found_any = True
    if not found_any:
      print("warning:%s: no '// cwg123: foo' comments in this file" % test_cpp, file=sys.stderr)
  return status_map

def get_issues(path):
  buffer = None
  if not path and os.path.exists(default_issue_list_path):
    path = default_issue_list_path
  try:
    if path is None:
      print('Fetching issue list from {}'.format(issue_list_url))
      with urllib.request.urlopen(issue_list_url) as f:
        buffer = f.read().decode('utf-8')
    else:
      print('Opening issue list from file {}'.format(path))
      with open(path, 'r') as f:
        buffer = f.read()
  except Exception as ex:
     print('Unable to read the core issue list', file=sys.stderr)
     print(ex, file=sys.stderr)
     sys.exit(1)

  return sorted((parse(dr) for dr in buffer.split('<TR>')[2:]),
                key = lambda dr: dr.issue)


issue_list_path  = None
if len(sys.argv) == 1:
  pass
elif len(sys.argv) == 2:
  issue_list_path = sys.argv[1]
else:
  print('Usage: {} [<path to cwg_index.html>]'.format(sys.argv[0]), file=sys.stderr)
  sys.exit(1)

status_map = collect_tests()
drs = get_issues(issue_list_path)
out_file = open(output, 'w')
out_file.write('''\
<!DOCTYPE html>
<!-- This file is auto-generated by make_cxx_dr_status. Do not modify. -->
<html>
<head>
  <META http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Clang - C++ Defect Report Status</title>
  <link type="text/css" rel="stylesheet" href="menu.css">
  <link type="text/css" rel="stylesheet" href="content.css">
  <style type="text/css">
    .none { background-color: #FFCCCC }
    .none-superseded { background-color: rgba(255, 204, 204, 0.65) }
    .unknown { background-color: #EBCAFE }
    .unknown-superseded { background-color: rgba(234, 200, 254, 0.65) }
    .partial { background-color: #FFE0B0 }
    .partial-superseded { background-color: rgba(255, 224, 179, 0.65) }
    .unreleased { background-color: #FFFF99 }
    .unreleased-superseded { background-color: rgba(255, 255, 153, 0.65) }
    .full { background-color: #CCFF99 }
    .full-superseded { background-color: rgba(214, 255, 173, 0.65) }
    .na { background-color: #DDDDDD }
    .na-superseded { background-color: rgba(222, 222, 222, 0.65) }
    .open * { color: #AAAAAA }
    .open-superseded * { color: rgba(171, 171, 171, 0.65) }
    //.open { filter: opacity(0.2) }
    tr:target { background-color: #FFFFBB }
    th { background-color: #FFDDAA }
  </style>
</head>
<body>

<!--#include virtual="menu.html.incl"-->

<div id="content">

<!--*************************************************************************-->
<h1>C++ Defect Report Support in Clang</h1>
<!--*************************************************************************-->

<h2 id="cxxdr">C++ defect report implementation status</h2>

<p>This page tracks which C++ defect reports are implemented within Clang.</p>

<table width="689" border="1" cellspacing="0">
  <tr>
    <th>Number</th>
    <th>Status</th>
    <th>Issue title</th>
    <th>Available in Clang?</th>
  </tr>''')

class AvailabilityError(RuntimeError):
  pass

availability_error_occurred = False

def availability(issue):
  status = status_map.get(issue, 'unknown')

  unresolved_status = ''
  proposed_resolution = ''
  unresolved_status_match = re.search(r' (open|drafting|review|tentatively ready)', status)
  if unresolved_status_match:
    unresolved_status = unresolved_status_match.group(1)
    proposed_resolution_match = re.search(r' (open|drafting|review|tentatively ready) (\d{4}-\d{2}(?:-\d{2})?|P\d{4}R\d+)$', status)
    if proposed_resolution_match is None:
      raise AvailabilityError('Issue {}: \'{}\' status should be followed by a paper number (P1234R5) or proposed resolution in YYYY-MM-DD format'.format(dr.issue, unresolved_status))
    proposed_resolution = proposed_resolution_match.group(2)
    status = status[:-1-len(proposed_resolution)]
    status = status[:-1-len(unresolved_status)]

  avail_suffix = ''
  avail_style = ''
  tooltip = ''
  if status.endswith(' c++11'):
    status = status[:-6]
    avail_suffix = ' (C++11 onwards)'
  elif status.endswith(' c++14'):
    status = status[:-6]
    avail_suffix = ' (C++14 onwards)'
  elif status.endswith(' c++17'):
    status = status[:-6]
    avail_suffix = ' (C++17 onwards)'
  elif status.endswith(' c++20'):
    status = status[:-6]
    avail_suffix = ' (C++20 onwards)'
  if status == 'unknown':
    avail = 'Unknown'
    avail_style = 'unknown'
  elif re.match(r'^[0-9]+\.?[0-9]*', status):
    if not proposed_resolution:
      avail = 'Clang %s' % status
      if float(status) > latest_release:
        avail_style = 'unreleased'
      else:
        avail_style = 'full'
    else: 
      avail = 'Not Resolved*'
      tooltip = f' title="Clang {status} implements {proposed_resolution} resolution"'
  elif status == 'yes':
    if not proposed_resolution:
      avail = 'Yes'
      avail_style = 'full'
    else:
      avail = 'Not Resolved*'
      tooltip = f' title="Clang implements {proposed_resolution} resolution"'
  elif status == 'partial':
    if not proposed_resolution:
      avail = 'Partial'
      avail_style = 'partial'
    else:
      avail = 'Not Resolved*'
      tooltip = f' title="Clang partially implements {proposed_resolution} resolution"'
  elif status == 'no':
    if not proposed_resolution:
      avail = 'No'
      avail_style = 'none'
    else:
      avail = 'Not Resolved*'
      tooltip = f' title="Clang does not implement {proposed_resolution} resolution"'
  elif status == 'na':
    avail = 'N/A'
    avail_style = 'na'
  elif status == 'na lib':
    avail = 'N/A (Library DR)'
    avail_style = 'na'
  elif status == 'na abi':
    avail = 'N/A (ABI constraint)'
    avail_style = 'na'
  elif status.startswith('sup '):
    dup = status.split(' ', 1)[1]
    if dup.startswith('P'):
      avail = 'Superseded by <a href="https://wg21.link/%s">%s</a>' % (dup, dup)
      avail_style = 'na'
    else:
      avail = 'Superseded by <a href="#%s">%s</a>' % (dup, dup)
      try:
        _, avail_style, _, _ = availability(int(dup))
        avail_style += '-superseded'
      except:
        print("issue %s marked as sup %s" % (issue, dup), file=sys.stderr)
        avail_style = 'none'
  elif status.startswith('dup '):
    dup = int(status.split(' ', 1)[1])
    avail = 'Duplicate of <a href="#%s">%s</a>' % (dup, dup)
    _, avail_style, _, _ = availability(dup)
  else:
    raise AvailabilityError('Unknown status %s for issue %s' % (status, dr.issue))
  return (avail + avail_suffix, avail_style, unresolved_status, tooltip)

count = {}
for dr in drs:
  if dr.status in ('concepts',):
    # This refers to the old ("C++0x") concepts feature, which was not part
    # of any C++ International Standard or Technical Specification.
    continue

  elif dr.status == 'extension':
    row_style = ' class="open"'
    avail = 'Extension'
    avail_style = ''

  elif dr.status in ('open', 'drafting', 'review', 'tentatively ready'):
    row_style = ' class="open"'
    try:
      avail, avail_style, unresolved_status, tooltip = availability(dr.issue)
    except AvailabilityError as e:
      availability_error_occurred = True
      print(e.args[0])
      continue
      
    if avail == 'Unknown':
      avail = 'Not resolved'
      avail_style = ''
    else:
      if unresolved_status != dr.status:
        availability_error_occurred = True
        print("Issue %s is marked '%s', which differs from CWG index status '%s'" \
             % (dr.issue, unresolved_status, dr.status))
        continue
  else:
    row_style = ''
    try:
      avail, avail_style, unresolved_status, tooltip = availability(dr.issue)
    except AvailabilityError as e:
      availability_error_occurred = True
      print(e.args[0])
      continue

    if unresolved_status:
      availability_error_occurred = True
      print("Issue %s is marked '%s', even though it is resolved in CWG index" \
           % (dr.issue, unresolved_status))
      continue

  if not avail.startswith('Sup') and not avail.startswith('Dup'):
    count[avail] = count.get(avail, 0) + 1

  if avail_style != '':
    avail_style = ' class="{}"'.format(avail_style)
  out_file.write('''
  <tr%s id="%s">
    <td><a href="https://cplusplus.github.io/CWG/issues/%s.html">%s</a></td>
    <td>%s</td>
    <td>%s</td>
    <td%s%s align="center">%s</td>
  </tr>''' % (row_style, dr.issue, dr.issue, dr.issue, dr.status, dr.title, avail_style, tooltip, avail))

if availability_error_occurred:
  exit(1)

for status, num in sorted(count.items()):
  print("%s: %s" % (status, num), file=sys.stderr)

out_file.write('''\
</table>

</div>
</body>
</html>
''')
out_file.close()

