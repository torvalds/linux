cmake_minimum_required(VERSION 3.20.0)
set(LLVM_SUBPROJECT_TITLE "LLDB")

if(NOT DEFINED LLVM_COMMON_CMAKE_UTILS)
  set(LLVM_COMMON_CMAKE_UTILS ${CMAKE_CURRENT_SOURCE_DIR}/../cmake)
endif()
include(${LLVM_COMMON_CMAKE_UTILS}/Modules/CMakePolicy.cmake
  NO_POLICY_SCOPE)

# Add path for custom modules.
set(CMAKE_MODULE_PATH
  ${CMAKE_MODULE_PATH}
  "${CMAKE_CURRENT_SOURCE_DIR}/cmake"
  "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules"
  )

# If we are not building as part of LLVM, build LLDB as a standalone project,
# using LLVM as an external library.
if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
  project(lldb)
  set(LLDB_BUILT_STANDALONE TRUE)
  set(LLVM_INCLUDE_TESTS ON CACHE INTERNAL "")
endif()

# Must go below project(..)
include(GNUInstallDirs)

option(LLDB_INCLUDE_TESTS "Generate build targets for the LLDB unit tests." ${LLVM_INCLUDE_TESTS})

if(LLDB_BUILT_STANDALONE)
  set(CMAKE_CXX_STANDARD 17 CACHE STRING "C++ standard to conform to")
  set(CMAKE_CXX_STANDARD_REQUIRED YES)
  set(CMAKE_CXX_EXTENSIONS NO)

  include(LLDBStandalone)
endif()

include(LLDBConfig)
include(AddLLDB)

# Define the LLDB_CONFIGURATION_xxx matching the build type.
if(uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG" )
  add_definitions(-DLLDB_CONFIGURATION_DEBUG)
endif()

if (WIN32)
  add_definitions(-D_ENABLE_EXTENDED_ALIGNED_STORAGE)
  if (NOT MSVC)
    # _BSD_SOURCE is required for MinGW's getopt.h to define optreset
    add_definitions(-D_BSD_SOURCE)
  endif()
endif()

if (LLDB_ENABLE_PYTHON)
  set(cachestring_LLDB_PYTHON_RELATIVE_PATH
    "Path where Python modules are installed, relative to LLDB's install prefix")
  set(cachestring_LLDB_PYTHON_EXE_RELATIVE_PATH
    "Path to python interpreter exectuable, relative to python's install prefix")
  set(cachestring_LLDB_PYTHON_EXT_SUFFIX
    "Filename extension for native code python modules")

  foreach(var LLDB_PYTHON_RELATIVE_PATH LLDB_PYTHON_EXE_RELATIVE_PATH LLDB_PYTHON_EXT_SUFFIX)
    if(NOT DEFINED ${var} AND NOT CMAKE_CROSSCOMPILING)
      execute_process(
        COMMAND ${Python3_EXECUTABLE}
          ${CMAKE_CURRENT_SOURCE_DIR}/bindings/python/get-python-config.py
          ${var}
        OUTPUT_VARIABLE value
        OUTPUT_STRIP_TRAILING_WHITESPACE)
      file(TO_CMAKE_PATH "${value}" value)
      set(${var} ${value} CACHE STRING ${cachestring_${var}})
    else()
      if ("${${var}}" STREQUAL "")
        message(FATAL_ERROR
          "Crosscompiling LLDB with Python requires manually setting ${var}.")
      endif()
    endif()
  endforeach()
  # Make sure lldb extension has "_d" suffix on Windows in Debug mode.
  if(WIN32 AND CMAKE_BUILD_TYPE STREQUAL Debug)
    string(SUBSTRING ${LLDB_PYTHON_EXT_SUFFIX} 0 2 FIRST_2_CHARS)
    # Add "_d" manually if LLDB_PYTHON_EXT_SUFFIX lacks it due to release Python configuration.
    if(NOT FIRST_2_CHARS STREQUAL "_d")
      set(LLDB_PYTHON_EXT_SUFFIX "_d${LLDB_PYTHON_EXT_SUFFIX}")
    endif()
  endif()
endif ()

if (LLDB_ENABLE_LUA)
  find_program(Lua_EXECUTABLE lua5.3)
  set(LLDB_LUA_DEFAULT_RELATIVE_PATH "lib/lua/5.3")
  set(LLDB_LUA_RELATIVE_PATH ${LLDB_LUA_DEFAULT_RELATIVE_PATH}
    CACHE STRING "Path where Lua modules are installed, relative to install prefix")
endif ()

if (LLDB_ENABLE_PYTHON OR LLDB_ENABLE_LUA)
  add_subdirectory(bindings)
endif ()

# We need the headers generated by instrinsics_gen before we can compile
# any source file in LLDB as the imported Clang modules might include
# some of these generated headers. This approach is copied from Clang's main
# CMakeLists.txt, so it should kept in sync the code in Clang which was added
# in llvm-svn 308844.
if(LLVM_ENABLE_MODULES)
  list(APPEND LLVM_COMMON_DEPENDS intrinsics_gen)
endif()

if(CMAKE_CROSSCOMPILING AND LLDB_BUILT_STANDALONE AND NOT LLDB_TABLEGEN_EXE)
  set(LLVM_USE_HOST_TOOLS ON)
  include(CrossCompile)
  if (NOT NATIVE_LLVM_DIR OR NOT NATIVE_Clang_DIR)
    message(FATAL_ERROR
      "Crosscompiling standalone requires the variables NATIVE_{CLANG,LLVM}_DIR
      for building the native lldb-tblgen used during the build process.")
  endif()
  llvm_create_cross_target(lldb NATIVE "" Release
    -DLLVM_DIR=${NATIVE_LLVM_DIR}
    -DClang_DIR=${NATIVE_Clang_DIR})
endif()

# TableGen
add_subdirectory(utils/TableGen)

add_subdirectory(source)
add_subdirectory(tools)
add_subdirectory(docs)

if (LLDB_ENABLE_PYTHON)
  if(LLDB_BUILD_FRAMEWORK)
    set(lldb_python_target_dir "${LLDB_FRAMEWORK_ABSOLUTE_BUILD_DIR}/LLDB.framework/Resources/Python/lldb")
  else()
    set(lldb_python_target_dir "${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${LLDB_PYTHON_RELATIVE_PATH}/lldb")
  endif()
  get_target_property(lldb_python_bindings_dir swig_wrapper_python BINARY_DIR)
  finish_swig_python("lldb-python" "${lldb_python_bindings_dir}" "${lldb_python_target_dir}")
endif()

if (LLDB_ENABLE_LUA)
  if(LLDB_BUILD_FRAMEWORK)
    set(lldb_lua_target_dir "${LLDB_FRAMEWORK_ABSOLUTE_BUILD_DIR}/LLDB.framework/Resources/Lua")
  else()
    set(lldb_lua_target_dir "${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/${LLDB_LUA_RELATIVE_PATH}")
  endif()
  get_target_property(lldb_lua_bindings_dir swig_wrapper_lua BINARY_DIR)
  finish_swig_lua("lldb-lua" "${lldb_lua_bindings_dir}" "${lldb_lua_target_dir}")
endif()

set(LLDB_INCLUDE_UNITTESTS ON)
if (NOT TARGET llvm_gtest)
  set(LLDB_INCLUDE_UNITTESTS OFF)
endif()

if(LLDB_INCLUDE_TESTS)
  add_subdirectory(test)
  if (LLDB_INCLUDE_UNITTESTS)
    add_subdirectory(unittests)
  endif()
  add_subdirectory(utils)
endif()

if(LLDB_BUILT_STANDALONE AND NOT LLVM_ENABLE_IDE)
  llvm_distribution_add_targets()
endif()
