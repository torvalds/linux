
   Completion Checklist for the Standard C++ Library
   Updated: 2003-04-25

   Status Code Legend:
    M - Missing
    S - Present as stub.
    X - Partially implemented, or buggy.
    T - Implemented, pending test/inspection.
    V - Verified to pass all available test suites.
    Q - Qualified by inspection for non-testable correctness.
    P - Portability verified.
    C - Certified.

   Lexical notes:
   Only status codes appear in column 0.  Notes relating to conformance
   issues appear [in brackets].

   Note that this checklist does not (yet) include all emendations
   recommended by the ISO Library Working Group:
   http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-toc.html

   Detailed explanation of status codes:

    M - Missing:  The name is not visible to programs that include
        the specified header, either at compile or link stage.

    S - Present as stub:  A program can use the name, but no implementation
        is provided.  Programs that use the name link correctly, but
        cannot usefully be run.

    X - Partially implemented, or buggy:  Some implementation has been
        provided, but it is known or believed not to conform fully.
        It may have an incorrect base class, wrong namespace, wrong
        storage class, or simply not fully implement requirements.
        However, it may be sufficiently usable to help test other
        components.

    T - Implemented, pending test/inspection:  Implementation believed
        to be complete, and informal testing suggests it is ready for
        formal verification.

    V - Verified, passes all test suites:  Verified to satisfy all
        generically testable conformance requirements.

    Q - Qualified by inspection for non-testable correctness:
        Inspected, "implementation-defined" documentation accepted,
        local usability criteria satisfied, formally inspected for
        other untestable conformance.  (Untestable requirements
        include exception-safety, thread-safety, worst-case
        complexity, memory cleanliness, usefulness.)

    P - Portability verified:  Qualified on all primary target platforms.

    C - Certified:  Formally certified to have passed all tests,
        inspections, qualifications; approved under "signing authority"
        to be used to satisfy contractual guarantees.

   ----------------------------------------------------------------------
       <algorithm>    <iomanip>    <list>      <ostream>     <streambuf>
       <bitset>       <ios>        <locale>    <queue>       <string>
       <complex>      <iosfwd>     <map>       <set>         <typeinfo>
X      <deque>        <iostream>   <memory>    <sstream>     <utility>
       <exception>    <istream>    <new>       <stack>       <valarray>
       <fstream>      <iterator>   <numeric>   <stdexcept>   <vector>
       <functional>   <limits>

   [C header names must be in std:: to qualify.  Related to shadow/ dir.]
           <cassert> <ciso646> <csetjmp> <cstdio>  <ctime>
           <cctype>  <climits> <csignal> <cstdlib> <cwchar>
X          <cerrno>  <clocale> <cstdarg> <cstring> <cwctype>
           <cfloat>  <cmath>   <cstddef>

    Macro:
X   errno,  declared  or  defined in <cerrno>.

    Macro fn:
X   setjmp(jmp_buf), declared or defined in <csetjmp>
X   va_end(va_list), declared or defined in <cstdarg>

    Types:
X   clock_t, div_t, FILE, fpos_t, lconv, ldiv_t, mbstate_t,
X   ptrdiff_t, sig_atomic_t, size_t,  time_t,  tm,  va_list,
X   wctrans_t, wctype_t, and wint_t.

   1 Which  of  the functions in the C++ Standard Library are not reentrant
    subroutines is implementation-defined.

   18.1  Types                                        [lib.support.types]
X      <cstddef>
X      NULL
X      offsetof
X      ptrdiff_t
X      size_t

   18.2  Implementation properties                   [lib.support.limits]

    <limits>, <climits>, and <cfloat>

   18.2.1  Numeric limits                                    [lib.limits]

X   template<class T> class numeric_limits;

T   enum float_round_style;
T   enum float_denorm_style;

T   template<> class numeric_limits<bool>;

T   template<> class numeric_limits<char>;
T   template<> class numeric_limits<signed char>;
T   template<> class numeric_limits<unsigned char>;
T   template<> class numeric_limits<wchar_t>;

T   template<> class numeric_limits<short>;
T   template<> class numeric_limits<int>;
T   template<> class numeric_limits<long>;
T   template<> class numeric_limits<unsigned short>;
T   template<> class numeric_limits<unsigned int>;
T   template<> class numeric_limits<unsigned long>;

X   template<> class numeric_limits<float>;
X   template<> class numeric_limits<double>;
X   template<> class numeric_limits<long double>;

   18.2.1.1  Template class numeric_limits           [lib.numeric.limits]
T   template<class T> class numeric_limits {
    public:
T     static const bool is_specialized = false;
T     static T min() throw();
T     static T max() throw();
T     static const int  digits = 0;
T     static const int  digits10 = 0;
T     static const bool is_signed = false;
T     static const bool is_integer = false;
T     static const bool is_exact = false;
T     static const int  radix = 0;
T     static T epsilon() throw();
T     static T round_error() throw();

T     static const int  min_exponent = 0;
T     static const int  min_exponent10 = 0;
T     static const int  max_exponent = 0;
T     static const int  max_exponent10 = 0;

T     static const bool has_infinity = false;
T     static const bool has_quiet_NaN = false;
T     static const bool has_signaling_NaN = false;
T     static const float_denorm_style has_denorm = denorm_absent;
T     static const bool has_denorm_loss = false;
T     static T infinity() throw();
T     static T quiet_NaN() throw();
T     static T signaling_NaN() throw();
T     static T denorm_min() throw();

T     static const bool is_iec559 = false;
T     static const bool is_bounded = false;
T     static const bool is_modulo = false;

T     static const bool traps = false;
T     static const bool tinyness_before = false;
T     static const float_round_style round_style = round_toward_zero;
    };

   18.2.1.3  Type float_round_style                     [lib.round.style]

T   enum float_round_style {
T     round_indeterminate       = -1,
T     round_toward_zero         =  0,
T     round_to_nearest          =  1,
T     round_toward_infinity     =  2,
T     round_toward_neg_infinity =  3
    };

   18.2.1.4  Type float_denorm_style                   [lib.denorm.style]

T   enum float_denorm_style {
T     denorm_indeterminate = -1;
T     denorm_absent = 0;
T     denorm present = 1;
    };

   18.2.1.5  numeric_limits specializations         [lib.numeric.special]
   
   [Note: see Note at 18.2.1.  ]

   18.2.2  C Library                                       [lib.c.limits]

   1 Header <climits> (Table 3):
      CHAR_BIT   INT_MAX    LONG_MIN     SCHAR_MIN   UCHAR_MAX   USHRT_MAX
X     CHAR_MAX   INT_MIN    MB_LEN_MAX   SHRT_MAX    UINT_MAX
      CHAR_MIN   LONG_MAX   SCHAR_MAX    SHRT_MIN    ULONG_MAX

   3 Header <cfloat> (Table 4):

    DBL_DIG          DBL_MIN_EXP      FLT_MIN_10_EXP   LDBL_MAX_10_EXP
    DBL_EPSILON      FLT_DIG          FLT_MIN_EXP      LDBL_MAX_EXP
    DBL_MANT_DIG     FLT_EPSILON      FLT_RADIX        LDBL_MIN
X   DBL_MAX          FLT_MANT_DIG     FLT_ROUNDS       LDBL_MIN_10_EXP
    DBL_MAX_10_EXP   FLT_MAX          LDBL_DIG         LDBL_MIN_EXP
    DBL_MAX_EXP      FLT_MAX_10_EXP   LDBL_EPSILON
    DBL_MIN          FLT_MAX_EXP      LDBL_MANT_DIG
    DBL_MIN_10_EXP   FLT_MIN          LDBL_MAX


        1 Header <cstdlib> (partial), Table 5:
X             EXIT_FAILURE     EXIT_SUCCESS
              abort   atexit   exit

S    abort(void)
S    extern "C" int atexit(void (*f)(void))
S    extern "C++" int atexit(void (*f)(void))
S    exit(int status)

   18.4  Dynamic memory management                  [lib.support.dynamic]

   Header <new> synopsis

T    class bad_alloc;
T    struct nothrow_t {};
T    extern const nothrow_t nothrow;
T    typedef void (*new_handler)();
T    new_handler set_new_handler(new_handler new_p) throw();

T    void* operator new(std::size_t size) throw(std::bad_alloc);
T    void* operator new(std::size_t size, const std::nothrow_t&) throw();
T    void  operator delete(void* ptr) throw();
T    void  operator delete(void* ptr, const std::nothrow_t&) throw();
T    void* operator new[](std::size_t size) throw(std::bad_alloc);
T    void* operator new[](std::size_t size, const std::nothrow_t&) throw();
T    void  operator delete[](void* ptr) throw();
T    void  operator delete[](void* ptr, const std::nothrow_t&) throw();
T    void* operator new  (std::size_t size, void* ptr) throw();
T    void* operator new[](std::size_t size, void* ptr) throw();
T    void  operator delete  (void* ptr, void*) throw();
T    void  operator delete[](void* ptr, void*) throw();

   18.4.2.1  Class bad_alloc                              [lib.bad.alloc]

T   class bad_alloc : public exception {
    public:
T     bad_alloc() throw();
T     bad_alloc(const bad_alloc&) throw();
T     bad_alloc& operator=(const bad_alloc&) throw();
T     virtual ~bad_alloc() throw();
T     virtual const char* what() const throw();



T  new_handler set_new_handler(new_handler new_p) throw();


     Header <typeinfo> synopsis

T    class type_info;
T    class bad_cast;
T    class bad_typeid;

   18.5.1 - Class type_info [lib.type.info]

T    class type_info {
    public:
T      virtual ~type_info();
T      bool operator==(const type_info& rhs) const;
T      bool operator!=(const type_info& rhs) const;
T      bool before(const type_info& rhs) const;
T      const char* name() const;
    private:
T      type_info(const type_info& rhs);
T      type_info& operator=(const type_info& rhs);
    };

   18.5.2 - Class bad_cast [lib.bad.cast]

T  bad_cast() throw();
T  virtual const char* bad_cast::what() const throw();

   18.5.3  Class bad_typeid                              [lib.bad.typeid]

T    class bad_typeid : public exception {
    public:
T      bad_typeid() throw();
T      bad_typeid(const bad_typeid&) throw();
T      bad_typeid& operator=(const bad_typeid&) throw();
T      virtual ~bad_typeid() throw();
T      virtual const char* what() const throw();
    };

   18.6  Exception handling                       [lib.support.exception]

T      Header <exception> synopsis

T    class exception;
T    class bad_exception;

T    typedef void (*unexpected_handler)();
T    unexpected_handler set_unexpected(unexpected_handler f) throw();
T    void unexpected();
T    typedef void (*terminate_handler)();
T    terminate_handler set_terminate(terminate_handler f) throw();
T    void terminate();
T    bool uncaught_exception();

   18.6.1  Class exception                                [lib.exception]

T    class exception {
     public:
T      exception() throw();
T      exception(const exception&) throw();
T      exception& operator=(const exception&) throw();
T      virtual ~exception() throw();
T      virtual const char* what() const throw();
    };

   18.6.2.1  Class bad_exception                      [lib.bad.exception]
T    class bad_exception : public exception {
    public:
T      bad_exception() throw();
T      bad_exception(const bad_exception&) throw();
T      bad_exception& operator=(const bad_exception&) throw();
T      virtual ~bad_exception() throw();
T      virtual const char* what() const throw();
    };

   18.7  Other runtime support                      [lib.support.runtime]

   1 Headers <cstdarg> (variable arguments),  <csetjmp>  (nonlocal  jumps),
    <ctime>  (system  clock clock(), time()), <csignal> (signal handling),
    and <cstdlib> (runtime environment getenv(), system()).

                    Table 6--Header <cstdarg> synopsis
                 Macros:   va_arg    va_end   va_start
X                Type:     va_list

                    Table 7--Header <csetjmp> synopsis

                          Macro:      setjmp |
X                         Type:       jmp_buf
                          Function:   longjmp

                     Table 8--Header <ctime> synopsis

                      Macros:      CLOCKS_PER_SEC
X                     Types:       clock_t
                      Functions:   clock

                    Table 9--Header <csignal> synopsis

X        Macros:      SIGABRT        SIGILL   SIGSEGV   SIG_DFL
         SIG_IGN      SIGFPE         SIGINT   SIGTERM   SIG_ERR
         Type:        sig_atomic_t
         Functions:   raise          signal

                   Table 10--Header <cstdlib> synopsis

X                     Functions:   getenv   system

   19.1  Exception classes                           [lib.std.exceptions]

   Header <stdexcept> synopsis

T     class logic_error;
T     class domain_error;
T     class invalid_argument;
T     class length_error;
T     class out_of_range;
T     class runtime_error;
T     class range_error;
T     class overflow_error;
T     class underflow_error;

   19.1.1  Class logic_error                            [lib.logic.error]
T   class logic_error : public exception {
    public:
T     explicit logic_error(const string& what_arg);
    };

   19.1.2  Class domain_error                          [lib.domain.error]

T   class domain_error : public logic_error {
    public:
T     explicit domain_error(const string& what_arg);
    };

   19.1.3  Class invalid_argument                  [lib.invalid.argument]

T   class invalid_argument : public logic_error {
    public:
T     explicit invalid_argument(const string& what_arg);
    };

   19.1.4  Class length_error                          [lib.length.error]

T   class length_error : public logic_error {
    public:
T     explicit length_error(const string& what_arg);
    };

   19.1.5  Class out_of_range                          [lib.out.of.range]

T   class out_of_range : public logic_error {
    public:
T     explicit out_of_range(const string& what_arg);
    };


   19.1.6  Class runtime_error                        [lib.runtime.error]

T   class runtime_error : public exception {
    public:
T     explicit runtime_error(const string& what_arg);
    };


   19.1.7  Class range_error                            [lib.range.error]

T   class range_error : public runtime_error {
    public:
T     explicit range_error(const string& what_arg);
    };

   19.1.8  Class overflow_error                      [lib.overflow.error]

T   class overflow_error : public runtime_error {
    public:
T     explicit overflow_error(const string& what_arg);
    };


   19.1.9  Class underflow_error                    [lib.underflow.error]

T   class underflow_error : public runtime_error {
    public:
T     explicit underflow_error(const string& what_arg);
    };


   19.2  Assertions                                      [lib.assertions]

                    Table 2--Header <cassert> synopsis

X                         Macro:   assert

   19.3  Error numbers                                        [lib.errno]

                    Table 3--Header <cerrno> synopsis

X                    |Macros:   EDOM   ERANGE   errno |


   20.2  Utility components                                 [lib.utility]

   Header <utility> synopsis

    // _lib.operators_, operators:
T    namespace rel_ops {
T      template<class T> bool operator!=(const T&, const T&);
T      template<class T> bool operator> (const T&, const T&);
T      template<class T> bool operator<=(const T&, const T&);
T      template<class T> bool operator>=(const T&, const T&);
    }
    // _lib.pairs_, pairs:
T   template <class T1, class T2> struct pair;
T   template <class T1, class T2>
      bool operator==(const pair<T1,T2>&, const pair<T1,T2>&);
T   template <class T1, class T2>
      bool operator< (const pair<T1,T2>&, const pair<T1,T2>&);
T   template <class T1, class T2>
      bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&);
T   template <class T1, class T2>
      bool operator> (const pair<T1,T2>&, const pair<T1,T2>&);
T   template <class T1, class T2>
      bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&);
T   template <class T1, class T2>
      bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&);
T   template <class T1, class T2> pair<T1,T2> make_pair(const T1&, const T2&);


   20.2.2  Pairs                                              [lib.pairs]

T  template <class T1, class T2>
   struct pair {
T    typedef T1 first_type;
T    typedef T2 second_type;

T    T1 first;
T    T2 second;
T    pair();
T    pair(const T1& x, const T2& y);
T    template<class U, class V> pair(const pair<U, V> &p);
   };

   20.3  Function objects                          [lib.function.objects]

   Header <functional> synopsis

    // _lib.base_, base:
V   template <class Arg, class Result> struct unary_function;
V   template <class Arg1, class Arg2, class Result> struct binary_function;

    // _lib.arithmetic.operations_, arithmetic operations:
V   template <class T> struct plus;
V   template <class T> struct minus;
V   template <class T> struct multiplies;
V   template <class T> struct divides;
V   template <class T> struct modulus;
V   template <class T> struct negate;
    // _lib.comparisons_, comparisons:
V   template <class T> struct equal_to;
V   template <class T> struct not_equal_to;
V   template <class T> struct greater;
V   template <class T> struct less;
V   template <class T> struct greater_equal;
V   template <class T> struct less_equal;
    // _lib.logical.operations_, logical operations:
V   template <class T> struct logical_and;
V   template <class T> struct logical_or;
V   template <class T> struct logical_not;
    // _lib.negators_, negators:
    template <class Predicate> struct unary_negate;
V   template <class Predicate>
      unary_negate<Predicate>  not1(const Predicate&);
V   template <class Predicate> struct binary_negate;
V   template <class Predicate>
      binary_negate<Predicate> not2(const Predicate&);
    // _lib.binders_, binders:
V   template <class Operation>  class binder1st;
V   template <class Operation, class T>
      binder1st<Operation> bind1st(const Operation&, const T&);
V   template <class Operation> class binder2nd;
V   template <class Operation, class T>
      binder2nd<Operation> bind2nd(const Operation&, const T&);
    // _lib.function.pointer.adaptors_, adaptors:
V   template <class Arg, class Result> class pointer_to_unary_function;
V   template <class Arg, class Result>
      pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg));
V   template <class Arg1, class Arg2, class Result>
      class pointer_to_binary_function;
V   template <class Arg1, class Arg2, class Result>
      pointer_to_binary_function<Arg1,Arg2,Result>
        ptr_fun(Result (*)(Arg1,Arg2));

    // _lib.member.pointer.adaptors_, adaptors:
V   template<class S, class T> class mem_fun_t;
V   template<class S, class T, class A> class mem_fun1_t;
V   template<class S, class T>
        mem_fun_t<S,T> mem_fun(S (T::*f)());
V   template<class S, class T, class A>
        mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));
V   template<class S, class T> class mem_fun_ref_t;
V   template<class S, class T, class A> class mem_fun1_ref_t;
V   template<class S, class T>
        mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)());
V   template<class S, class T, class A>
        mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));

V   template <class S, class T> class const_mem_fun_t;
V   template <class S, class T, class A> class const_mem_fun1_t;
V   template <class S, class T>
      const_mem_fun_t<S,T> mem_fun(S (T::*f)() const);
V   template <class S, class T, class A>
      const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);
V   template <class S, class T> class const_mem_fun_ref_t;
V   template <class S, class T, class A> class const_mem_fun1_ref_t;
V   template <class S, class T>
      const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const);
V   template <class S, class T, class A>
      const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);
   }

   20.3.1  Base                                                [lib.base]

V   template <class Arg, class Result>
    struct unary_function {
V     typedef Arg    argument_type;
V     typedef Result result_type;
    };
V   template <class Arg1, class Arg2, class Result>
    struct binary_function {
V     typedef Arg1   first_argument_type;
V     typedef Arg2   second_argument_type;
V     typedef Result result_type;
    };

   20.3.2  Arithmetic operations              [lib.arithmetic.operations]

T  template <class T> struct plus : binary_function<T,T,T> {
V   T operator()(const T& x, const T& y) const;
   };

T  template <class T> struct minus : binary_function<T,T,T> {
V   T operator()(const T& x, const T& y) const;
   };

T  template <class T> struct multiplies : binary_function<T,T,T> {
V   T operator()(const T& x, const T& y) const;
   };

T  template <class T> struct divides : binary_function<T,T,T> {
V   T operator()(const T& x, const T& y) const;
   };

T  template <class T> struct modulus : binary_function<T,T,T> {
V   T operator()(const T& x, const T& y) const;
   };

T  template <class T> struct negate : unary_function<T,T> {
V   T operator()(const T& x) const;
   };

   20.3.3  Comparisons                                  [lib.comparisons]

T  template <class T> struct equal_to : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

T  template <class T> struct not_equal_to : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

T  template <class T> struct greater : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

T  template <class T> struct less : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

T  template <class T> struct greater_equal : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

T  template <class T> struct less_equal : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

   20.3.4  Logical operations                    [lib.logical.operations]

T  template <class T> struct logical_and : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

T  template <class T> struct logical_or : binary_function<T,T,bool> {
V   bool operator()(const T& x, const T& y) const;
   };

T  template <class T> struct logical_not : unary_function<T,bool> {
V   bool operator()(const T& x) const;
   };

   20.3.5  Negators                                        [lib.negators]

T  template <class Predicate>
    class unary_negate
      : public unary_function<typename Predicate::argument_type,bool> {
   public:
T   explicit unary_negate(const Predicate& pred);
V   bool operator()(const typename Predicate::argument_type& x) const;
   };

T  template <class Predicate>
    class binary_negate
      : public binary_function<typename Predicate::first_argument_type,
          typename Predicate::second_argument_type, bool> {
    public:
T     explicit binary_negate(const Predicate& pred);
V     bool operator()(const typename Predicate::first_argument_type&  x,
          const typename Predicate::second_argument_type& y) const;
    };


   20.3.6  Binders                                          [lib.binders]

   20.3.6.1  Template class binder1st                    [lib.binder.1st]
T   template <class Operation>
    class binder1st
      : public unary_function<typename Operation::second_argument_type,
                              typename Operation::result_type> {
    protected:
T     Operation                      op;
T     typename Operation::first_argument_type value;
    public:
V     binder1st(const Operation& x,
                const typename Operation::first_argument_type& y);
V     typename Operation::result_type
        operator()(const typename Operation::second_argument_type& x) const;
    };

   20.3.6.2  bind1st                                       [lib.bind.1st]

V  template <class Operation, class T>
    binder1st<Operation> bind1st(const Operation& op, const T& x);

   20.3.6.3  Template class binder2nd                    [lib.binder.2nd]
T   template <class Operation>
    class binder2nd
      : public unary_function<typename Operation::first_argument_type,
                              typename Operation::result_type> {
    protected:
T     Operation                       op;
T     typename Operation::second_argument_type value;
    public:
V     binder2nd(const Operation& x,
                const typename Operation::second_argument_type& y);
V     typename Operation::result_type
        operator()(const typename Operation::first_argument_type& x) const;
    };

   20.3.6.4  bind2nd                                       [lib.bind.2nd]

T  template <class Operation, class T>
    binder2nd<Operation> bind2nd(const Operation& op, const T& x);


   20.3.7  Adaptors for pointers to       [lib.function.pointer.adaptors]
       functions

   1 To  allow  pointers to (unary and binary) functions to work with func-
   tion adaptors the library provides:

T   template <class Arg, class Result>
    class pointer_to_unary_function : public unary_function<Arg, Result> {
    public:
T     explicit pointer_to_unary_function(Result (*f)(Arg));
V     Result operator()(Arg x) const;
    };

T  template <class Arg, class Result>
    pointer_to_unary_function<Arg, Result> ptr_fun(Result (*f)(Arg));

T       template <class Arg1, class Arg2, class Result>
        class pointer_to_binary_function :
          public binary_function<Arg1,Arg2,Result> {
        public:
T         explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
V         Result operator()(Arg1 x, Arg2 y) const;
        };


   20.3.8  Adaptors for pointers to         [lib.member.pointer.adaptors]
       members

T  template <class S, class T> class mem_fun_t
          : public unary_function<T*, S> {
   public:
T   explicit mem_fun_t(S (T::*p)());
V   S operator()(T* p) const;
   };

T   template <class S, class T, class A> class mem_fun1_t
          : public binary_function<T*, A, S> {
    public:
T     explicit mem_fun1_t(S (T::*p)(A));
V     S operator()(T* p, A x) const;
   };

V   template<class S, class T> mem_fun_t<S,T>
       mem_fun(S (T::*f)());
V   template<class S, class T, class A> mem_fun1_t<S,T,A>
       mem_fun(S (T::*f)(A));

T   template <class S, class T> class mem_fun_ref_t
          : public unary_function<T, S> {
    public:
T     explicit mem_fun_ref_t(S (T::*p)());
V     S operator()(T& p) const;
   };

T   template <class S, class T, class A> class mem_fun1_ref_t
          : public binary_function<T, A, S> {
    public:
T     explicit mem_fun1_ref_t(S (T::*p)(A));
V     S operator()(T& p, A x) const;
   };

T   template<class S, class T> mem_fun_ref_t<S,T>
       mem_fun_ref(S (T::*f)());

T   template<class S, class T, class A> mem_fun1_ref_t<S,T,A>
       mem_fun_ref(S (T::*f)(A));

T  template <class S, class T> class const_mem_fun_t
        : public unary_function<T*, S> {
   public:
T   explicit const_mem_fun_t(S (T::*p)() const);
V   S operator()(const T* p) const;
   };

T  template <class S, class T, class A> class const_mem_fun1_t
        : public binary_function<T*, A, S> {
   public:
T   explicit const mem_fun1_t(S (T::*p)(A) const);
V   S operator()(const T* p, A x) const;
   };

V   template<class S, class T> const_mem_fun_t<S,T>
       mem_fun(S (T::*f)() const);
V   template<class S, class T, class A> const_mem_fun1_t<S,T,A>
       mem_fun(S (T::*f)(A) const);

T   template <class S, class T> class const_mem_fun_ref_t
          : public unary_function<T, S> {
    public:
T     explicit const_mem_fun_ref_t(S (T::*p)() const);
V     S operator()(const T& p) const;
   };

T   template <class S, class T, class A> class const_mem_fun1_ref_t
          : public binary_function<T, A, S> {
    public:
T     explicit const_mem_fun1_ref_t(S (T::*p)(A) const);
V     S operator()(const T& p, A x) const;
   };

T   template<class S, class T> const_mem_fun_ref_t<S,T>
       mem_fun_ref(S (T::*f)() const);

T   template<class S, class T, class A> const_mem_fun1_ref_t<S,T,A>
        mem_fun_ref(S (T::*f)(A) const);

   20.4  Memory                                              [lib.memory]

   Header <memory> synopsis

    // _lib.default.allocator_, the default allocator:
T   template <class T> class allocator;
T   template <> class allocator<void>;
T   template <class T, class U>
      bool operator==(const allocator<T>&, const allocator<U>&) throw();
T   template <class T, class U>
      bool operator!=(const allocator<T>&, const allocator<U>&) throw();
    // _lib.storage.iterator_, raw storage iterator:
T   template <class OutputIterator, class T> class raw_storage_iterator;
    // _lib.temporary.buffer_, temporary buffers:
T   template <class T>
      pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n);
T   template <class T>
      void return_temporary_buffer(T* p);
    // _lib.specialized.algorithms_, specialized algorithms:
T   template <class InputIterator, class ForwardIterator>
      ForwardIterator
        uninitialized_copy(InputIterator first, InputIterator last,
                           ForwardIterator result);
T   template <class ForwardIterator, class T>
      void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                              const T& x);
T   template <class ForwardIterator, class Size, class T>
      void uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
    // _lib.auto.ptr_, pointers:
X   template<class X> class auto_ptr;
   }

   20.4.1  The default allocator                  [lib.default.allocator]

T   template <class T> class allocator;
    // specialize for void:
T   template <> class allocator<void> {
    public:
T     typedef void*       pointer;
T     typedef const void* const_pointer;
      // reference-to-void members are impossible.
T     typedef void  value_type;
T     template <class U> struct rebind { typedef allocator<U> other; };
    };

T   template <class T> class allocator {
     public:
T     typedef size_t    size_type;
T     typedef ptrdiff_t difference_type;
T     typedef T*        pointer;
T     typedef const T*  const_pointer;
T     typedef T&        reference;
T     typedef const T&  const_reference;
T     typedef T         value_type;
T     template <class U> struct rebind { typedef allocator<U> other; };
T     allocator() throw();
T     allocator(const allocator&) throw();
T     template <class U> allocator(const allocator<U>&) throw();
T    ~allocator() throw();
T     pointer address(reference x) const;
T     const_pointer address(const_reference x) const;
T     pointer allocate(
        size_type, allocator<void>::const_pointer hint = 0);
T     void deallocate(pointer p, size_type n);
T     size_type max_size() const throw();
T     void construct(pointer p, const T& val);
T     void destroy(pointer p);
    };

   20.4.1.2  allocator globals                    [lib.allocator.globals]

T  template <class T1, class T2>
    bool operator==(const allocator<T1>&, const allocator<T2>&) throw();
T  template <class T1, class T2>
    bool operator!=(const allocator<T1>&, const allocator<T2>&) throw();

   20.4.2  Raw storage iterator                    [lib.storage.iterator]

T   template <class OutputIterator, class T>
    class raw_storage_iterator
      : public iterator<output_iterator_tag,void,void,void,void> {
    public:
T     explicit raw_storage_iterator(OutputIterator x);
T     raw_storage_iterator<OutputIterator,T>& operator*();
T     raw_storage_iterator<OutputIterator,T>& operator=(const T& element);
T     raw_storage_iterator<OutputIterator,T>& operator++();
T     raw_storage_iterator<OutputIterator,T>  operator++(int);
    };

   20.4.3  Temporary buffers                       [lib.temporary.buffer]

T  template <class T>
    pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n);

T  template <class T> void return_temporary_buffer(T* p);

   20.4.4  Specialized algorithms            [lib.specialized.algorithms]

   20.4.4.1  uninitialized_copy                  [lib.uninitialized.copy]

V  template <class InputIterator, class ForwardIterator>
    ForwardIterator
      uninitialized_copy(InputIterator first, InputIterator last,
                         ForwardIterator result);

   20.4.4.2  uninitialized_fill                  [lib.uninitialized.fill]

V  template <class ForwardIterator, class T>
    void uninitialized_fill(ForwardIterator first, ForwardIterator last,
                            const T& x);

   20.4.4.3  uninitialized_fill_n              [lib.uninitialized.fill.n]

V  template <class ForwardIterator, class Size, class T>
    void uninitialized_fill_n(ForwardIterator first, Size n, const T& x);

   20.4.5  Template class auto_ptr                         [lib.auto.ptr]

X   template<class X> class auto_ptr {
      template <class Y> struct auto_ptr_ref {};
    public:
T     typedef X element_type;
      // _lib.auto.ptr.cons_ construct/copy/destroy:
T     explicit auto_ptr(X* p =0) throw();
T     auto_ptr(auto_ptr&) throw();
T     template<class Y> auto_ptr(auto_ptr<Y>&) throw();
T     auto_ptr& operator=(auto_ptr&) throw();
T     template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();
T    ~auto_ptr() throw();
      // _lib.auto.ptr.members_ members:
T     X& operator*() const throw();
T     X* operator->() const throw();
T     X* get() const throw();
T     X* release() throw();
T     void reset(X* p =0) throw();

      // _lib.auto.ptr.conv_ conversions:
X     auto_ptr(auto_ptr_ref<X>) throw();
X     template<class Y> operator auto_ptr_ref<Y>() throw();
X     template<class Y> operator auto_ptr<Y>() throw();
    };

   20.4.6  C Library                                       [lib.c.malloc]

                    Table 7--Header <cstdlib> synopsis

X                    Functions:   calloc   malloc
                                  free     realloc


                    Table 8--Header <cstring> synopsis

X                    Macro:       NULL
X                    Type:        size_t
X                    Functions:   memchr    memcmp
X                    memcpy       memmove   memset

                     Table 9--Header <ctime> synopsis

X          Macros:   NULL
X          Types:    size_t   clock_t    time_t
X          Struct:   tm
           Functions:
X          asctime   clock    difftime   localtime   strftime
X          ctime     gmtime   mktime     time

   21.1.1  Character traits requirements        [lib.char.traits.require]

   2 The struct template
T  template<class charT> struct char_traits;
   shall be provided in the header <string> as a basis for  explicit spe-
   cializations.


   21.1.3.1  struct                [lib.char.traits.specializations.char]
       char_traits<char>

T   template<>
    struct char_traits<char> {
T     typedef char        char_type;
T     typedef int         int_type;
T     typedef streamoff   off_type;
T     typedef streampos   pos_type;
T     typedef mbstate_t   state_type;

T     static void assign(char_type& c1, const char_type& c2);
T     static bool eq(const char_type& c1, const char_type& c2);
T     static bool lt(const char_type& c1, const char_type& c2);

T     static int compare(const char_type* s1, const char_type* s2, size_t n);
T     static size_t length(const char_type* s);
T     static const char_type* find(const char_type* s, size_t n,
                                   const char_type& a);
T     static char_type* move(char_type* s1, const char_type* s2, size_t n);
T     static char_type* copy(char_type* s1, const char_type* s2, size_t n);
T     static char_type* assign(char_type* s, size_t n, char_type a);

T     static int_type not_eof(const int_type& c);
T     static char_type to_char_type(const int_type& c);
T     static int_type to_int_type(const char_type& c);
T     static bool eq_int_type(const int_type& c1, const int_type& c2);
T     static int_type eof();
    };

   21.1.3.2  struct             [lib.char.traits.specializations.wchar.t]
       char_traits<wchar_t>

V   template<>
    struct char_traits<wchar_t> {
V     typedef wchar_t      char_type;
V     typedef wint_t       int_type;
V     typedef streamoff   off_type;
V     typedef wstreampos   pos_type;
V     typedef mbstate_t    state_type;

V     static void assign(char_type& c1, const char_type& c2);
V     static bool eq(const char_type& c1, const char_type& c2);
V     static bool lt(const char_type& c1, const char_type& c2);

V     static int compare(const char_type* s1, const char_type* s2, size_t n);
V     static size_t length(const char_type* s);
V     static const char_type* find(const char_type* s, size_t n,
                                   const char_type& a);
V     static char_type* move(char_type* s1, const char_type* s2, size_t n);
V     static char_type* copy(char_type* s1, const char_type* s2, size_t n);
V     static char_type* assign(char_type* s, size_t n, char_type a);

V     static int_type not_eof(const int_type& c);
V     static char_type to_char_type(const int_type& c);
V     static int_type to_int_type(const char_type& c);
V     static bool eq_int_type(const int_type& c1, const int_type& c2);
V     static int_type eof();
    };

   21.2  String classes                              [lib.string.classes]

    // _lib.char.traits_, character traits:
V   template<class charT>
      struct char_traits;
V   template <> struct char_traits<char>;
V   template <> struct char_traits<wchar_t>;

    // _lib.basic.string_, basic_string:
V   template<class charT, class traits = char_traits<charT>,
             class Allocator = allocator<charT> >
      class basic_string;
V   template<class charT, class traits, class Allocator>
      basic_string<charT,traits,Allocator>
        operator+(const basic_string<charT,traits,Allocator>& lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      basic_string<charT,traits,Allocator>
        operator+(const charT* lhs,
                  const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      basic_string<charT,traits,Allocator>
        operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      basic_string<charT,traits,Allocator>
        operator+(const basic_string<charT,traits,Allocator>& lhs,
                  const charT* rhs);
V   template<class charT, class traits, class Allocator>
      basic_string<charT,traits,Allocator>
        operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);

V   template<class charT, class traits, class Allocator>
      bool operator==(const basic_string<charT,traits,Allocator>& lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator==(const charT* lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator==(const basic_string<charT,traits,Allocator>& lhs,
                      const charT* rhs);
V   template<class charT, class traits, class Allocator>
      bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator!=(const charT* lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
                      const charT* rhs);
V   template<class charT, class traits, class Allocator>
      bool operator< (const basic_string<charT,traits,Allocator>& lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator< (const basic_string<charT,traits,Allocator>& lhs,
                      const charT* rhs);
V   template<class charT, class traits, class Allocator>
      bool operator< (const charT* lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator> (const basic_string<charT,traits,Allocator>& lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator> (const basic_string<charT,traits,Allocator>& lhs,
                      const charT* rhs);
V   template<class charT, class traits, class Allocator>
      bool operator> (const charT* lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
                      const charT* rhs);
V   template<class charT, class traits, class Allocator>
      bool operator<=(const charT* lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
                      const basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
      bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
                      const charT* rhs);
V   template<class charT, class traits, class Allocator>
      bool operator>=(const charT* lhs,
                      const basic_string<charT,traits,Allocator>& rhs);

    // _lib.string.special_:
V   template<class charT, class traits, class Allocator>
       void swap(basic_string<charT,traits,Allocator>& lhs,
                 basic_string<charT,traits,Allocator>& rhs);
V   template<class charT, class traits, class Allocator>
     basic_istream<charT,traits>&
      operator>>(basic_istream<charT,traits>& is,
                 basic_string<charT,traits,Allocator>& str);
T   template<class charT, class traits, class Allocator>
     basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os,
                 const basic_string<charT,traits,Allocator>& str);
V   template<class charT, class traits, class Allocator>
     basic_istream<charT,traits>&
       getline(basic_istream<charT,traits>& is,
               basic_string<charT,traits,Allocator>& str,
               charT delim);
V   template<class charT, class traits, class Allocator>
     basic_istream<charT,traits>&
       getline(basic_istream<charT,traits>& is,
               basic_string<charT,traits,Allocator>& str);
V   typedef basic_string<char> string;
T   typedef basic_string<wchar_t> wstring;
   }

   21.3  Template class basic_string                   [lib.basic.string]

V  namespace std {
    template<class charT, class traits = char_traits<charT>,
             class Allocator = allocator<charT> >
    class basic_string {
    public:
      // types:
      typedef          traits                     traits_type;
      typedef typename traits::char_type          value_type;
      typedef          Allocator                  allocator_type;
      typedef typename Allocator::size_type       size_type;
      typedef typename Allocator::difference_type difference_type;
      typedef typename Allocator::reference       reference;
      typedef typename Allocator::const_reference const_reference;
      typedef typename Allocator::pointer         pointer;
      typedef typename Allocator::const_pointer   const_pointer;
      typedef implementation defined             iterator;
      typedef implementation defined             const_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      static const size_type npos = -1;

      // _lib.string.cons_ construct/copy/destroy:
V     explicit basic_string(const Allocator& a = Allocator());
V     basic_string(const basic_string& str, size_type pos = 0,
                   size_type n = npos, const Allocator& a = Allocator());
V     basic_string(const charT* s,
                   size_type n, const Allocator& a = Allocator());
V     basic_string(const charT* s, const Allocator& a = Allocator());
V     basic_string(size_type n, charT c, const Allocator& a = Allocator());
V     template<class InputIterator>
        basic_string(InputIterator begin, InputIterator end,
                     const Allocator& a = Allocator());
V    ~basic_string();
V     basic_string& operator=(const basic_string& str);
V     basic_string& operator=(const charT* s);
V     basic_string& operator=(charT c);
      // _lib.string.iterators_ iterators:
V     iterator       begin();
V     const_iterator begin() const;
V     iterator       end();
V     const_iterator end() const;

V     reverse_iterator       rbegin();
V     const_reverse_iterator rbegin() const;
V     reverse_iterator       rend();
V     const_reverse_iterator rend() const;
      // _lib.string.capacity_ capacity:
V     size_type size() const;
V     size_type length() const;
V     size_type max_size() const;
V     void resize(size_type n, charT c);
V     void resize(size_type n);
V     size_type capacity() const;
V     void reserve(size_type res_arg = 0);
V     void clear();
V     bool empty() const;
      // _lib.string.access_ element access:
V     const_reference operator[](size_type pos) const;
V     reference       operator[](size_type pos);
V     const_reference at(size_type n) const;
V     reference       at(size_type n);
      // _lib.string.modifiers_ modifiers:
V     basic_string& operator+=(const basic_string& str);
V     basic_string& operator+=(const charT* s);
V     basic_string& operator+=(charT c);
V     basic_string& append(const basic_string& str);
V     basic_string& append(const basic_string& str, size_type pos,
                           size_type n);
V     basic_string& append(const charT* s, size_type n);
V     basic_string& append(const charT* s);
V     basic_string& append(size_type n, charT c);
V     template<class InputIterator>
        basic_string& append(InputIterator first, InputIterator last);
V     void push_back(const charT);

V     basic_string& assign(const basic_string&);
V     basic_string& assign(const basic_string& str, size_type pos,
                           size_type n);
V     basic_string& assign(const charT* s, size_type n);
V     basic_string& assign(const charT* s);
V     basic_string& assign(size_type n, charT c);
V     template<class InputIterator>
        basic_string& assign(InputIterator first, InputIterator last);
V     basic_string& insert(size_type pos1, const basic_string& str);
V     basic_string& insert(size_type pos1, const basic_string& str,
                           size_type pos2, size_type n);
V     basic_string& insert(size_type pos, const charT* s, size_type n);
V     basic_string& insert(size_type pos, const charT* s);
V     basic_string& insert(size_type pos, size_type n, charT c);
V     iterator insert(iterator p, charT c);
V     void     insert(iterator p, size_type n, charT c);
V     template<class InputIterator>
        void insert(iterator p, InputIterator first, InputIterator last);
V     basic_string& erase(size_type pos = 0, size_type n = npos);
V     iterator erase(iterator position);
V     iterator erase(iterator first, iterator last);
V     basic_string& replace(size_type pos1, size_type n1,
                            const basic_string& str);
V     basic_string& replace(size_type pos1, size_type n1,
                            const basic_string& str,
                            size_type pos2, size_type n2);
V     basic_string& replace(size_type pos, size_type n1, const charT* s,
                            size_type n2);
V     basic_string& replace(size_type pos, size_type n1, const charT* s);
V     basic_string& replace(size_type pos, size_type n1, size_type n2,
                            charT c);
V     basic_string& replace(iterator i1, iterator i2, const basic_string& str);
V     basic_string& replace(iterator i1, iterator i2, const charT* s,
                            size_type n);
V     basic_string& replace(iterator i1, iterator i2, const charT* s);
V     basic_string& replace(iterator i1, iterator i2,
                            size_type n, charT c);
V     template<class InputIterator>
        basic_string& replace(iterator i1, iterator i2,
                              InputIterator j1, InputIterator j2);
V     size_type copy(charT* s, size_type n, size_type pos = 0) const;
V     void swap(basic_string<charT,traits,Allocator>&);
      // _lib.string.ops_ string operations:
V     const charT* c_str() const;         // explicit
V     const charT* data() const;
V     allocator_type get_allocator() const;
V     size_type find (const basic_string& str, size_type pos = 0) const;
V     size_type find (const charT* s, size_type pos, size_type n) const;
V     size_type find (const charT* s, size_type pos = 0) const;
V     size_type find (charT c, size_type pos = 0) const;
V     size_type rfind(const basic_string& str, size_type pos = npos) const;
V     size_type rfind(const charT* s, size_type pos, size_type n) const;
V     size_type rfind(const charT* s, size_type pos = npos) const;
V     size_type rfind(charT c, size_type pos = npos) const;

V     size_type find_first_of(const basic_string& str,
                              size_type pos = 0) const;
V     size_type find_first_of(const charT* s,
                              size_type pos, size_type n) const;
V     size_type find_first_of(const charT* s, size_type pos = 0) const;
V     size_type find_first_of(charT c, size_type pos = 0) const;
V     size_type find_last_of (const basic_string& str,
                              size_type pos = npos) const;
V     size_type find_last_of (const charT* s,
                              size_type pos, size_type n) const;
V     size_type find_last_of (const charT* s, size_type pos = npos) const;
V     size_type find_last_of (charT c, size_type pos = npos) const;
V     size_type find_first_not_of(const basic_string& str,
                                  size_type pos = 0) const;
V     size_type find_first_not_of(const charT* s, size_type pos,
                                  size_type n) const;
V     size_type find_first_not_of(const charT* s, size_type pos = 0) const;
V     size_type find_first_not_of(charT c, size_type pos = 0) const;
V     size_type find_last_not_of (const basic_string& str,
                                  size_type pos = npos) const;
V     size_type find_last_not_of (const charT* s, size_type pos,
                                  size_type n) const;
V     size_type find_last_not_of (const charT* s,
                                  size_type pos = npos) const;
V     size_type find_last_not_of (charT c, size_type pos = npos) const;
V     basic_string substr(size_type pos = 0, size_type n = npos) const;
V     int compare(const basic_string& str) const;
V     int compare(size_type pos1, size_type n1,
                  const basic_string& str) const;
V     int compare(size_type pos1, size_type n1,
                  const basic_string& str,
                  size_type pos2, size_type n2) const;
V     int compare(const charT* s) const;
V     int compare(size_type pos1, size_type n1,
                  const charT* s, size_type n2 = npos) const;
    };
   }

   21.4  Null-terminated sequence utilities               [lib.c.strings]

                    Table 10--Header <cctype> synopsis

            isalnum   isdigit   isprint   isupper    tolower
X           isalpha   isgraph   ispunct   isxdigit   toupper
            iscntrl   islower   isspace

                   Table 11--Header <cwctype> synopsis

X  Macro:     WEOF <cwctype>
X  Types:     wctrans_t   wctype_t   wint_t <cwctype>
   Functions:
X  iswalnum   iswctype    iswlower   iswspace    towctrans   wctrans
X  iswalpha   iswdigit    iswprint   iswupper    towlower    wctype
X  iswcntrl   iswgraph    iswpunct   iswxdigit   towupper

                   Table 12--Header <cstring> synopsis

X           Macro:    NULL <cstring>
X           Type:     size_t <cstring>
            Functions:
X           memchr    strcat    strcspn    strncpy   strtok
X           memcmp    strchr    strerror   strpbrk   strxfrm
X           memcpy    strcmp    strlen     strrchr
X           memmove   strcoll   strncat    strspn
X           memset    strcpy    strncmp    strstr

                    Table 13--Header <cwchar> synopsis
   Macros:    NULL <cwchar>   WCHAR_MAX         WCHAR_MIN   WEOF <cwchar>
   Types:     mbstate_t       wint_t <cwchar>   size_t
   Functions:
X  btowc      getwchar        ungetwc           wcscpy      wcsrtombs   wmemchr
X  fgetwc     mbrlen          vfwprintf         wcscspn     wcsspn      wmemcmp
X  fgetws     mbrtowc         vswprintf         wcsftime    wcsstr      wmemcpy
X  fputwc     mbsinit         vwprintf          wcslen      wcstod      wmemmove
X  fputws     mbsrtowcs       wcrtomb           wcsncat     wcstok      wmemset
X  fwide      putwc           wcscat            wcsncmp     wcstol      wprintf
X  fwprintf   putwchar        wcschr            wcsncpy     wcstoul     wscanf
X  fwscanf    swprintf        wcscmp            wcspbrk     wcsxfrm
X  getwc      swscanf         wcscoll           wcsrchr     wctob

                   Table 14--Header <cstdlib> synopsis

               Macros:   MB_CUR_MAX
               Functions:
X              atol      mblen        strtod    wctomb
X              atof      mbstowcs     strtol    wcstombs
X              atoi      mbtowc       strtoul

X  const char* strchr(const char* s, int c);
X       char* strchr(      char* s, int c);

X  const char* strpbrk(const char* s1, const char* s2);
X       char* strpbrk(      char* s1, const char* s2);

X  const char* strrchr(const char* s, int c);
X       char* strrchr(      char* s, int c);

X  const char* strstr(const char* s1, const char* s2);
X       char* strstr(      char* s1, const char* s2);

X  const void* memchr(const void* s, int c, size_t n);
X       void* memchr(      void* s, int c, size_t n);

X  const wchar_t* wcschr(const wchar_t* s, wchar_t c);
X       wchar_t* wcschr(      wchar_t* s, wchar_t c);

X  const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
X       wchar_t* wcspbrk(      wchar_t* s1, const wchar_t* s2);

X  const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
X       wchar_t* wcsrchr(      wchar_t* s, wchar_t c);

X  const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
X       wchar_t* wcsstr(      wchar_t* s1, const wchar_t* s2);

X  const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
X       wchar_t* wmemchr(      wchar_t* s, wchar_t c, size_t n);

   [for initial efforts on the above, see shadow/string.h]

   22.1  Locales                                            [lib.locales]

   Header <locale> synopsis

    // _lib.locale_, locale:
T   class locale;
T   template <class Facet> const Facet& use_facet(const locale&);
T   template <class Facet> bool         has_facet(const locale&) throw();

    // _lib.locale.convenience_, convenience interfaces:
T   template <class charT> bool isspace (charT c, const locale& loc);
T   template <class charT> bool isprint (charT c, const locale& loc);
T   template <class charT> bool iscntrl (charT c, const locale& loc);
T   template <class charT> bool isupper (charT c, const locale& loc);
T   template <class charT> bool islower (charT c, const locale& loc);
T   template <class charT> bool isalpha (charT c, const locale& loc);
T   template <class charT> bool isdigit (charT c, const locale& loc);
T   template <class charT> bool ispunct (charT c, const locale& loc);
T   template <class charT> bool isxdigit(charT c, const locale& loc);
T   template <class charT> bool isalnum (charT c, const locale& loc);
T   template <class charT> bool isgraph (charT c, const locale& loc);
T   template <class charT> charT toupper(charT c, const locale& loc);
T   template <class charT> charT tolower(charT c, const locale& loc);
    // _lib.category.ctype_ and _lib.facet.ctype.special_, ctype:
    class ctype_base;
T   template <class charT> class ctype;
T   template <>            class ctype<char>;             // specialization
S   template <class charT> class ctype_byname;
S   template <>            class ctype_byname<char>;      // specialization
T   class codecvt_base;
X   template <class internT, class externT, class stateT> class codecvt;
S   template <class internT, class externT, class stateT> class codecvt_byname;
    // _lib.category.numeric_ and _lib.facet.numpunct_, numeric:
X   template <class charT, class InputIterator>  class num_get;
X   template <class charT, class OutputIterator> class num_put;
T   template <class charT> class numpunct;
S   template <class charT> class numpunct_byname;
    // _lib.category.collate_, collation:
T   template <class charT> class collate;
S   template <class charT> class collate_byname;
    // _lib.category.time_, date and time:
T   class time_base;
S   template <class charT, class InputIterator>  class time_get;
S   template <class charT, class InputIterator>  class time_get_byname;
S   template <class charT, class OutputIterator> class time_put;
S   template <class charT, class OutputIterator> class time_put_byname;
    // _lib.category.monetary_, money:
T   class money_base;
S   template <class charT, class InputIterator>  class money_get;
S   template <class charT, class OutputIterator> class money_put;
S   template <class charT, bool Intl> class moneypunct;
S   template <class charT, bool Intl> class moneypunct_byname;
    // _lib.category.messages_, message retrieval:
T   class messages_base;
S   template <class charT> class messages;
S   template <class charT> class messages_byname;


   22.1.1  Class locale                                      [lib.locale]

X   class locale {
    public:
      // types:
T     class facet;
T     class id;
T     typedef int category;
T     static const category   // values assigned here are for exposition only
T       none     = 0,
T       collate  = 0x010, ctype    = 0x020,
T       monetary = 0x040, numeric  = 0x080,
T       time     = 0x100, messages = 0x200,
T       all = collate | ctype | monetary | numeric | time  | messages;
      // construct/copy/destroy:
T     locale() throw()
T     locale(const locale& other) throw()
X     explicit locale(const char* std_name);
X     locale(const locale& other, const char* std_name, category);
T     template <class Facet> locale(const locale& other, Facet* f);
T     locale(const locale& other, const locale& one, category);
T    ~locale() throw();           // non-virtual
T     const locale& operator=(const locale& other) throw();
T     template <class Facet> locale combine(const locale& other) const;
      // locale operations:
X     basic_string<char>                  name() const;
T     bool operator==(const locale& other) const;
T     bool operator!=(const locale& other) const;
T     template <class charT, class Traits, class Allocator>
        bool operator()(const basic_string<charT,Traits,Allocator>& s1,
                        const basic_string<charT,Traits,Allocator>& s2) const;
      // global locale objects:
T     static       locale  global(const locale&);
T     static const locale& classic();
    };

   22.1.1.1  locale types                              [lib.locale.types]

   22.1.1.1.1  Type locale::category                [lib.locale.category]

T  typedef int category;

T   none, collate, ctype, monetary, numeric, time, and messages

      [required locale members]
T     collate<char>, collate<wchar_t>
T     ctype<char>, ctype<wchar_t>
T     codecvt<char,char,mbstate_t>,
S     codecvt<wchar_t,char,mbstate_t>
T     moneypunct<char>, moneypunct<wchar_t>
T     moneypunct<char,true>, moneypunct<wchar_t,true>,
S     money_get<char>, money_get<wchar_t
S     money_put<char>, money_put<wchar_t>
T     numpunct<char>, numpunct<wchar_t>,
X     num_get<char>, num_get<wchar_t>
X     num_put<char>, num_put<wchar_t>
S     time_get<char>, time_get<wchar_t>,
S     time_put<char>, time_put<wchar_t>
S     messages<char>, messages<wchar_t>

      [required instantiations]
S    collate_byname<char>, collate_byname<wchar_t>
S    ctype_byname<char>, ctype_byname<wchar_t>
S    codecvt_byname<char,char,mbstate_t>,
S    codecvt_byname<wchar_t,char,mbstate_t>
S    moneypunct_byname<char,International>,
S    moneypunct_byname<wchar_t,International>,
S    money_get<C,InputIterator>,
S    money_put<C,OutputIterator>
S    numpunct_byname<char>, numpunct_byname<wchar_t>
X    num_get<C,InputIterator>, num_put<C,OutputIterator>
S    time_get<char,InputIterator>,
S    time_get_byname<char,InputIterator>,
S    time_get<wchar_t,OutputIterator>,
S    time_get_byname<wchar_t,OutputIterator>,
S    time_put<char,OutputIterator>,
S    time_put_byname<char,OutputIterator>,
S    time_put<wchar_t,OutputIterator>
S    time_put_byname<wchar_t,OutputIterator>
S    messages_byname<char>, messages_byname<wchar_t>


   22.1.1.1.2  Class locale::facet                     [lib.locale.facet]

T   class locale::facet {
    protected:
T     explicit facet(size_t refs = 0);
T     virtual ~facet();
    private:
T     facet(const facet&);                // not defined
T     void operator=(const facet&);       // not defined
    };
   }


   22.1.1.1.3  Class locale::id                           [lib.locale.id]

T   class locale::id {
    public:
T     id();
    private:
T     void operator=(const id&);  // not defined
T     id(const id&);              // not defined
    };
   }


   22.2.1  The ctype category                        [lib.category.ctype]

T   class ctype_base {
    public:
T     enum mask {         // numeric values are for exposition only.
T       space=, print=, cntrl=, upper=, lower=,
T       alpha=, digit=, punct=, xdigit=,
T       alnum=, graph=
      };
    };


   22.2.1.1  Template class ctype                      [lib.locale.ctype]

T   template <class charT>
    class ctype : public locale::facet, public ctype_base {
    public:
T     typedef charT char_type;
T     explicit ctype(size_t refs = 0);
T     bool         is(mask m, charT c) const;
T     const charT* is(const charT* low, const charT* high, mask* vec) const;
T     const charT* scan_is(mask m,
                           const charT* low, const charT* high) const;
T     const charT* scan_not(mask m,
                            const charT* low, const charT* high) const;
T     charT        toupper(charT c) const;
T     const charT* toupper(charT* low, const charT* high) const;
T     charT        tolower(charT c) const;
T     const charT* tolower(charT* low, const charT* high) const;
T     charT        widen(char c) const;
T     const char*  widen(const char* low, const char* high, charT* to) const;
T     char         narrow(charT c, char dfault) const;
T     const charT* narrow(const charT* low, const charT*, char dfault,
                          char* to) const;
T     static locale::id id;

    protected:
T    ~ctype();                    // virtual
T     virtual bool         do_is(mask m, charT c) const;
T     virtual const charT* do_is(const charT* low, const charT* high,
                                 mask* vec) const;
T     virtual const charT* do_scan_is(mask m,
                              const charT* low, const charT* high) const;
T     virtual const charT* do_scan_not(mask m,
                              const charT* low, const charT* high) const;
T     virtual charT        do_toupper(charT) const;
T     virtual const charT* do_toupper(charT* low, const charT* high) const;
T     virtual charT        do_tolower(charT) const;
T     virtual const charT* do_tolower(charT* low, const charT* high) const;
T     virtual charT        do_widen(char) const;
T     virtual const char*  do_widen(const char* low, const char* high,
                                    charT* dest) const;
T     virtual char         do_narrow(charT, char dfault) const;
T     virtual const charT* do_narrow(const charT* low, const charT* high,
                                     char dfault, char* dest) const;
    };


   22.2.1.2  Template class ctype_byname        [lib.locale.ctype.byname]

X   template <class charT>
    class ctype_byname : public ctype<charT> {
    public:
T     typedef ctype<charT>::mask mask;
S     explicit ctype_byname(const char*, size_t refs = 0);
    protected:
S    ~ctype_byname();             // virtual
S     virtual bool         do_is(mask m, charT c) const;
S     virtual const charT* do_is(const charT* low, const charT* high,
                                 mask* vec) const;
S     virtual const char*  do_scan_is(mask m,
                               const charT* low, const charT* high) const;
S     virtual const char*  do_scan_not(mask m,
                               const charT* low, const charT* high) const;
S     virtual charT        do_toupper(charT) const;
S     virtual const charT* do_toupper(charT* low, const charT* high) const;
S     virtual charT        do_tolower(charT) const;
S     virtual const charT* do_tolower(charT* low, const charT* high) const;
S     virtual charT        do_widen(char) const;
S     virtual const char*  do_widen(const char* low, const char* high,
                                    charT* dest) const;
S     virtual char         do_narrow(charT, char dfault) const;
S     virtual const charT* do_narrow(const charT* low, const charT* high,
                                     char dfault, char* dest) const;
    };

   22.2.1.3  ctype specializations              [lib.facet.ctype.special]

T   template <> class ctype<char>
      : public locale::facet, public ctype_base {
    public:
T     typedef char char_type;
T     explicit ctype(const mask* tab = 0, bool del = false,
                     size_t refs = 0);
T     bool is(mask m, char c) const;
T     const char* is(const char* low, const char* high, mask* vec) const;
T     const char* scan_is (mask m,
                           const char* low, const char* high) const;
T     const char* scan_not(mask m,
                           const char* low, const char* high) const;
T     char        toupper(char c) const;
T     const char* toupper(char* low, const char* high) const;
T     char        tolower(char c) const;
T     const char* tolower(char* low, const char* high) const;
T     char  widen(char c) const;
T     const char* widen(const char* low, const char* high, char* to) const;
T     char  narrow(char c, char dfault) const;
T     const char* narrow(const char* low, const char* high, char dfault,
                         char* to) const;
T     static locale::id id;
T     static const size_t table_size = IMPLEMENTATION_DEFINED;

    protected:
T     const mask* table() const throw();
T     static const mask* classic_table() throw();
T    ~ctype();                    // virtual
T     virtual char        do_toupper(char c) const;
T     virtual const char* do_toupper(char* low, const char* high) const;
T     virtual char        do_tolower(char c) const;
T     virtual const char* do_tolower(char* low, const char* high) const;

T     virtual char        do_widen(char c) const;
T     virtual const char* do_widen(const char* low,
                                   const char* high,
                                   char* to) const;
T     virtual char        do_narrow(char c, char dfault) const;
T     virtual const char* do_narrow(const char* low,
                                    const char* high,
                                    char dfault, char* to) const;
    };


   22.2.1.4  Class                      [lib.locale.ctype.byname.special]
       ctype_byname<char>

X   template <> class ctype_byname<char> : public ctype<char> {
    public:
S     explicit ctype_byname(const char*, size_t refs = 0);
    protected:
S    ~ctype_byname();             // virtual
S     virtual char        do_toupper(char c) const;
S     virtual const char* do_toupper(char* low, const char* high) const;
S     virtual char        do_tolower(char c) const;
S     virtual const char* do_tolower(char* low, const char* high) const;

S     virtual char        do_widen(char c) const;
S     virtual const char* do_widen(char* low,
                                   const char* high,
                                   char* to) const;
S     virtual char        do_widen(char c) const;
S     virtual const char* do_widen(char* low, const char* high) const;

    };



   22.2.1.5  Template class codecvt                  [lib.locale.codecvt]

T  class codecvt_base {
   public:
T   enum result { ok, partial, error, noconv };
   };

T  template <class internT, class externT, class stateT>
   class codecvt : public locale::facet, public codecvt_base {
   public:
T   typedef internT  intern_type;
T   typedef externT  extern_type;
T   typedef stateT state_type;
T   explicit codecvt(size_t refs = 0)
T   result out(stateT& state,
     const internT* from, const internT* from_end, const internT*& from_next,
           externT*   to,       externT* to_limit, externT*& to_next) const;
T   result unshift(stateT& state,
           externT*   to,        externT* to_limit, externT*& to_next) const;
T   result in(stateT& state,
     const externT* from, const externT* from_end, const externT*& from_next,
           internT*   to,       internT* to_limit, internT*& to_next) const;
T   int encoding() const throw();
T   bool always_noconv() const throw();
T   int length(const stateT&, const externT* from, const externT* end,
               size_t max) const;
T   int max_length() const throw();
T   static locale::id id;

   protected:
T   ~codecvt();                   // virtual
T   virtual result do_out(stateT& state,
     const internT* from, const internT* from_end, const internT*& from_next,
           externT* to,         externT* to_limit, externT*& to_next) const;
T   virtual result do_in(stateT& state,
T    const externT* from, const externT* from_end, const externT*& from_next,
           internT* to,         internT* to_limit, internT*& to_next) const;
T   virtual result do_unshift(stateT& state,
           externT* to,         externT* to_limit, externT*& to_next) const;
T   virtual int do_encoding() const throw();
T   virtual bool do_always_noconv() const throw();
T   virtual int do_length(const stateT&, const externT* from,
                          const externT* end, size_t max) const;
T   virtual int do_max_length() const throw();
   };
   }


   22.2.1.6  Template class                   [lib.locale.codecvt.byname]
       codecvt_byname

X  template <class internT, class externT, class stateT>
   class codecvt_byname : public codecvt<internT, externT, stateT> {
   public:
S   explicit codecvt_byname(const char*, size_t refs = 0);
   protected:
S  ~codecvt_byname();             // virtual
S   virtual result do_out(stateT& state,
      const internT* from, const internT* from_end, const internT*& from_next,
            externT* to,         externT* to_limit, externT*& to_next) const;
S   virtual result do_in(stateT& state,
      const externT* from, const externT* from_end, const externT*& from_next,
            internT* to,         internT* to_limit, internT*& to_next) const;
S   virtual result do_unshift(stateT& state,
            externT* to,         externT* to_limit, externT*& to_next) const;
S   virtual int do_encoding() const throw();
S   virtual bool do_always_noconv() const throw();
S   virtual int do_length(const stateT&, const externT* from,
                          const externT* end, size_t max) const;
S   virtual result do_unshift(stateT& state,
           externT* to, externT* to_limit, externT*& to_next) const;
S   virtual int do_max_length() const throw();
    };


   22.2.2.1  Template class num_get                  [lib.locale.num.get]

X   template <class charT, class InputIterator = istreambuf_iterator<charT> >
    class num_get : public locale::facet {
    public:
T     typedef charT            char_type;
T     typedef InputIterator    iter_type;
T     explicit num_get(size_t refs = 0);
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, bool& v)           const;
T     iter_type get(iter_type in, iter_type end, ios_base& ,
                    ios_base::iostate& err, long& v)           const;
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, unsigned short& v) const;
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, unsigned int& v)   const;
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, unsigned long& v)  const;
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, float& v)          const;
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, double& v)         const;
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, long double& v)    const;
T     iter_type get(iter_type in, iter_type end, ios_base&,
                    ios_base::iostate& err, void*& v)          const;
T     static locale::id id;

    protected:
T    ~num_get();                  // virtual
T     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, bool& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, long& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, unsigned short& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, unsigned int& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, unsigned long& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, float& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, double& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, long double& v) const;
S     virtual iter_type do_get(iter_type, iter_type, ios_base&,
          ios_base::iostate& err, void*& v) const;
    };



   22.2.2.2  Template class num_put                   [lib.locale.nm.put]

X   template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
    class num_put : public locale::facet {
    public:
T     typedef charT            char_type;
T     typedef OutputIterator   iter_type;
T     explicit num_put(size_t refs = 0);
T     iter_type put(iter_type s, ios_base& f, char_type fill, bool v) const;
T     iter_type put(iter_type s, ios_base& f, char_type fill, long v) const;
T     iter_type put(iter_type s, ios_base& f, char_type fill,
                    unsigned long v) const;
T     iter_type put(iter_type s, ios_base& f, char_type fill,
                    double v) const;
T     iter_type put(iter_type s, ios_base& f, char_type fill,
                    long double v) const;
T     iter_type put(iter_type s, ios_base& f, char_type fill,
                    const void* v) const;
T     static locale::id id;
    protected:
T    ~num_put();                  // virtual
T     virtual iter_type do_put(iter_type, ios_base&, char_type fill,
                               bool v) const;
T     virtual iter_type do_put(iter_type, ios_base&, char_type fill,
                               long v) const;
T     virtual iter_type do_put(iter_type, ios_base&, char_type fill,
                               unsigned long) const;
S     virtual iter_type do_put(iter_type, ios_base&, char_type fill,
                               double v) const;
S     virtual iter_type do_put(iter_type, ios_base&, char_type fill,
                               long double v) const;
T     virtual iter_type do_put(iter_type, ios_base&, char_type fill,
                               const void* v) const;
    };
   }

   22.2.3.1  Template class numpunct                [lib.locale.numpunct]

T   template <class charT>
    class numpunct : public locale::facet {
    public:
T     typedef charT               char_type;
T     typedef basic_string<charT> string_type;
T     explicit numpunct(size_t refs = 0);
T     char_type    decimal_point()   const;
T     char_type    thousands_sep()   const;
T     string       grouping()        const;
T     string_type  truename()        const;
T     string_type  falsename()       const;
T     static locale::id id;
    protected:
T    ~numpunct();                 // virtual
T     virtual char_type    do_decimal_point() const;
T     virtual char_type    do_thousands_sep() const;
T     virtual string       do_grouping()      const;
T     virtual string_type  do_truename()      const;      // for bool
T     virtual string_type  do_falsename()     const;      // for bool
    };
   }



   22.2.3.2  Template class                  [lib.locale.numpunct.byname]
       numpunct_byname

X   template <class charT>
    class numpunct_byname : public numpunct<charT> {
   // this class is specialized for char and wchar_t.
    public:
T     typedef charT                char_type;
T     typedef basic_string<charT>  string_type;
S     explicit numpunct_byname(const char*, size_t refs = 0);
    protected:
S    ~numpunct_byname();          // virtual
S     virtual char_type    do_decimal_point() const;
S     virtual char_type    do_thousands_sep() const;
S     virtual string       do_grouping()      const;
S     virtual string_type  do_truename()      const;      // for bool
S     virtual string_type  do_falsename()     const;      // for bool
    };


   22.2.4.1  Template class collate                  [lib.locale.collate]

T   template <class charT>
    class collate : public locale::facet {
    public:
T     typedef charT               char_type;
T     typedef basic_string<charT> string_type;
T     explicit collate(size_t refs = 0);
T     int compare(const charT* low1, const charT* high1,
                  const charT* low2, const charT* high2) const;
T     string_type transform(const charT* low, const charT* high) const;
T     long hash(const charT* low, const charT* high) const;
T     static locale::id id;
    protected:
T    ~collate();                  // virtual
T     virtual int    do_compare(const charT* low1, const charT* high1,
                                const charT* low2, const charT* high2) const;
T     virtual string_type do_transform
                               (const charT* low, const charT* high) const;
T     virtual long   do_hash   (const charT* low, const charT* high) const;
    };


   22.2.4.2  Template class                   [lib.locale.collate.byname]
       collate_byname

X   template <class charT>
    class collate_byname : public collate<charT> {
    public:
T     typedef basic_string<charT> string_type;
T     explicit collate_byname(const char*, size_t refs = 0);
    protected:
S    ~collate_byname();           // virtual
S     virtual int    do_compare(const charT* low1, const charT* high1,
                                const charT* low2, const charT* high2) const;
S     virtual string_type do_transform
                               (const charT* low, const charT* high) const;
S     virtual long   do_hash   (const charT* low, const charT* high) const;
    };


   22.2.5.1  Template class time_get                [lib.locale.time.get]

T   class time_base {
    public:
T     enum dateorder { no_order, dmy, mdy, ymd, ydm };
    };

    [Note: semantics of time_get members are implementation-defined.
     To complete implementation requires documenting behavior.]

X   template <class charT, class InputIterator = istreambuf_iterator<charT> >
    class time_get : public locale::facet, public time_base {
    public:
T     typedef charT            char_type;
T     typedef InputIterator    iter_type;
T     explicit time_get(size_t refs = 0);

T     dateorder date_order()  const { return do_date_order(); }
T     iter_type get_time(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t)  const;
T     iter_type get_date(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t)  const;
T     iter_type get_weekday(iter_type s, iter_type end, ios_base& f,
                            ios_base::iostate& err, tm* t) const;
T     iter_type get_monthname(iter_type s, iter_type end, ios_base& f,
                              ios_base::iostate& err, tm* t) const;
T     iter_type get_year(iter_type s, iter_type end, ios_base& f,
                         ios_base::iostate& err, tm* t) const;
T     static locale::id id;
    protected:
     ~time_get();                 // virtual
X     virtual dateorder do_date_order()  const;
S     virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
S     virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
S     virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&,
                                       ios_base::iostate& err, tm* t) const;
S     virtual iter_type do_get_monthname(iter_type s, ios_base&,
                                         ios_base::iostate& err, tm* t) const;
S     virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
    };



   22.2.5.2  Template class                  [lib.locale.time.get.byname]
       time_get_byname

X   template <class charT, class InputIterator = istreambuf_iterator<charT> >
    class time_get_byname : public time_get<charT, InputIterator> {
    public:
T     typedef time_base::dateorder dateorder;
T     typedef InputIterator        iter_type

S     explicit time_get_byname(const char*, size_t refs = 0);
    protected:
S    ~time_get_byname();          // virtual
S     virtual dateorder do_date_order()  const;
S     virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
S     virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
T     virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&,
                                       ios_base::iostate& err, tm* t) const;
T     virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&,
                                         ios_base::iostate& err, tm* t) const;
S     virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&,
                                    ios_base::iostate& err, tm* t) const;
    };
   }

   22.2.5.3  Template class time_put                [lib.locale.time.put]

X   template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
    class time_put : public locale::facet {
    public:
T     typedef charT            char_type;
T     typedef OutputIterator   iter_type;
T     explicit time_put(size_t refs = 0);
      // the following is implemented in terms of other member functions.
S     iter_type put(iter_type s, ios_base& f, char_type fill, const tm* tmb,
                    const charT* pattern, const charT* pat_end) const;
T     iter_type put(iter_type s, ios_base& f, char_type fill,
                    const tm* tmb, char format, char modifier = 0) const;
T     static locale::id id;
    protected:
T    ~time_put();                 // virtual
S     virtual iter_type do_put(iter_type s, ios_base&, char_type, const tm* t,
                               char format, char modifier) const;
    };



   22.2.5.4  Template class                  [lib.locale.time.put.byname]
       time_put_byname

T   template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
    class time_put_byname : public time_put<charT, OutputIterator>
    {
    public:
T     typedef charT          char_type;
T     typedef OutputIterator iter_type;

T     explicit time_put_byname(const char*, size_t refs = 0);
    protected:
T    ~time_put_byname();          // virtual
S     virtual iter_type do_put(iter_type s, ios_base&, char_type, const tm* t,
                               char format, char modifier) const;
    };


   22.2.6.1  Template class money_get              [lib.locale.money.get]

X   template <class charT,
              class InputIterator = istreambuf_iterator<charT> >
    class money_get : public locale::facet {
    public:
T     typedef charT               char_type;
T     typedef InputIterator       iter_type;
T     typedef basic_string<charT> string_type;
T     explicit money_get(size_t refs = 0);
T     iter_type get(iter_type s, iter_type end, bool intl,
                    ios_base& f, ios_base::iostate& err,
                    long double& units) const;
T     iter_type get(iter_type s, iter_type end, bool intl,
                    ios_base& f, ios_base::iostate& err,
                    string_type& digits) const;
T     static locale::id id;
    protected:
T    ~money_get();                // virtual
S     virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
                       ios_base::iostate& err, long double& units) const;
S     virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
                       ios_base::iostate& err, string_type& digits) const;
    };

   22.2.6.2  Template class money_put              [lib.locale.money.put]

X   template <class charT,
              class OutputIterator = ostreambuf_iterator<charT> >
    class money_put : public locale::facet {
    public:
T     typedef charT               char_type;
T     typedef OutputIterator      iter_type;
T     typedef basic_string<charT> string_type;
T     explicit money_put(size_t refs = 0);
T     iter_type put(iter_type s, bool intl, ios_base& f,
                    char_type fill, long double units) const;
T     iter_type put(iter_type s, bool intl, ios_base& f,
                    char_type fill, const string_type& digits) const;
T     static locale::id id;

    protected:
T    ~money_put();                // virtual
S     virtual iter_type
        do_put(iter_type, bool, ios_base&, char_type fill,
               long double units) const;
S     virtual iter_type
        do_put(iter_type, bool, ios_base&, char_type fill,
               const string_type& digits) const;
    };


   22.2.6.3  Template class moneypunct            [lib.locale.moneypunct]

T   class money_base {
    public:
T     enum part { none, space, symbol, sign, value };
T     struct pattern { char field[4]; };
    };

X   template <class charT, bool International = false>
    class moneypunct : public locale::facet, public money_base {
    public:
T     typedef charT char_type;
T     typedef basic_string<charT> string_type;
T     explicit moneypunct(size_t refs = 0);
T     charT        decimal_point() const;
T     charT        thousands_sep() const;
T     string       grouping()      const;
T     string_type  curr_symbol()   const;
T     string_type  positive_sign() const;
T     string_type  negative_sign() const;
T     int          frac_digits()   const;
T     pattern      pos_format()    const;
T     pattern      neg_format()    const;
T     static locale::id id;
T     static const bool intl = International;
    protected:
T    ~moneypunct();               // virtual
S     virtual charT        do_decimal_point() const;
S     virtual charT        do_thousands_sep() const;
S     virtual string       do_grouping()      const;
S     virtual string_type  do_curr_symbol()   const;
S     virtual string_type  do_positive_sign() const;
S     virtual string_type  do_negative_sign() const;
S     virtual int          do_frac_digits()   const;
T     virtual pattern      do_pos_format()    const;
T     virtual pattern      do_neg_format()    const;
    };
   }

   22.2.6.4  Template class                [lib.locale.moneypunct.byname]
       moneypunct_byname

X   template <class charT, bool Intl = false>
    class moneypunct_byname : public moneypunct<charT, Intl> {
    public:
T     typedef money_base::pattern pattern;
T     typedef basic_string<charT> string_type;

T     explicit moneypunct_byname(const char*, size_t refs = 0);
    protected:
T    ~moneypunct_byname();        // virtual
S     virtual charT        do_decimal_point() const;
S     virtual charT        do_thousands_sep() const;
S     virtual string       do_grouping()      const;
S     virtual string_type  do_curr_symbol()   const;
S     virtual string_type  do_positive_sign() const;
S     virtual string_type  do_negative_sign() const;
S     virtual int          do_frac_digits()   const;
S     virtual pattern      do_pos_format()    const;
S     virtual pattern      do_neg_format()    const;
    };

   22.2.7.1  Template class messages                [lib.locale.messages]

T   class messages_base {
    public:
T     typedef int catalog;
    };

X   template <class charT>
    class messages : public locale::facet, public messages_base {
    public:
T     typedef charT char_type;
T     typedef basic_string<charT> string_type;
T     explicit messages(size_t refs = 0);
T     catalog open(const basic_string<char>& fn, const locale&) const;
T     string_type  get(catalog c, int set, int msgid,
                       const string_type& dfault) const;
T     void    close(catalog c) const;
T     static locale::id id;
    protected:
T    ~messages();                 // virtual
S     virtual catalog do_open(const basic_string<char>&, const locale&) const;
S     virtual string_type  do_get(catalog, int set, int msgid,
                             const string_type& dfault) const;
S     virtual void    do_close(catalog) const;
    };

   22.2.7.2  Template class                  [lib.locale.messages.byname]
       messages_byname


X   template <class charT>
    class messages_byname : public messages<charT> {
    public:
T     typedef messages_base::catalog catalog;
T     typedef basic_string<charT>    string_type;

T     explicit messages_byname(const char*, size_t refs = 0);
    protected:
T    ~messages_byname();          // virtual
S     virtual catalog do_open(const basic_string<char>&, const locale&) const;
S     virtual string_type  do_get(catalog, int set, int msgid,
                             const string_type& dfault) const;
S     virtual void    do_close(catalog) const;
    };


   22.3  C Library Locales                                [lib.c.locales]


                   Table 13--Header <clocale> synopsis
            Macros:
X                        LC_ALL        LC_COLLATE   LC_CTYPE
X                        LC_MONETARY   LC_NUMERIC   LC_TIME
X                        NULL
X           Struct:      lconv
X           Functions:   localeconv    setlocale


   23.2  Sequences                                        [lib.sequences]

   <deque>, <list>, <queue>, <stack>, and <vector>.

   Header <deque> synopsis

T   template <class T, class Allocator = allocator<T> > class deque;
T   template <class T, class Allocator>
      bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);
   }

   Header <list> synopsis

T   template <class T, class Allocator = allocator<T> > class list;
T   template <class T, class Allocator>
      bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      void swap(list<T,Allocator>& x, list<T,Allocator>& y);
   }

   Header <queue> synopsis

   namespace std {
T   template <class T, class Container = deque<T> > class queue;
T   template <class T, class Container>
      bool operator==(const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator< (const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator!=(const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator> (const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator>=(const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator<=(const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container = vector<T>,
              class Compare = less<typename Container::value_type> >
T   class priority_queue;
   }

   Header <stack> synopsis

   namespace std {
T   template <class T, class Container = deque<T> > class stack;
T   template <class T, class Container>
      bool operator==(const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator< (const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator!=(const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator> (const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator>=(const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator<=(const stack<T, Container>& x,
                      const stack<T, Container>& y);
   }

   Header <vector> synopsis

T   template <class T, class Allocator = allocator<T> > class vector;

T   template <class T, class Allocator>
      bool operator==(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator< (const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator!=(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator> (const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator>=(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator<=(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);

T   template <class Allocator> class vector<bool,Allocator>;
T   template <class Allocator>
      bool operator==(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator< (const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator!=(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator> (const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator>=(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator<=(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      void swap(vector<bool,Allocator>& x, vector<bool,Allocator>& y);
   }

   23.2.1  Template class deque                               [lib.deque]

    template <class T, class Allocator = allocator<T> >
T   class deque {
    public:
      // types:
T     typedef typename Allocator::reference         reference;
T     typedef typename Allocator::const_reference   const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type;
T     typedef T                                     value_type;
T     typedef Allocator                             allocator_type;
T     typedef typename Allocator::pointer           pointer;
T     typedef typename Allocator::const_pointer     const_pointer;
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      // _lib.deque.cons_ construct/copy/destroy:
T     explicit deque(const Allocator& = Allocator());
T     explicit deque(size_type n, const T& value = T(),
          const Allocator& = Allocator());
T     template <class InputIterator>
        deque(InputIterator first, InputIterator last,
              const Allocator& = Allocator());
T     deque(const deque<T,Allocator>& x);
T    ~deque();
T     deque<T,Allocator>& operator=(const deque<T,Allocator>& x);
T     template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
T     void assign(size_type n, const T& t);
T     allocator_type get_allocator() const;
      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // _lib.deque.capacity_ capacity:
T     size_type size() const;
T     size_type max_size() const;
T     void      resize(size_type sz, T c = T());
T     bool      empty() const;

      // element access:
T     reference       operator[](size_type n);
T     const_reference operator[](size_type n) const;
T     reference       at(size_type n);
T     const_reference at(size_type n) const;
T     reference       front();
T     const_reference front() const;
T     reference       back();
T     const_reference back() const;
      // _lib.deque.modifiers_ modifiers:
T     void push_front(const T& x);
T     void push_back(const T& x);
T     iterator insert(iterator position, const T& x);
T     void     insert(iterator position, size_type n, const T& x);
T     template <class InputIterator>
        void insert (iterator position,
                     InputIterator first, InputIterator last);
T     void pop_front();
T     void pop_back();
T     iterator erase(iterator position);
T     iterator erase(iterator first, iterator last);
T     void     swap(deque<T,Allocator>&);
T     void     clear();
    };
T   template <class T, class Allocator>
      bool operator==(const deque<T,Allocator>& x,
                      const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator< (const deque<T,Allocator>& x,
                      const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator!=(const deque<T,Allocator>& x,
                      const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator> (const deque<T,Allocator>& x,
                      const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator>=(const deque<T,Allocator>& x,
                      const deque<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator<=(const deque<T,Allocator>& x,
                      const deque<T,Allocator>& y);
    // specialized algorithms:
T   template <class T, class Allocator>
      void swap(deque<T,Allocator>& x, deque<T,Allocator>& y);


   23.2.2  Template class list                                 [lib.list]

T   template <class T, class Allocator = allocator<T> >
    class list {
    public:
      // types:
T     typedef typename Allocator::reference         reference;
T     typedef typename Allocator::const_reference   const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type;
T     typedef T                                     value_type;
T     typedef Allocator                             allocator_type;
T     typedef typename Allocator::pointer           pointer;
T     typedef typename Allocator::const_pointer     const_pointer;
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

      // _lib.list.cons_ construct/copy/destroy:
T     explicit list(const Allocator& = Allocator());
T     explicit list(size_type n, const T& value = T(),
                    const Allocator& = Allocator());
T     template <class InputIterator>
        list(InputIterator first, InputIterator last,
             const Allocator& = Allocator());
T     list(const list<T,Allocator>& x);
T    ~list();
T     list<T,Allocator>& operator=(const list<T,Allocator>& x);
T     template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
T     void assign(size_type n, const T& t);
T     allocator_type get_allocator() const;
      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // _lib.list.capacity_ capacity:
T     bool      empty() const;
T     size_type size() const;
T     size_type max_size() const;
T     void      resize(size_type sz, T c = T());
      // element access:
T     reference       front();
T     const_reference front() const;
T     reference       back();
T     const_reference back() const;
      // _lib.list.modifiers_ modifiers:
T     void push_front(const T& x);
T     void pop_front();
T     void push_back(const T& x);
T     void pop_back();
T     iterator insert(iterator position, const T& x);
T     void     insert(iterator position, size_type n, const T& x);
T     template <class InputIterator>
        void insert(iterator position, InputIterator first,
                    InputIterator last);
T     iterator erase(iterator position);
T     iterator erase(iterator position, iterator last);
T     void     swap(list<T,Allocator>&);
T     void     clear();
      // _lib.list.ops_ list operations:
T     void splice(iterator position, list<T,Allocator>& x);
T     void splice(iterator position, list<T,Allocator>& x, iterator i);
T     void splice(iterator position, list<T,Allocator>& x, iterator first,
                  iterator last);
T     void remove(const T& value);
T     template <class Predicate> void remove_if(Predicate pred);

T     void unique();
T     template <class BinaryPredicate>
        void unique(BinaryPredicate binary_pred);
T     void merge(list<T,Allocator>& x);
T     template <class Compare> void merge(list<T,Allocator>& x, Compare comp);
        void sort();
T     template <class Compare> void sort(Compare comp);
        void reverse();
    };
T   template <class T, class Allocator>
      bool operator==(const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator< (const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator!=(const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator> (const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator>=(const list<T,Allocator>& x, const list<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator<=(const list<T,Allocator>& x, const list<T,Allocator>& y);
    // specialized algorithms:
T   template <class T, class Allocator>
      void swap(list<T,Allocator>& x, list<T,Allocator>& y);


   23.2.3.1  Template class queue                             [lib.queue]

T   template <class T, class Container = deque<T> >
    class queue {
    public:
T     typedef typename Container::value_type            value_type;
T     typedef typename Container::size_type             size_type;
T     typedef          Container                        container_type;
    protected:
T     Container c;
    public:
T     explicit queue(const Container& = Container());

T     bool      empty() const             { return c.empty(); }
T     size_type size()  const             { return c.size(); }
T     value_type&       front()           { return c.front(); }
T     const value_type& front() const     { return c.front(); }
T     value_type&       back()            { return c.back(); }
T     const value_type& back() const      { return c.back(); }
T     void push(const value_type& x)      { c.push_back(x); }
T     void pop()                          { c.pop_front(); }
    };

T   template <class T, class Container>
      bool operator==(const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator< (const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator!=(const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator> (const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator>=(const queue<T, Container>& x,
                      const queue<T, Container>& y);
T   template <class T, class Container>
      bool operator<=(const queue<T, Container>& x,
                      const queue<T, Container>& y);

   23.2.3.2  Template class priority_queue           [lib.priority.queue]

T   template <class T, class Container = vector<T>,
              class Compare = less<typename Container::value_type> >
    class priority_queue {
    public:
T     typedef typename Container::value_type            value_type;
T     typedef typename Container::size_type             size_type;
T     typedef          Container                        container_type;
    protected:
T     Container c;
T     Compare comp;
    public:
T     explicit priority_queue(const Compare& x = Compare(),
                              const Container& = Container());
T     template <class InputIterator>
        priority_queue(InputIterator first, InputIterator last,
                       const Compare& x = Compare(),
                       const Container& = Container());

T     bool      empty() const       { return c.empty(); }
T     size_type size()  const       { return c.size(); }
T     const value_type& top() const { return c.front(); }
T     void push(const value_type& x);
T     void pop();
    };

   23.2.3.3  Template class stack                             [lib.stack]

T   template <class T, class Container = deque<T> >
    class stack {
    public:
T     typedef typename Container::value_type            value_type;
T     typedef typename Container::size_type             size_type;
T     typedef          Container                        container_type;
    protected:
T     Container c;
    public:
T     explicit stack(const Container& = Container());

T     bool      empty() const             { return c.empty(); }
T     size_type size()  const             { return c.size(); }
T     value_type&       top()             { return c.back(); }
T     const value_type& top() const       { return c.back(); }
T     void push(const value_type& x)      { c.push_back(x); }
T     void pop()                          { c.pop_back(); }
    };
T   template <class T, class Container>
      bool operator==(const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator< (const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator!=(const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator> (const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator>=(const stack<T, Container>& x,
                      const stack<T, Container>& y);
T   template <class T, class Container>
      bool operator<=(const stack<T, Container>& x,
                      const stack<T, Container>& y);

   23.2.4  Template class vector                             [lib.vector]

    template <class T, class Allocator = allocator<T> >
T   class vector {
    public:
      // types:
T     typedef typename Allocator::reference         reference;
T     typedef typename Allocator::const_reference   const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type;
T     typedef T                                     value_type;
T     typedef Allocator                             allocator_type;
T     typedef typename Allocator::pointer           pointer;
T     typedef typename Allocator::const_pointer     const_pointer
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      // _lib.vector.cons_ construct/copy/destroy:
T     explicit vector(const Allocator& = Allocator());
T     explicit vector(size_type n, const T& value = T(),
          const Allocator& = Allocator());
T     template <class InputIterator>
        vector(InputIterator first, InputIterator last,
          const Allocator& = Allocator());
T     vector(const vector<T,Allocator>& x);
T    ~vector();
T     vector<T,Allocator>& operator=(const vector<T,Allocator>& x);
T     template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
T     void assign(size_type n, const T& u);
T     allocator_type get_allocator() const;
      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // _lib.vector.capacity_ capacity:
T     size_type size() const;
T     size_type max_size() const;
T     void      resize(size_type sz, T c = T());
T     size_type capacity() const;
T     bool      empty() const;
T     void      reserve(size_type n);

      // element access:
T     reference       operator[](size_type n);
T     const_reference operator[](size_type n) const;
T     const_reference at(size_type n) const;
T     reference       at(size_type n);
T     reference       front();
T     const_reference front() const;
T     reference       back();
T     const_reference back() const;
      // _lib.vector.modifiers_ modifiers:
T     void push_back(const T& x);
T     void pop_back();
T     iterator insert(iterator position, const T& x);
T     void     insert(iterator position, size_type n, const T& x);
T     template <class InputIterator>
          void insert(iterator position,
                      InputIterator first, InputIterator last);
T     iterator erase(iterator position);
T     iterator erase(iterator first, iterator last);
T     void     swap(vector<T,Allocator>&);
T     void     clear();
    };

T   template <class T, class Allocator>
      bool operator==(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator< (const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator!=(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator> (const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator>=(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
T   template <class T, class Allocator>
      bool operator<=(const vector<T,Allocator>& x,
                      const vector<T,Allocator>& y);
    // specialized algorithms:
T   template <class T, class Allocator>
      void swap(vector<T,Allocator>& x, vector<T,Allocator>& y);


   23.2.5  Class vector<bool>                           [lib.vector.bool]

T   template <class Allocator> class vector<bool, Allocator> {
    public:
      // types:
T     typedef bool                                  const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type;
T     typedef bool                                  value_type;
T     typedef Allocator                             allocator_type;
T     typedef implementation defined                pointer;
T     typedef implementation defined                const_pointer
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      // bit reference:
T     class reference {
       friend class vector;
T      reference();
      public:
T      ~reference();
T       operator bool() const;
T       reference& operator=(const bool x);
T       reference& operator=(const reference& x);
T       void flip();              // flips the bit
      };

      // construct/copy/destroy:
T     explicit vector(const Allocator& = Allocator());
T     explicit vector(size_type n, const bool& value = bool(),
                      const Allocator& = Allocator());
T     template <class InputIterator>
        vector(InputIterator first, InputIterator last,
          const Allocator& = Allocator());
T     vector(const vector<bool,Allocator>& x);
T    ~vector();
T     vector<bool,Allocator>& operator=(const vector<bool,Allocator>& x);
T     template <class InputIterator>
        void assign(InputIterator first, InputIterator last);
T     void assign(size_type n, const T& t);
T     allocator_type get_allocator() const;
      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // capacity:
T     size_type size() const;
T     size_type max_size() const;
T     void      resize(size_type sz, bool c = false);
T     size_type capacity() const;
T     bool      empty() const;
T     void      reserve(size_type n);
      // element access:
T     reference       operator[](size_type n);
T     const_reference operator[](size_type n) const;
T     const_reference at(size_type n) const;
T     reference       at(size_type n);
T     reference       front();
T     const_reference front() const;
T     reference       back();
T     const_reference back() const;
      // modifiers:
T     void push_back(const bool& x);
T     void pop_back();
T     iterator insert(iterator position, const bool& x);
T     void     insert (iterator position, size_type n, const bool& x);
T     template <class InputIterator>
          void insert(iterator position,
                      InputIterator first, InputIterator last);
T     iterator erase(iterator position);
T     iterator erase(iterator first, iterator last);
T     void swap(vector<bool,Allocator>&);
T     static void swap(reference x, reference y);
T     void flip();                // flips all bits
T     void clear();
    };

T   template <class Allocator>
      bool operator==(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator< (const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator!=(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator> (const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator>=(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
T   template <class Allocator>
      bool operator<=(const vector<bool,Allocator>& x,
                      const vector<bool,Allocator>& y);
    // specialized algorithms:
T   template <class Allocator>
      void swap(vector<bool,Allocator>& x, vector<bool,Allocator>& y);

   23.3  Associative containers                         [lib.associative]

 <map> and <set>:

   Header <map> synopsis

    template <class Key, class T, class Compare = less<Key>,
              class Allocator = allocator<pair<const Key, T> > >
T     class map;

T   template <class Key, class T, class Compare, class Allocator>
      bool operator==(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator< (const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator!=(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator> (const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator>=(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator<=(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      void swap(map<Key,T,Compare,Allocator>& x,
                map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare = less<Key>,
              class Allocator = allocator<pair<const Key, T> > >
      class multimap;
T   template <class Key, class T, class Compare, class Allocator>
      bool operator==(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator< (const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator> (const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      void swap(multimap<Key,T,Compare,Allocator>& x,
                multimap<Key,T,Compare,Allocator>& y);
   }

   Header <set> synopsis

    template <class Key, class Compare = less<Key>,
              class Allocator = allocator<Key> >
T     class set;

T   template <class Key, class Compare, class Allocator>
      bool operator==(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator< (const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator!=(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator> (const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator>=(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator<=(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      void swap(set<Key,Compare,Allocator>& x,
                set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare = less<Key>,
              class Allocator = allocator<Key> >
      class multiset;
T   template <class Key, class Compare, class Allocator>
      bool operator==(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator< (const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator!=(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator> (const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator>=(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator<=(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      void swap(multiset<Key,Compare,Allocator>& x,
                multiset<Key,Compare,Allocator>& y);
   }

   23.3.1  Template class map                                   [lib.map]

    template <class Key, class T, class Compare = less<Key>,
              class Allocator = allocator<pair<const Key, T> > >
T     class map {
    public:
      // types:
T     typedef Key                                   key_type;
T     typedef T                                     mapped_type;
T     typedef pair<const Key, T>                    value_type;
T     typedef Compare                               key_compare;
T     typedef Allocator                             allocator_type;
T     typedef typename Allocator::reference         reference;
T     typedef typename Allocator::const_reference   const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type;
T     typedef typename Allocator::pointer           pointer;
T     typedef typename Allocator::const_pointer     const_pointer;
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
T     class value_compare
        : public binary_function<value_type,value_type,bool> {
      friend class map;
      protected:
T       Compare comp;
T       value_compare(Compare c) : comp(c) {}
      public:
T       bool operator()(const value_type& x, const value_type& y) const {
          return comp(x.first, y.first);
        }
      };

      // _lib.map.cons_ construct/copy/destroy:
T     explicit map(const Compare& comp = Compare(),
                   const Allocator& = Allocator());
T     template <class InputIterator>
        map(InputIterator first, InputIterator last,
            const Compare& comp = Compare(), const Allocator& = Allocator());
T     map(const map<Key,T,Compare,Allocator>& x);
T    ~map();
T     map<Key,T,Compare,Allocator>&
        operator=(const map<Key,T,Compare,Allocator>& x);
      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // capacity:
T     bool      empty() const;
T     size_type size() const;
T     size_type max_size() const;
      // _lib.map.access_ element access:
T     T& operator[](const key_type& x);
      // modifiers:
T     pair<iterator, bool> insert(const value_type& x);
T     iterator             insert(iterator position, const value_type& x);
T     template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
T     void      erase(iterator position);
T     size_type erase(const key_type& x);
T     void      erase(iterator first, iterator last);
T     void swap(map<Key,T,Compare,Allocator>&);
T     void clear();
      // observers:
T     key_compare   key_comp() const;
T     value_compare value_comp() const;
      // _lib.map.ops_ map operations:
T     iterator       find(const key_type& x);
T     const_iterator find(const key_type& x) const;
T     size_type      count(const key_type& x) const;
T     iterator       lower_bound(const key_type& x);
T     const_iterator lower_bound(const key_type& x) const;
T     iterator       upper_bound(const key_type& x);
T     const_iterator upper_bound(const key_type& x) const;
T     pair<iterator,iterator>
          equal_range(const key_type& x);
T     pair<const_iterator,const_iterator>
          equal_range(const key_type& x) const;
    };

T   template <class Key, class T, class Compare, class Allocator>
      bool operator==(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator< (const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator!=(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator> (const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator>=(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator<=(const map<Key,T,Compare,Allocator>& x,
                      const map<Key,T,Compare,Allocator>& y);
    // specialized algorithms:
T   template <class Key, class T, class Compare, class Allocator>
      void swap(map<Key,T,Compare,Allocator>& x,
                map<Key,T,Compare,Allocator>& y);

   23.3.2  Template class multimap                         [lib.multimap]

    template <class Key, class T, class Compare = less<Key>,
              class Allocator = allocator<pair<const Key, T> > >
T   class multimap {
    public:
      // types:
T     typedef Key                                   key_type;
T     typedef T                                     mapped_type;
T     typedef pair<const Key,T>                     value_type;
T     typedef Compare                               key_compare;
T     typedef Allocator                             allocator_type;
T     typedef typename Allocator::reference         reference;
T     typedef typename Allocator::const_reference   const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type
T     typedef typename Allocator::pointer           pointer;
T     typedef typename Allocator::const_pointer     const_pointer;
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
T     class value_compare
        : public binary_function<value_type,value_type,bool> {
      friend class multimap;
      protected:
T       Compare comp;
T       value_compare(Compare c) : comp(c) {}
      public:
T       bool operator()(const value_type& x, const value_type& y) const {
          return comp(x.first, y.first);
        }
      };
      // construct/copy/destroy:
T     explicit multimap(const Compare& comp = Compare(),
                        const Allocator& = Allocator());
T     template <class InputIterator>
        multimap(InputIterator first, InputIterator last,
                 const Compare& comp = Compare(),
                 const Allocator& = Allocator());
T     multimap(const multimap<Key,T,Compare,Allocator>& x);
T    ~multimap();
T     multimap<Key,T,Compare,Allocator>&
        operator=(const multimap<Key,T,Compare,Allocator>& x);
T     allocator_type get_allocator() const;

      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // capacity:
T     bool           empty() const;
T     size_type      size() const;
T     size_type      max_size() const;
      // modifiers:
T     iterator insert(const value_type& x);
T     iterator insert(iterator position, const value_type& x);
T     template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
T     void      erase(iterator position);
T     size_type erase(const key_type& x);
T     void      erase(iterator first, iterator last);
T     void swap(multimap<Key,T,Compare,Allocator>&);
T     void clear();
      // observers:
T     key_compare    key_comp() const;
T     value_compare  value_comp() const;
      // map operations:
T     iterator       find(const key_type& x);
T     const_iterator find(const key_type& x) const;
T     size_type      count(const key_type& x) const;
T     iterator       lower_bound(const key_type& x);
T     const_iterator lower_bound(const key_type& x) const;
T     iterator       upper_bound(const key_type& x);
T     const_iterator upper_bound(const key_type& x) const;
T     pair<iterator,iterator>             equal_range(const key_type& x);
T     pair<const_iterator,const_iterator> equal_range(const key_type& x) const;
    };

T   template <class Key, class T, class Compare, class Allocator>
      bool operator==(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator< (const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator!=(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator> (const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator>=(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
T   template <class Key, class T, class Compare, class Allocator>
      bool operator<=(const multimap<Key,T,Compare,Allocator>& x,
                      const multimap<Key,T,Compare,Allocator>& y);
    // specialized algorithms:
T   template <class Key, class T, class Compare, class Allocator>
      void swap(multimap<Key,T,Compare,Allocator>& x,
                multimap<Key,T,Compare,Allocator>& y);


   23.3.3  Template class set                                   [lib.set]

    template <class Key, class Compare = less<Key>,
              class Allocator = allocator<Key> >
T   class set {
    public:
      // types:
T     typedef Key                                   key_type;
T     typedef Key                                   value_type;
T     typedef Compare                               key_compare;
T     typedef Compare                               value_compare;
T     typedef Allocator                             allocator_type;
T     typedef typename Allocator::reference         reference;
T     typedef typename Allocator::const_reference   const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type;
T     typedef typename Allocator::pointer           pointer;
T     typedef typename Allocator::const_pointer     const_pointer;
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      // _lib.set.cons_ construct/copy/destroy:
T     explicit set(const Compare& comp = Compare(),
                   const Allocator& = Allocator());
T     template <class InputIterator>
        set(InputIterator first, InputIterator last,
            const Compare& comp = Compare(), const Allocator& = Allocator());
T     set(const set<Key,Compare,Allocator>& x);
T    ~set();
T     set<Key,Compare,Allocator>&
        operator=(const set<Key,Compare,Allocator>& x);
T     allocator_type get_allocator() const;
      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // capacity:
T     bool          empty() const;
T     size_type     size() const;
T     size_type     max_size() const;
      // modifiers:
T     pair<iterator,bool> insert(const value_type& x);
T     iterator            insert(iterator position, const value_type& x);
T     template <class InputIterator>
T         void insert(InputIterator first, InputIterator last);
T     void      erase(iterator position);
T     size_type erase(const key_type& x);
T     void      erase(iterator first, iterator last);
T     void swap(set<Key,Compare,Allocator>&);
T     void clear();

      // observers:
T     key_compare   key_comp() const;
T     value_compare value_comp() const;
      // set operations:
T     iterator  find(const key_type& x) const;
T     size_type count(const key_type& x) const;
T     iterator  lower_bound(const key_type& x) const;
T     iterator  upper_bound(const key_type& x) const;
T     pair<iterator,iterator> equal_range(const key_type& x) const;
    };
T   template <class Key, class Compare, class Allocator>
      bool operator==(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator< (const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator!=(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator> (const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator>=(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator<=(const set<Key,Compare,Allocator>& x,
                      const set<Key,Compare,Allocator>& y);
    // specialized algorithms:
T   template <class Key, class Compare, class Allocator>
      void swap(set<Key,Compare,Allocator>& x,
                set<Key,Compare,Allocator>& y);

   23.3.4  Template class multiset                         [lib.multiset]

    template <class Key, class Compare = less<Key>,
              class Allocator = allocator<Key> >
T   class multiset {
    public:
      // types:
T     typedef Key                                   key_type;
T     typedef Key                                   value_type;
T     typedef Compare                               key_compare;
T     typedef Compare                               value_compare;
T     typedef Allocator                             allocator_type;
T     typedef typename Allocator::reference         reference;
T     typedef typename Allocator::const_reference   const_reference;
T     typedef implementation defined                iterator;
T     typedef implementation defined                const_iterator;
T     typedef implementation defined                size_type;
T     typedef implementation defined                difference_type
T     typedef typename Allocator::pointer           pointer;
T     typedef typename Allocator::const_pointer     const_pointer;
T     typedef std::reverse_iterator<iterator>       reverse_iterator;
T     typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

      // construct/copy/destroy:
T     explicit multiset(const Compare& comp = Compare(),
                        const Allocator& = Allocator());
T     template <class InputIterator>
        multiset(InputIterator first, InputIterator last,
                 const Compare& comp = Compare(),
                 const Allocator& = Allocator());
T     multiset(const multiset<Key,Compare,Allocator>& x);
T    ~multiset();
T     multiset<Key,Compare,Allocator>&
          operator=(const multiset<Key,Compare,Allocator>& x);
T     allocator_type get_allocator() const;
      // iterators:
T     iterator               begin();
T     const_iterator         begin() const;
T     iterator               end();
T     const_iterator         end() const;
T     reverse_iterator       rbegin();
T     const_reverse_iterator rbegin() const;
T     reverse_iterator       rend();
T     const_reverse_iterator rend() const;
      // capacity:
T     bool          empty() const;
T     size_type     size() const;
T     size_type     max_size() const;
      // modifiers:
T     iterator insert(const value_type& x);
T     iterator insert(iterator position, const value_type& x);
T     template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
T     void      erase(iterator position);
T     size_type erase(const key_type& x);
T     void      erase(iterator first, iterator last);
T     void swap(multiset<Key,Compare,Allocator>&);
T     void clear();
      // observers:
T     key_compare   key_comp() const;
T     value_compare value_comp() const;
      // set operations:
T     iterator  find(const key_type& x) const;
T     size_type count(const key_type& x) const;
T     iterator  lower_bound(const key_type& x) const;
T     iterator  upper_bound(const key_type& x) const;
T     pair<iterator,iterator> equal_range(const key_type& x) const;
    };

T   template <class Key, class Compare, class Allocator>
      bool operator==(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator< (const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator!=(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator> (const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator>=(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
T   template <class Key, class Compare, class Allocator>
      bool operator<=(const multiset<Key,Compare,Allocator>& x,
                      const multiset<Key,Compare,Allocator>& y);
    // specialized algorithms:
T   template <class Key, class Compare, class Allocator>
      void swap(multiset<Key,Compare,Allocator>& x,
                multiset<Key,Compare,Allocator>& y);

   23.3.5  Template class bitset                    [lib.template.bitset]

   Header <bitset> synopsis

T   template <size_t N> class bitset;
    // _lib.bitset.operators_ bitset operations:
T   template <size_t N>
      bitset<N> operator&(const bitset<N>&, const bitset<N>&);
T   template <size_t N>
      bitset<N> operator|(const bitset<N>&, const bitset<N>&);
T   template <size_t N>
      bitset<N> operator^(const bitset<N>&, const bitset<N>&);
T   template <class charT, class traits, size_t N>
      basic_istream<charT, traits>&
      operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
T   template <class charT, class traits, size_t N>
      basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);

T   template<size_t N> class bitset {
    public:
      // bit reference:
T     class reference {
        friend class bitset;
T       reference();
      public:
T      ~reference();
T       reference& operator=(bool x);             // for b[i] = x;
T       reference& operator=(const reference&);   // for b[i] = b[j];
T       bool operator~() const;                   // flips the bit
T       operator bool() const;                    // for x = b[i];
T       reference& flip();                        // for b[i].flip();
      };

      // _lib.bitset.cons_ constructors:
T     bitset();
T     bitset(unsigned long val);
T     template<class charT, class traits, class Allocator>
        explicit bitset(
          const basic_string<charT,traits,Allocator>& str,
          typename basic_string<charT,traits,Allocator>::size_type pos = 0,
          typename basic_string<charT,traits,Allocator>::size_type n =
            basic_string<charT,traits,Allocator>::npos);
      // _lib.bitset.members_ bitset operations:
T     bitset<N>& operator&=(const bitset<N>& rhs);
T     bitset<N>& operator|=(const bitset<N>& rhs);
T     bitset<N>& operator^=(const bitset<N>& rhs);
T     bitset<N>& operator<<=(size_t pos);
T     bitset<N>& operator>>=(size_t pos);
T     bitset<N>& set();
T     bitset<N>& set(size_t pos, int val = true);
T     bitset<N>& reset();
T     bitset<N>& reset(size_t pos);
T     bitset<N>  operator~() const;
T     bitset<N>& flip();
T     bitset<N>& flip(size_t pos);
      // element access:
T     reference operator[](size_t pos);         // for b[i];
T     unsigned long  to_ulong() const;
T     template <class charT, class traits, class Allocator>
        basic_string<charT, traits, Allocator> to_string() const;
T     size_t count() const;
T     size_t size()  const;
T     bool operator==(const bitset<N>& rhs) const;
T     bool operator!=(const bitset<N>& rhs) const;
T     bool test(size_t pos) const;
T     bool any() const;
T     bool none() const;
T     bitset<N> operator<<(size_t pos) const;
T     bitset<N> operator>>(size_t pos) const;
    };




   24.2  Header <iterator> synopsis               [lib.iterator.synopsis]

    // _lib.iterator.primitives_, primitives:
T   template<class Iterator> struct iterator_traits;
T   template<class T> struct iterator_traits<T*>;

X   template<class Category, class T, class Distance = ptrdiff_t,
             class Pointer = T*, class Reference = T&> struct iterator;
T   struct input_iterator_tag {};
T   struct output_iterator_tag {};
T   struct forward_iterator_tag: public input_iterator_tag {};
T   struct bidirectional_iterator_tag: public forward_iterator_tag {};
T   struct random_access_iterator_tag: public bidirectional_iterator_tag {};
    // _lib.iterator.operations_, iterator operations:
T   template <class InputIterator, class Distance>
      void advance(InputIterator& i, Distance n);
T   template <class InputIterator>
      typename iterator_traits<InputIterator>::difference_type
      distance(InputIterator first, InputIterator last);
    // _lib.predef.iterators_, predefined iterators:
X   template <class Iterator> class reverse_iterator;
T   template <class Iterator>
      bool operator==(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator<(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator!=(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator>(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator>=(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator<=(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      typename reverse_iterator<Iterator>::difference_type operator-(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      reverse_iterator<Iterator>
        operator+(
          typename reverse_iterator<Iterator>::difference_type n,
          const reverse_iterator<Iterator>& x);

X   template <class Container> class back_insert_iterator;
T   template <class Container>
      back_insert_iterator<Container> back_inserter(Container& x);
X   template <class Container> class front_insert_iterator;
T   template <class Container>
      front_insert_iterator<Container> front_inserter(Container& x);
X   template <class Container> class insert_iterator;
T   template <class Container, class Iterator>
      insert_iterator<Container> inserter(Container& x, Iterator i);
    // _lib.stream.iterators_, stream iterators:
X   template <class T, class charT = char, class traits = char_traits<charT>,
              class Distance = ptrdiff_t>
      class istream_iterator;
    template <class T, class charT, class traits, class Distance>
X     bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
                      const istream_iterator<T,charT,traits,Distance>& y);
    template <class T, class charT, class traits, class Distance>
X     bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
                      const istream_iterator<T,charT,traits,Distance>& y);
X   template <class T, class charT = char, class traits = char_traits<charT> >
        class ostream_iterator;
X   template<class charT, class traits = char_traits<charT> >
      class istreambuf_iterator;
X   template <class charT, class traits>
      bool operator==(const istreambuf_iterator<charT,traits>& a,
                      const istreambuf_iterator<charT,traits>& b);
X   template <class charT, class traits>
      bool operator!=(const istreambuf_iterator<charT,traits>& a,
                      const istreambuf_iterator<charT,traits>& b);
T   template <class charT, class traits = char_traits<charT> >
      class ostreambuf_iterator;

   24.3  Iterator primitives                    [lib.iterator.primitives]

T   template<class Iterator> struct iterator_traits {
T     typedef typename Iterator::difference_type difference_type;
T     typedef typename Iterator::value_type value_type;
T     typedef typename Iterator::pointer pointer;
T     typedef typename Iterator::reference reference;
T     typedef typename Iterator::iterator_category iterator_category;
    };

T   template<class T> struct iterator_traits<T*> {
T     typedef ptrdiff_t difference_type;
T     typedef T value_type;
T     typedef T* pointer;
T     typedef T& reference;
T     typedef random_access_iterator_tag iterator_category;
    };

T   template<class T> struct iterator_traits<const T*> {
T     typedef ptrdiff_t difference_type;
T     typedef T value_type;
T     typedef const T* pointer;
T     typedef const T& reference;
T     typedef random_access_iterator_tag iterator_category;
    };

   24.3.2  Basic iterator                            [lib.iterator.basic]

    template<class Category, class T, class Distance = ptrdiff_t,
             class Pointer = T*, class Reference = T&>
X     struct iterator {
T         typedef T         value_type;
T         typedef Distance  difference_type;
T         typedef Pointer   pointer;
T         typedef Reference reference;
T         typedef Category  iterator_category;
    };

   24.3.3  Standard iterator tags                 [lib.std.iterator.tags]

T   struct input_iterator_tag {};
T   struct output_iterator_tag {};
T   struct forward_iterator_tag: public input_iterator_tag {};
T   struct bidirectional_iterator_tag: public forward_iterator_tag {};
T   struct random_access_iterator_tag: public bidirectional_iterator_tag {};


   24.4.1  Reverse iterators                      [lib.reverse.iterators]

    template <class Iterator>
X   class reverse_iterator : public
          iterator<typename iterator_traits<Iterator>::iterator_category,
                   typename iterator_traits<Iterator>::value_type,
                   typename iterator_traits<Iterator>::difference_type,
                   typename iterator_traits<Iterator>::pointer,
                   typename iterator_traits<Iterator>::reference> {
    protected:
T     Iterator current;
    public:
T     typedef Iterator
          iterator_type;
T     typedef typename iterator_traits<Iterator>::difference_type
          difference_type;
T     typedef typename iterator_traits<Iterator>::reference
          reference;
T     typedef typename iterator_traits<Iterator>::pointer
          pointer;

T     reverse_iterator();
T     explicit reverse_iterator(Iterator x);
T     template <class U> reverse_iterator(const reverse_iterator<U>& u);
T     Iterator base() const;      // explicit
T     reference operator*() const;
T     pointer   operator->() const;
T     reverse_iterator& operator++();
T     reverse_iterator  operator++(int);
T     reverse_iterator& operator--();
T     reverse_iterator  operator--(int);

T     reverse_iterator  operator+ (difference_type n) const;
T     reverse_iterator& operator+=(difference_type n);
T     reverse_iterator  operator- (difference_type n) const;
T     reverse_iterator& operator-=(difference_type n);
T     reference operator[](difference_type n) const;
    };
T   template <class Iterator>
      bool operator==(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator<(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator!=(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator>(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator>=(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      bool operator<=(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      typename reverse_iterator<Iterator>::difference_type operator-(
        const reverse_iterator<Iterator>& x,
        const reverse_iterator<Iterator>& y);
T   template <class Iterator>
      reverse_iterator<Iterator> operator+(
        typename reverse_iterator<Iterator>::difference_type n,
        const reverse_iterator<Iterator>& x);


   24.4.2.1  Template class                    [lib.back.insert.iterator]
       back_insert_iterator

    template <class Container>
X   class back_insert_iterator :
          public iterator<output_iterator_tag,void,void,void,void> {
    protected:
T     Container* container;
    public:
T     typedef Container container_type;
T     explicit back_insert_iterator(Container& x);
T     back_insert_iterator<Container>&
        operator=(typename Container::const_reference value);

T     back_insert_iterator<Container>& operator*();
T     back_insert_iterator<Container>& operator++();
T     back_insert_iterator<Container>  operator++(int);
    };
T   template <class Container>
      back_insert_iterator<Container> back_inserter(Container& x);



   24.4.2.3  Template class                   [lib.front.insert.iterator]
       front_insert_iterator

    template <class Container>
X   class front_insert_iterator :
          public iterator<output_iterator_tag,void,void,void,void> {
    protected:
T     Container* container;
    public:
T     typedef Container container_type;
T     explicit front_insert_iterator(Container& x);
T     front_insert_iterator<Container>&
        operator=(typename Container::const_reference value);
T     front_insert_iterator<Container>& operator*();
T     front_insert_iterator<Container>& operator++();
T     front_insert_iterator<Container>  operator++(int);
    };
T   template <class Container>
      front_insert_iterator<Container> front_inserter(Container& x);


   24.4.2.5  Template class insert_iterator         [lib.insert.iterator]

    template <class Container>
X   class insert_iterator :
          public iterator<output_iterator_tag,void,void,void,void> {
    protected:
T     Container* container;
T     typename Container::iterator iter;
    public:
T     typedef Container container_type;
T     insert_iterator(Container& x, typename Container::iterator i);
T     insert_iterator<Container>&
        operator=(typename Container::const_reference value);
T     insert_iterator<Container>& operator*();
T     insert_iterator<Container>& operator++();
T     insert_iterator<Container>& operator++(int);
    };
T   template <class Container, class Iterator>
      insert_iterator<Container> inserter(Container& x, Iterator i);

   24.5.1  Template class istream_iterator         [lib.istream.iterator]

    template <class T, class charT = char, class traits = char_traits<charT>,
        class Distance = ptrdiff_t>
X   class istream_iterator:
      public iterator<input_iterator_tag, T, Distance, const T*, const T&> {
    public:
T     typedef charT char_type
T     typedef traits traits_type;
T     typedef basic_istream<charT,traits> istream_type;
T     istream_iterator();
T     istream_iterator(istream_type& s);
T     istream_iterator(const istream_iterator<T,charT,traits,Distance>& x);
T    ~istream_iterator();

T     const T& operator*() const;
T     const T* operator->() const;
T     istream_iterator<T,charT,traits,Distance>& operator++();
T     istream_iterator<T,charT,traits,Distance>  operator++(int);
    };

T   template <class T, class charT, class traits, class Distance>
      bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
                      const istream_iterator<T,charT,traits,Distance>& y);
T   template <class T, class charT, class traits, class Distance>
      bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
                      const istream_iterator<T,charT,traits,Distance>& y);


   24.5.2  Template class ostream_iterator         [lib.ostream.iterator]

    template <class T, class charT = char, class traits = char_traits<charT> >
X   class ostream_iterator:
      public iterator<output_iterator_tag, void, void, void, void> {
    public:
T     typedef charT char_type;
T     typedef traits traits_type;
T     typedef basic_ostream<charT,traits> ostream_type;
T     ostream_iterator(ostream_type& s);
T     ostream_iterator(ostream_type& s, const charT* delimiter);
T     ostream_iterator(const ostream_iterator<T,charT,traits>& x);
T    ~ostream_iterator();
T     ostream_iterator<T,charT,traits>& operator=(const T& value);

T     ostream_iterator<T,charT,traits>& operator*();
T     ostream_iterator<T,charT,traits>& operator++();
T     ostream_iterator<T,charT,traits>& operator++(int);
    };


   24.5.3  Template class                       [lib.istreambuf.iterator]
       istreambuf_iterator

    template<class charT, class traits = char_traits<charT> >
X   class istreambuf_iterator
       : public iterator<input_iterator_tag, charT,
                         typename traits::off_type, charT*, charT&> {
    public:
T     typedef charT                         char_type;
T     typedef traits                        traits_type;
T     typedef typename traits::int_type     int_type;
T     typedef basic_streambuf<charT,traits> streambuf_type;
T     typedef basic_istream<charT,traits>   istream_type;
T     class proxy;                        // exposition only
T     istreambuf_iterator() throw();
T     istreambuf_iterator(istream_type& s) throw();
T     istreambuf_iterator(streambuf_type* s) throw();
T     istreambuf_iterator(const proxy& p) throw();
T     charT operator*() const;
T     istreambuf_iterator<charT,traits>& operator++();
T     proxy operator++(int);
X     bool equal(istreambuf_iterator& b);
    };

T   template <class charT, class traits>
      bool operator==(const istreambuf_iterator<charT,traits>& a,
                      const istreambuf_iterator<charT,traits>& b);

T   template <class charT, class traits>
      bool operator!=(const istreambuf_iterator<charT,traits>& a,
                      const istreambuf_iterator<charT,traits>& b);

   24.5.3.1  Template class              [lib.istreambuf.iterator::proxy]
       istreambuf_iterator::proxy

    template <class charT, class traits = char_traits<charT> >
T     class istreambuf_iterator<charT, traits>::proxy
    {
T     charT keep_;
T     basic_streambuf<charT,traits>* sbuf_;
T     proxy(charT c,
            basic_streambuf<charT,traits>* sbuf);
        : keep_(c), sbuf_(sbuf) {}
    public:
T     charT operator*() { return keep_; }
    };



   24.5.4  Template class                       [lib.ostreambuf.iterator]
       ostreambuf_iterator

    template <class charT, class traits = char_traits<charT> >
T   class ostreambuf_iterator:
      public iterator<output_iterator_tag, void, void, void, void> {
    public:
T     typedef charT                         char_type;
T     typedef traits                        traits_type;
T     typedef basic_streambuf<charT,traits> streambuf_type;
T     typedef basic_ostream<charT,traits>   ostream_type;
    public:
T     ostreambuf_iterator(ostream_type& s) throw();
T     ostreambuf_iterator(streambuf_type* s) throw();
T     ostreambuf_iterator& operator=(charT c);
T     ostreambuf_iterator& operator*();
T     ostreambuf_iterator& operator++();
T     ostreambuf_iterator& operator++(int);
T     bool failed() const throw();
    };


   Header <algorithm> synopsis


    // _lib.alg.nonmodifying_, non-modifying sequence operations:
T   template<class InputIterator, class Function>
      Function for_each(InputIterator first, InputIterator last, Function f);
T   template<class InputIterator, class T>
      InputIterator find(InputIterator first, InputIterator last,
                         const T& value);
T   template<class InputIterator, class Predicate>
      InputIterator find_if(InputIterator first, InputIterator last,
                            Predicate pred);
T   template<class ForwardIterator1, class ForwardIterator2>
      ForwardIterator1
        find_end(ForwardIterator1 first1, ForwardIterator1 last1,
                 ForwardIterator2 first2, ForwardIterator2 last2);
T   template<class ForwardIterator1, class ForwardIterator2,
             class BinaryPredicate>
      ForwardIterator1
        find_end(ForwardIterator1 first1, ForwardIterator1 last1,
                 ForwardIterator2 first2, ForwardIterator2 last2,
                 BinaryPredicate pred);
T   template<class ForwardIterator1, class ForwardIterator2>
      ForwardIterator1
        find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                      ForwardIterator2 first2, ForwardIterator2 last2);
T   template<class ForwardIterator1, class ForwardIterator2,
             class BinaryPredicate>
      ForwardIterator1
        find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,
                 ForwardIterator2 first2, ForwardIterator2 last2,
                 BinaryPredicate pred);
T   template<class ForwardIterator>
      ForwardIterator adjacent_find(ForwardIterator first,
                                    ForwardIterator last);
T   template<class ForwardIterator, class BinaryPredicate>
      ForwardIterator adjacent_find(ForwardIterator first,
          ForwardIterator last, BinaryPredicate pred);
T   template<class InputIterator, class T>
      typename iterator_traits<InputIterator>::difference_type
        count(InputIterator first, InputIterator last, const T& value);
T   template<class InputIterator, class Predicate>
      typename iterator_traits<InputIterator>::difference_type
        count_if(InputIterator first, InputIterator last, Predicate pred);
T   template<class InputIterator1, class InputIterator2>
      pair<InputIterator1, InputIterator2>
        mismatch(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2);
T   template<class InputIterator1, class InputIterator2, class BinaryPredicate>
      pair<InputIterator1, InputIterator2>
        mismatch(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, BinaryPredicate pred);

T   template<class InputIterator1, class InputIterator2>
      bool equal(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2);
T   template<class InputIterator1, class InputIterator2, class BinaryPredicate>
      bool equal(InputIterator1 first1, InputIterator1 last1,
                 InputIterator2 first2, BinaryPredicate pred);
T   template<class ForwardIterator1, class ForwardIterator2>
      ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2);
T   template<class ForwardIterator1, class ForwardIterator2,
             class BinaryPredicate>
      ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2,
                              BinaryPredicate pred);
T   template<class ForwardIterator, class Size, class T>
      ForwardIterator  search_n(ForwardIterator first, ForwardIterator last,
                              Size count, const T& value);
T   template<class ForwardIterator, class Size, class T, class BinaryPredicate>
      ForwardIterator1 search_n(ForwardIterator first, ForwardIterator last,
                              Size count, const T& value,
                              BinaryPredicate pred);
    // _lib.alg.modifying.operations_, modifying sequence operations:
    // _lib.alg.copy_, copy:
T   template<class InputIterator, class OutputIterator>
      OutputIterator copy(InputIterator first, InputIterator last,
                          OutputIterator result);
T   template<class BidirectionalIterator1, class BidirectionalIterator2>
      BidirectionalIterator2
        copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,
                      BidirectionalIterator2 result);
    // _lib.alg.swap_, swap:
T   template<class T> void swap(T& a, T& b);
T   template<class ForwardIterator1, class ForwardIterator2>
      ForwardIterator2 swap_ranges(ForwardIterator1 first1,
          ForwardIterator1 last1, ForwardIterator2 first2);
T   template<class ForwardIterator1, class ForwardIterator2>
      void iter_swap(ForwardIterator1 a, ForwardIterator2 b);
T   template<class InputIterator, class OutputIterator, class UnaryOperation>
      OutputIterator transform(InputIterator first, InputIterator last,
                               OutputIterator result, UnaryOperation op);
T   template<class InputIterator1, class InputIterator2, class OutputIterator,
             class BinaryOperation>
      OutputIterator transform(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, OutputIterator result,
                               BinaryOperation binary_op);

T   template<class ForwardIterator, class T>
      void replace(ForwardIterator first, ForwardIterator last,
                   const T& old_value, const T& new_value);
T   template<class ForwardIterator, class Predicate, class T>
      void replace_if(ForwardIterator first, ForwardIterator last,
                      Predicate pred, const T& new_value);
T   template<class InputIterator, class OutputIterator, class T>
      OutputIterator replace_copy(InputIterator first, InputIterator last,
                                  OutputIterator result,
                                  const T& old_value, const T& new_value);
T   template<class Iterator, class OutputIterator, class Predicate, class T>
      OutputIterator replace_copy_if(Iterator first, Iterator last,
                                     OutputIterator result,
                                     Predicate pred, const T& new_value);
T   template<class ForwardIterator, class T>
      void fill(ForwardIterator first, ForwardIterator last, const T& value);
T   template<class OutputIterator, class Size, class T>
      void fill_n(OutputIterator first, Size n, const T& value);
T   template<class ForwardIterator, class Generator>
      void generate(ForwardIterator first, ForwardIterator last, Generator gen);
T   template<class OutputIterator, class Size, class Generator>
      void generate_n(OutputIterator first, Size n, Generator gen);
T   template<class ForwardIterator, class T>
      ForwardIterator remove(ForwardIterator first, ForwardIterator last,
                             const T& value);
T   template<class ForwardIterator, class Predicate>
      ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                                Predicate pred);
T   template<class InputIterator, class OutputIterator, class T>
      OutputIterator remove_copy(InputIterator first, InputIterator last,
                                 OutputIterator result, const T& value);
T   template<class InputIterator, class OutputIterator, class Predicate>
      OutputIterator remove_copy_if(InputIterator first, InputIterator last,
                                    OutputIterator result, Predicate pred);
T   template<class ForwardIterator>
      ForwardIterator unique(ForwardIterator first, ForwardIterator last);
T   template<class ForwardIterator, class BinaryPredicate>
      ForwardIterator unique(ForwardIterator first, ForwardIterator last,
                             BinaryPredicate pred);
T   template<class InputIterator, class OutputIterator>
      OutputIterator unique_copy(InputIterator first, InputIterator last,
                                 OutputIterator result);
T   template<class InputIterator, class OutputIterator, class BinaryPredicate>
      OutputIterator unique_copy(InputIterator first, InputIterator last,
                                 OutputIterator result, BinaryPredicate pred);
T   template<class BidirectionalIterator>
      void reverse(BidirectionalIterator first, BidirectionalIterator last);
T   template<class BidirectionalIterator, class OutputIterator>
      OutputIterator reverse_copy(BidirectionalIterator first,
                                  BidirectionalIterator last,
                                  OutputIterator result);

T   template<class ForwardIterator>
      void rotate(ForwardIterator first, ForwardIterator middle,
                  ForwardIterator last);
T   template<class ForwardIterator, class OutputIterator>
      OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,
                                 ForwardIterator last, OutputIterator result);
T   template<class RandomAccessIterator>
      void random_shuffle(RandomAccessIterator first,
                          RandomAccessIterator last);
T   template<class RandomAccessIterator, class RandomNumberGenerator>
      void random_shuffle(RandomAccessIterator first,
                          RandomAccessIterator last,
                          RandomNumberGenerator& rand);
    // _lib.alg.partitions_, partitions:
T   template<class BidirectionalIterator, class Predicate>
      BidirectionalIterator partition(BidirectionalIterator first,
                                      BidirectionalIterator last,
                                      Predicate pred);
T   template<class BidirectionalIterator, class Predicate>
      BidirectionalIterator stable_partition(BidirectionalIterator first,
                                             BidirectionalIterator last,
                                             Predicate pred);
    // _lib.alg.sorting_, sorting and related operations:
    // _lib.alg.sort_, sorting:
T   template<class RandomAccessIterator>
      void sort(RandomAccessIterator first, RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void sort(RandomAccessIterator first, RandomAccessIterator last,
                Compare comp);
T   template<class RandomAccessIterator>
      void stable_sort(RandomAccessIterator first, RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void stable_sort(RandomAccessIterator first, RandomAccessIterator last,
                       Compare comp);
T   template<class RandomAccessIterator>
      void partial_sort(RandomAccessIterator first,
                        RandomAccessIterator middle,
                        RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void partial_sort(RandomAccessIterator first,
                        RandomAccessIterator middle,
                        RandomAccessIterator last, Compare comp);
T   template<class InputIterator, class RandomAccessIterator>
      RandomAccessIterator
        partial_sort_copy(InputIterator first, InputIterator last,
                          RandomAccessIterator result_first,
                          RandomAccessIterator result_last);
T   template<class InputIterator, class RandomAccessIterator, class Compare>
      RandomAccessIterator
        partial_sort_copy(InputIterator first, InputIterator last,
                          RandomAccessIterator result_first,
                          RandomAccessIterator result_last,
                          Compare comp);

T   template<class RandomAccessIterator>
      void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                       RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                       RandomAccessIterator last, Compare comp);
    // _lib.alg.binary.search_, binary search:
T   template<class ForwardIterator, class T>
      ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                                  const T& value);
T   template<class ForwardIterator, class T, class Compare>
      ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,
                                  const T& value, Compare comp);
T   template<class ForwardIterator, class T>
      ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                                  const T& value);
T   template<class ForwardIterator, class T, class Compare>
      ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,
                                  const T& value, Compare comp);
T   template<class ForwardIterator, class T>
      pair<ForwardIterator, ForwardIterator>
        equal_range(ForwardIterator first, ForwardIterator last,
                    const T& value);
T   template<class ForwardIterator, class T, class Compare>
      pair<ForwardIterator, ForwardIterator>
        equal_range(ForwardIterator first, ForwardIterator last,
                    const T& value, Compare comp);
T   template<class ForwardIterator, class T>
      bool binary_search(ForwardIterator first, ForwardIterator last,
                         const T& value);
T   template<class ForwardIterator, class T, class Compare>
      bool binary_search(ForwardIterator first, ForwardIterator last,
                         const T& value, Compare comp);
    // _lib.alg.merge_, merge:
T   template<class InputIterator1, class InputIterator2, class OutputIterator>
      OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                           InputIterator2 first2, InputIterator2 last2,
                           OutputIterator result);
T   template<class InputIterator1, class InputIterator2, class OutputIterator,
             class Compare>
      OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
                           InputIterator2 first2, InputIterator2 last2,
                           OutputIterator result, Compare comp);
T   template<class BidirectionalIterator>
      void inplace_merge(BidirectionalIterator first,
                         BidirectionalIterator middle,
                         BidirectionalIterator last);
T   template<class BidirectionalIterator, class Compare>
      void inplace_merge(BidirectionalIterator first,
                         BidirectionalIterator middle,
                         BidirectionalIterator last, Compare comp);

    // _lib.alg.set.operations_, set operations:
T   template<class InputIterator1, class InputIterator2>
      bool includes(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, InputIterator2 last2);
T   template<class InputIterator1, class InputIterator2, class Compare>
      bool includes(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, InputIterator2 last2, Compare comp);
T   template<class InputIterator1, class InputIterator2, class OutputIterator>
      OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result);
T   template<class InputIterator1, class InputIterator2, class OutputIterator,
             class Compare>
      OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,
                               InputIterator2 first2, InputIterator2 last2,
                               OutputIterator result, Compare comp);
T   template<class InputIterator1, class InputIterator2, class OutputIterator>
      OutputIterator set_intersection
          (InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2, InputIterator2 last2,
           OutputIterator result);
T   template<class InputIterator1, class InputIterator2, class OutputIterator,
             class Compare>
      OutputIterator set_intersection
          (InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2, InputIterator2 last2,
           OutputIterator result, Compare comp);
T   template<class InputIterator1, class InputIterator2, class OutputIterator>
      OutputIterator set_difference
          (InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2, InputIterator2 last2,
           OutputIterator result);
T   template<class InputIterator1, class InputIterator2, class OutputIterator,
             class Compare>
      OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,
                                    InputIterator2 first2, InputIterator2 last2,
                                    OutputIterator result, Compare comp);
T   template<class InputIterator1, class InputIterator2, class OutputIterator>
      OutputIterator
        set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, InputIterator2 last2,
                                 OutputIterator result);
T   template<class InputIterator1, class InputIterator2, class OutputIterator,
              class Compare>
      OutputIterator
        set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,
                                 InputIterator2 first2, InputIterator2 last2,
                                 OutputIterator result, Compare comp);
    // _lib.alg.heap.operations_, heap operations:
T   template<class RandomAccessIterator>
      void push_heap(RandomAccessIterator first, RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void push_heap(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);

T   template<class RandomAccessIterator>
      void pop_heap(RandomAccessIterator first, RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void pop_heap(RandomAccessIterator first, RandomAccessIterator last,
                    Compare comp);
T   template<class RandomAccessIterator>
      void make_heap(RandomAccessIterator first, RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void make_heap(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
T   template<class RandomAccessIterator>
      void sort_heap(RandomAccessIterator first, RandomAccessIterator last);
T   template<class RandomAccessIterator, class Compare>
      void sort_heap(RandomAccessIterator first, RandomAccessIterator last,
                     Compare comp);
    // _lib.alg.min.max_, minimum and maximum:
T   template<class T> const T& min(const T& a, const T& b);
T   template<class T, class Compare>
      const T& min(const T& a, const T& b, Compare comp);
T   template<class T> const T& max(const T& a, const T& b);
T   template<class T, class Compare>
      const T& max(const T& a, const T& b, Compare comp);
T   template<class ForwardIterator>
      ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
T   template<class ForwardIterator, class Compare>
      ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                                Compare comp);
T   template<class ForwardIterator>
      ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
T   template<class ForwardIterator, class Compare>
      ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                                Compare comp);
T   template<class InputIterator1, class InputIterator2>
      bool lexicographical_compare
          (InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2, InputIterator2 last2);
T   template<class InputIterator1, class InputIterator2, class Compare>
      bool lexicographical_compare
          (InputIterator1 first1, InputIterator1 last1,
           InputIterator2 first2, InputIterator2 last2,
           Compare comp);

    // _lib.alg.permutation.generators_, permutations
T   template<class BidirectionalIterator>
      bool next_permutation(BidirectionalIterator first,
                            BidirectionalIterator last);
T   template<class BidirectionalIterator, class Compare>
      bool next_permutation(BidirectionalIterator first,
                            BidirectionalIterator last, Compare comp);
T   template<class BidirectionalIterator>
      bool prev_permutation(BidirectionalIterator first,
                            BidirectionalIterator last);
T   template<class BidirectionalIterator, class Compare>
      bool prev_permutation(BidirectionalIterator first,
                            BidirectionalIterator last, Compare comp);


   25.4  C library algorithms                         [lib.alg.c.library]

   1 Header <cstdlib> (partial, Table 2):

                    Table 2--Header <cstdlib> synopsis

                      Functions:   bsearch   qsort


X  extern "C" void *bsearch(const void *key, const void *base,
                          size_t nmemb, size_t size,
                          int (*compar)(const void *, const void *));
X  extern "C++" void *bsearch(const void *key, const void *base,
                          size_t nmemb, size_t size,
                          int (*compar)(const void *, const void *));

X  extern "C" void qsort(void* base, size_t nmemb, size_t size,
                  int (*compar)(const void*, const void*));
X  extern "C++" void qsort(void* base, size_t nmemb, size_t size,
                  int (*compar)(const void*, const void*));



   26.2  Complex numbers                            [lib.complex.numbers]


   26.2.1  Header <complex> synopsis               [lib.complex.synopsis]

T   template<class T> class complex;
T   template<> class complex<float>;
T   template<> class complex<double>;
T   template<> class complex<long double>;
    // _lib.complex.ops_ operators:
T   template<class T>
      complex<T> operator+(const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator+(const complex<T>&, const T&);
T   template<class T> complex<T> operator+(const T&, const complex<T>&);
T   template<class T> complex<T> operator-
      (const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator-(const complex<T>&, const T&);
T   template<class T> complex<T> operator-(const T&, const complex<T>&);
T   template<class T> complex<T> operator*
      (const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator*(const complex<T>&, const T&);
T   template<class T> complex<T> operator*(const T&, const complex<T>&);
T   template<class T> complex<T> operator/
      (const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator/(const complex<T>&, const T&);
T   template<class T> complex<T> operator/(const T&, const complex<T>&);
T   template<class T> complex<T> operator+(const complex<T>&);
T   template<class T> complex<T> operator-(const complex<T>&);
T   template<class T> bool operator==
      (const complex<T>&, const complex<T>&);
T   template<class T> bool operator==(const complex<T>&, const T&);
T   template<class T> bool operator==(const T&, const complex<T>&);
T   template<class T> bool operator!=(const complex<T>&, const complex<T>&);
T   template<class T> bool operator!=(const complex<T>&, const T&);
T   template<class T> bool operator!=(const T&, const complex<T>&);
T   template<class T, class charT, class traits>
      basic_istream<charT, traits>&
      operator>>(basic_istream<charT, traits>&, complex<T>&);

T   template<class T, class charT, class traits>
      basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>&, const complex<T>&);
    // _lib.complex.value.ops_ values:
T   template<class T> T real(const complex<T>&);
T   template<class T> T imag(const complex<T>&);

T   template<class T> T abs(const complex<T>&);
T   template<class T> T arg(const complex<T>&);
T   template<class T> T norm(const complex<T>&);
T   template<class T> complex<T> conj(const complex<T>&);
T   template<class T> complex<T> polar(const T&, const T&);
    // _lib.complex.transcendentals_ transcendentals:
T   template<class T> complex<T> cos  (const complex<T>&);
T   template<class T> complex<T> cosh (const complex<T>&);
T   template<class T> complex<T> exp  (const complex<T>&);
T   template<class T> complex<T> log  (const complex<T>&);
T   template<class T> complex<T> log10(const complex<T>&);
T   template<class T> complex<T> pow(const complex<T>&, int);
T   template<class T> complex<T> pow(const complex<T>&, const T&);
T   template<class T> complex<T> pow(const complex<T>&, const complex<T>&);
T   template<class T> complex<T> pow(const T&, const complex<T>&);
T   template<class T> complex<T> sin  (const complex<T>&);
T   template<class T> complex<T> sinh (const complex<T>&);
T   template<class T> complex<T> sqrt (const complex<T>&);
T   template<class T> complex<T> tan  (const complex<T>&);
T   template<class T> complex<T> tanh (const complex<T>&);
   }

   26.2.2  Template class complex                           [lib.complex]

    template<class T>
T   class complex {
    public:
T     typedef T value_type;

T     complex(const T& re = T(), const T& im = T());
T     complex(const complex&);
T     template<class X> complex(const complex<X>&);

T     T real() const;
T     T imag() const;

T     complex<T>& operator= (const T&);
T     complex<T>& operator+=(const T&);
T     complex<T>& operator-=(const T&);
T     complex<T>& operator*=(const T&);
T     complex<T>& operator/=(const T&);

T     complex& operator=(const complex&);
T     template<class X> complex<T>& operator= (const complex<X>&);
T     template<class X> complex<T>& operator+=(const complex<X>&);
T     template<class X> complex<T>& operator-=(const complex<X>&);
T     template<class X> complex<T>& operator*=(const complex<X>&);
T     template<class X> complex<T>& operator/=(const complex<X>&);
    };

T   template<class T> complex<T> operator+
      (const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator+(const complex<T>&, const T&);
T   template<class T> complex<T> operator+(const T&, const complex<T>&);

T   template<class T> complex<T> operator-
      (const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator-(const complex<T>&, const T&);
T   template<class T> complex<T> operator-(const T&, const complex<T>&);

T   template<class T> complex<T> operator*
      (const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator*(const complex<T>&, const T&);
T   template<class T> complex<T> operator*(const T&, const complex<T>&);

T   template<class T> complex<T> operator/
      (const complex<T>&, const complex<T>&);
T   template<class T> complex<T> operator/(const complex<T>&, const T&);
T   template<class T> complex<T> operator/(const T&, const complex<T>&);

T   template<class T> complex<T> operator+(const complex<T>&);
T   template<class T> complex<T> operator-(const complex<T>&);

T   template<class T> bool operator==(const complex<T>&, const complex<T>&);
T   template<class T> bool operator==(const complex<T>&, const T&);
T   template<class T> bool operator==(const T&, const complex<T>&);

T   template<class T> bool operator!=(const complex<T>&, const complex<T>&);
T   template<class T> bool operator!=(const complex<T>&, const T&);
T   template<class T> bool operator!=(const T&, const complex<T>&);

T   template<class T, class charT, class traits>
      basic_istream<charT, traits>&
      operator>>(basic_istream<charT, traits>&, complex<T>&);

T   template<class T, class charT, class traits>
      basic_ostream<charT, traits>&
      operator<<(basic_ostream<charT, traits>&, const complex<T>&);


   26.2.3  complex specializations                  [lib.complex.special]

T   template<> class complex<float> {
    public:
T     typedef float value_type;

T     complex(float re = 0.0f, float im = 0.0f);
T     explicit complex(const complex<double>&);
T     explicit complex(const complex<long double>&);
T     float real() const;
T     float imag() const;

T     complex<float>& operator= (float);
T     complex<float>& operator+=(float);
T     complex<float>& operator-=(float);
T     complex<float>& operator*=(float);
T     complex<float>& operator/=(float);

T     complex<float>& operator=(const complex<float>&);
T     template<class X> complex<float>& operator= (const complex<X>&);
T     template<class X> complex<float>& operator+=(const complex<X>&);
T     template<class X> complex<float>& operator-=(const complex<X>&);
T     template<class X> complex<float>& operator*=(const complex<X>&);
T     template<class X> complex<float>& operator/=(const complex<X>&);
    };
T   template<> class complex<double> {
    public:
T     typedef double value_type;

T     complex(double re = 0.0, double im = 0.0);
T     complex(const complex<float>&);
T     explicit complex(const complex<long double>&);
T     double real() const;
T     double imag() const;

T     complex<double>& operator= (double);
T     complex<double>& operator+=(double);
T     complex<double>& operator-=(double);
T     complex<double>& operator*=(double);
T     complex<double>& operator/=(double);

T     complex<double>& operator=(const complex<double>&);
T     template<class X> complex<double>& operator= (const complex<X>&);
T     template<class X> complex<double>& operator+=(const complex<X>&);
T     template<class X> complex<double>& operator-=(const complex<X>&);
T     template<class X> complex<double>& operator*=(const complex<X>&);
T     template<class X> complex<double>& operator/=(const complex<X>&);
    };

T   template<> class complex<long double> {
    public:
T     typedef long double value_type;

T     complex(long double re = 0.0L, long double im = 0.0L);
T     complex(const complex<float>&);
T     complex(const complex<double>&);
T     long double real() const;
T     long double imag() const;

T     complex<long double>& operator=(const complex<long double>&);
T     complex<long double>& operator= (long double);
T     complex<long double>& operator+=(long double);
T     complex<long double>& operator-=(long double);
T     complex<long double>& operator*=(long double);
T     complex<long double>& operator/=(long double);

T     template<class X> complex<long double>& operator= (const complex<X>&);
T     template<class X> complex<long double>& operator+=(const complex<X>&);
T     template<class X> complex<long double>& operator-=(const complex<X>&);
T     template<class X> complex<long double>& operator*=(const complex<X>&);
T     template<class X> complex<long double>& operator/=(const complex<X>&);
    };

   26.3  Numeric arrays                                    [lib.numarray]

   26.3.1  Header <valarray> synopsis             [lib.valarray.synopsis]

T   template<class T> class valarray;         // An array of type T
T   class slice;
T   template<class T> class slice_array;
T   class gslice;
T   template<class T> class gslice_array;
T   template<class T> class mask_array;       // a masked array
T   template<class T> class indirect_array;   // an indirected array

T   template<class T> valarray<T> operator*
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator* (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator* (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator/
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator/ (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator/ (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator%
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator% (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator% (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator+
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator+ (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator+ (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator-
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator- (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator- (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator^
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator^ (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator^ (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator&
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator& (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator& (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator|
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator| (const valarray<T>&, const T&);
T   template<class T> valarray<T> operator| (const T&, const valarray<T>&);
T   template<class T> valarray<T> operator<<
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator<<(const valarray<T>&, const T&);
T   template<class T> valarray<T> operator<<(const T&, const valarray<T>&);
T   template<class T> valarray<T> operator>>
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> operator>>(const valarray<T>&, const T&);
T   template<class T> valarray<T> operator>>(const T&, const valarray<T>&);
T   template<class T> valarray<bool> operator&&
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator&&(const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator&&(const T&, const valarray<T>&);
T   template<class T> valarray<bool> operator||
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator||(const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator||(const T&, const valarray<T>&);

T   template<class T>
      valarray<bool> operator==(const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator==(const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator==(const T&, const valarray<T>&);
T   template<class T>
      valarray<bool> operator!=(const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator!=(const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator!=(const T&, const valarray<T>&);
T   template<class T>
      valarray<bool> operator< (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator< (const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator< (const T&, const valarray<T>&);
T   template<class T>
      valarray<bool> operator> (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator> (const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator> (const T&, const valarray<T>&);
T   template<class T>
      valarray<bool> operator<=(const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator<=(const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator<=(const T&, const valarray<T>&);
T   template<class T>
      valarray<bool> operator>=(const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<bool> operator>=(const valarray<T>&, const T&);
T   template<class T> valarray<bool> operator>=(const T&, const valarray<T>&);
T   template<class T> valarray<T> abs  (const valarray<T>&);
T   template<class T> valarray<T> acos (const valarray<T>&);
T   template<class T> valarray<T> asin (const valarray<T>&);
T   template<class T> valarray<T> atan (const valarray<T>&);
T   template<class T> valarray<T> atan2
      (const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> atan2(const valarray<T>&, const T&);
T   template<class T> valarray<T> atan2(const T&, const valarray<T>&);
T   template<class T> valarray<T> cos  (const valarray<T>&);
T   template<class T> valarray<T> cosh (const valarray<T>&);
T   template<class T> valarray<T> exp  (const valarray<T>&);
T   template<class T> valarray<T> log  (const valarray<T>&);
T   template<class T> valarray<T> log10(const valarray<T>&);
T   template<class T> valarray<T> pow(const valarray<T>&, const valarray<T>&);
T   template<class T> valarray<T> pow(const valarray<T>&, const T&);
T   template<class T> valarray<T> pow(const T&, const valarray<T>&);
T   template<class T> valarray<T> sin  (const valarray<T>&);
T   template<class T> valarray<T> sinh (const valarray<T>&);
T   template<class T> valarray<T> sqrt (const valarray<T>&);
T   template<class T> valarray<T> tan  (const valarray<T>&);
T   template<class T> valarray<T> tanh (const valarray<T>&);
   }


   26.3.2  Template class valarray                [lib.template.valarray]

T   template<class T> class valarray {
    public:
T     typedef T value_type;

      // _lib.valarray.cons_ construct/destroy:
T     valarray();
T     explicit valarray(size_t);
T     valarray(const T&, size_t);
T     valarray(const T*, size_t);
T     valarray(const valarray&);
T     valarray(const slice_array<T>&);
T     valarray(const gslice_array<T>&);
T     valarray(const mask_array<T>&);
T     valarray(const indirect_array<T>&);
T    ~valarray();

      // _lib.valarray.assign_ assignment:
T     valarray<T>& operator=(const valarray<T>&);
T     valarray<T>& operator=(const T&);
T     valarray<T>& operator=(const slice_array<T>&);
T     valarray<T>& operator=(const gslice_array<T>&);
T     valarray<T>& operator=(const mask_array<T>&);
T     valarray<T>& operator=(const indirect_array<T>&);
      // _lib.valarray.access_ element access:
T     T                 operator[](size_t) const;
T     T&                operator[](size_t);
      // _lib.valarray.sub_ subset operations:
T     valarray<T>       operator[](slice) const;
T     slice_array<T>    operator[](slice);
T     valarray<T>       operator[](const gslice&) const;
T     gslice_array<T>   operator[](const gslice&);
T     valarray<T>       operator[](const valarray<bool>&) const;
T     mask_array<T>     operator[](const valarray<bool>&);
T     valarray<T>       operator[](const valarray<size_t>&) const;
T     indirect_array<T> operator[](const valarray<size_t>&);
      // _lib.valarray.unary_ unary operators:
T     valarray<T> operator+() const;
T     valarray<T> operator-() const;
T     valarray<T> operator~() const;
T     valarray<T> operator!() const;
      // _lib.valarray.cassign_ computed assignment:
T     valarray<T>& operator*= (const T&);
T     valarray<T>& operator/= (const T&);
T     valarray<T>& operator%= (const T&);
T     valarray<T>& operator+= (const T&);
T     valarray<T>& operator-= (const T&);
T     valarray<T>& operator^= (const T&);
T     valarray<T>& operator&= (const T&);
T     valarray<T>& operator|= (const T&);
T     valarray<T>& operator<<=(const T&);
T     valarray<T>& operator>>=(const T&);
T     valarray<T>& operator*= (const valarray<T>&);
T     valarray<T>& operator/= (const valarray<T>&);
T     valarray<T>& operator%= (const valarray<T>&);
T     valarray<T>& operator+= (const valarray<T>&);
T     valarray<T>& operator-= (const valarray<T>&);
T     valarray<T>& operator^= (const valarray<T>&);
T     valarray<T>& operator|= (const valarray<T>&);
T     valarray<T>& operator&= (const valarray<T>&);
T     valarray<T>& operator<<=(const valarray<T>&);
T     valarray<T>& operator>>=(const valarray<T>&);
      // _lib.valarray.members_ member functions:
T     size_t size() const;
T     T    sum() const;
T     T    min() const;
T     T    max() const;

T     valarray<T> shift (int) const;
T     valarray<T> cshift(int) const;
T     valarray<T> apply(T func(T)) const;
T     valarray<T> apply(T func(const T&)) const;
T     void resize(size_t sz, T c = T());
    };
   }



   26.3.4  Class slice                                  [lib.class.slice]

T   class slice {
    public:
T     slice();
T     slice(size_t, size_t, size_t);

T     size_t start() const;
T     size_t size() const;
T     size_t stride() const;
    };
   }



   26.3.5  Template class slice_array          [lib.template.slice.array]

T   template <class T> class slice_array {
    public:
T     typedef T value_type;

T     void operator=  (const valarray<T>&) const;
T     void operator*= (const valarray<T>&) const;
T     void operator/= (const valarray<T>&) const;
T     void operator%= (const valarray<T>&) const;
T     void operator+= (const valarray<T>&) const;
T     void operator-= (const valarray<T>&) const;
T     void operator^= (const valarray<T>&) const;
T     void operator&= (const valarray<T>&) const;
T     void operator|= (const valarray<T>&) const;
T     void operator<<=(const valarray<T>&) const;
T     void operator>>=(const valarray<T>&) const;
T     void operator=(const T&);
T    ~slice_array();
    private:
T     slice_array();
T     slice_array(const slice_array&);
T     slice_array& operator=(const slice_array&);
    };
   }



   26.3.6  The gslice class                            [lib.class.gslice]

T   class gslice {
    public:
T     gslice();
T     gslice(size_t s, const valarray<size_t>& l, const valarray<size_t>& d);

T     size_t           start() const;
T     valarray<size_t> size() const;
T     valarray<size_t> stride() const;
    };


   26.3.7  Template class gslice_array        [lib.template.gslice.array]

T   template <class T> class gslice_array {
    public:
T     typedef T value_type;

T     void operator=  (const valarray<T>&) const;
T     void operator*= (const valarray<T>&) const;
T     void operator/= (const valarray<T>&) const;
T     void operator%= (const valarray<T>&) const;
T     void operator+= (const valarray<T>&) const;
T     void operator-= (const valarray<T>&) const;
T     void operator^= (const valarray<T>&) const;
T     void operator&= (const valarray<T>&) const;
T     void operator|= (const valarray<T>&) const;
T     void operator<<=(const valarray<T>&) const;
T     void operator>>=(const valarray<T>&) const;
T     void operator=(const T&);
T    ~gslice_array();
    private:
T     gslice_array();
T     gslice_array(const gslice_array&);
T     gslice_array& operator=(const gslice_array&);
    };


   26.3.8  Template class mask_array            [lib.template.mask.array]

T   template <class T> class mask_array {
    public:
T     typedef T value_type;

T     void operator=  (const valarray<T>&) const;
T     void operator*= (const valarray<T>&) const;
T     void operator/= (const valarray<T>&) const;
T     void operator%= (const valarray<T>&) const;
T     void operator+= (const valarray<T>&) const;
T     void operator-= (const valarray<T>&) const;
T     void operator^= (const valarray<T>&) const;
T     void operator&= (const valarray<T>&) const;
T     void operator|= (const valarray<T>&) const;
T     void operator<<=(const valarray<T>&) const;
T     void operator>>=(const valarray<T>&) const;
T     void operator=(const T&);
T    ~mask_array();
    private:
T     mask_array();
T     mask_array(const mask_array&);
T     mask_array& operator=(const mask_array&);
      //  remainder implementation defined
    };


   26.3.9  Template class                   [lib.template.indirect.array]
       indirect_array

T   template <class T> class indirect_array {
    public:
T     typedef T value_type;

T     void operator=  (const valarray<T>&) const;
T     void operator*= (const valarray<T>&) const;
T     void operator/= (const valarray<T>&) const;
T     void operator%= (const valarray<T>&) const;
T     void operator+= (const valarray<T>&) const;
T     void operator-= (const valarray<T>&) const;
T     void operator^= (const valarray<T>&) const;
T     void operator&= (const valarray<T>&) const;
T     void operator|= (const valarray<T>&) const;
T     void operator<<=(const valarray<T>&) const;
T     void operator>>=(const valarray<T>&) const;
T     void operator=(const T&);
T    ~indirect_array();
    private:
T     indirect_array();
T     indirect_array(const indirect_array&);
T     indirect_array& operator=(const indirect_array&);
      //  remainder implementation defined
    };

   26.4  Generalized numeric operations                 [lib.numeric.ops]

   Header <numeric> synopsis

T   template <class InputIterator, class T>
      T accumulate(InputIterator first, InputIterator last, T init);

T   template <class InputIterator, class T, class BinaryOperation>
      T accumulate(InputIterator first, InputIterator last, T init,
                   BinaryOperation binary_op);

T   template <class InputIterator1, class InputIterator2, class T>
      T inner_product(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, T init);

T   template <class InputIterator1, class InputIterator2, class T,
              class BinaryOperation1, class BinaryOperation2>
      T inner_product(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, T init,
                      BinaryOperation1 binary_op1,
                      BinaryOperation2 binary_op2);

T   template <class InputIterator, class OutputIterator>
      OutputIterator partial_sum(InputIterator first,
                                 InputIterator last,
                                 OutputIterator result);

T   template <class InputIterator, class OutputIterator,
              class BinaryOperation>
      OutputIterator partial_sum(InputIterator first,
                                 InputIterator last,
                                 OutputIterator result,
                                 BinaryOperation binary_op);

T   template <class InputIterator, class OutputIterator>
      OutputIterator adjacent_difference(InputIterator first,
                                         InputIterator last,
                                         OutputIterator result);

T   template <class InputIterator, class OutputIterator,
              class BinaryOperation>
      OutputIterator adjacent_difference(InputIterator first,
                                         InputIterator last,
                                         OutputIterator result,
                                         BinaryOperation binary_op);


   26.5  C Library                                           [lib.c.math]

                     Table 2--Header <cmath> synopsis
X               Macro:   HUGE_VAL
                Functions:
X               acos     cos        fmod    modf   tan
X               asin     cosh       frexp   pow    tanh
X               atan     exp        ldexp   sin
X               atan2    fabs       log     sinh
X               ceil     floor      log10   sqrt

                    Table 3--Header <cstdlib> synopsis
X                     Macros:   RAND_MAX
X                     Types:    div_t      ldiv_t
                      Functions:
X                     abs       labs       srand
X                     div       ldiv       rand

X  long   abs(long);               // labs()
X  ldiv_t div(long, long);         // ldiv()

X  float abs  (float);
X  float acos (float);
X  float asin (float);
X  float atan (float);
X  float atan2(float, float);
X  float ceil (float);
X  float cos  (float);
X  float cosh (float);
X  float exp  (float);
X  float fabs (float);
X  float floor(float);
X  float fmod (float, float);
X  float frexp(float, int*);
X  float ldexp(float, int);
X  float log  (float);
X  float log10(float);
X  float modf (float, float*);
X  float pow  (float, float);
X  float pow  (float, int);
X  float sin  (float);
X  float sinh (float);
X  float sqrt (float);
X  float tan  (float);
X  float tanh (float);

X  double abs(double);            // fabs()
X  double pow(double, int);

X  long double abs  (long double);
X  long double acos (long double);
X  long double asin (long double);
X  long double atan (long double);
X  long double atan2(long double, long double);
X  long double ceil (long double);
X  long double cos  (long double);
X  long double cosh (long double);
X  long double exp  (long double);
X  long double fabs (long double);
X  long double floor(long double);
X  long double fmod (long double, long double);
X  long double frexp(long double, int*);
X  long double ldexp(long double, int);
X  long double log  (long double);
X  long double log10(long double);
X  long double modf (long double, long double*);
X  long double pow  (long double, long double);
X  long double pow  (long double, int);
X  long double sin  (long double);
X  long double sinh (long double);
X  long double sqrt (long double);
X  long double tan  (long double);
X  long double tanh (long double);

   Header <iosfwd> synopsis

X   template<class charT> class char_traits;
X   template<> class char_traits<char>;
X   template<> class char_traits<wchar_t>;
X   template<class T> class allocator;
X   template <class charT, class traits = char_traits<charT> >
      class basic_ios;

X   template <class charT, class traits = char_traits<charT> >
      class basic_streambuf;

X   template <class charT, class traits = char_traits<charT> >
      class basic_istream;

X   template <class charT, class traits = char_traits<charT> >
      class basic_ostream;

X   template <class charT, class traits = char_traits<charT> >
      class basic_iostream;

X   template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
      class basic_stringbuf;

X   template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
      class basic_istringstream;

X   template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
      class basic_ostringstream;

X   template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
      class basic_stringstream;

X   template <class charT, class traits = char_traits<charT> >
      class basic_filebuf;

X   template <class charT, class traits = char_traits<charT> >
      class basic_ifstream;

X   template <class charT, class traits = char_traits<charT> >
      class basic_ofstream;

X   template <class charT, class traits = char_traits<charT> >
      class basic_fstream;
X   template <class charT, class traits = char_traits<charT> >
      class istreambuf_iterator;

X   template <class charT, class traits = char_traits<charT> >
      class ostreambuf_iterator;
X   typedef basic_ios<char>       ios;
X   typedef basic_ios<wchar_t>    wios;
X   typedef basic_streambuf<char> streambuf;
X   typedef basic_istream<char>   istream;
X   typedef basic_ostream<char>   ostream;
X   typedef basic_iostream<char>  iostream;
X   typedef basic_stringbuf<char>     stringbuf;
X   typedef basic_istringstream<char> istringstream;
X   typedef basic_ostringstream<char> ostringstream;
X   typedef basic_stringstream<char>  stringstream;
X   typedef basic_filebuf<char>  filebuf;
X   typedef basic_ifstream<char> ifstream;
X   typedef basic_ofstream<char> ofstream;
X   typedef basic_fstream<char>  fstream;
X   typedef basic_streambuf<wchar_t> wstreambuf;
X   typedef basic_istream<wchar_t>   wistream;
X   typedef basic_ostream<wchar_t>   wostream;
X   typedef basic_iostream<wchar_t>  wiostream;
X   typedef basic_stringbuf<wchar_t>     wstringbuf;
X   typedef basic_istringstream<wchar_t> wistringstream;
X   typedef basic_ostringstream<wchar_t> wostringstream;
X   typedef basic_stringstream<wchar_t>  wstringstream;

X   typedef basic_filebuf<wchar_t>  wfilebuf;
X   typedef basic_ifstream<wchar_t> wifstream;
X   typedef basic_ofstream<wchar_t> wofstream;
X   typedef basic_fstream<wchar_t>  wfstream;
X   template <class state> class fpos;
X   typedef fpos<char_traits<char>::state_type>    streampos;
X   typedef fpos<char_traits<wchar_t>::state_type> wstreampos;

   27.3  Standard iostream objects                 [lib.iostream.objects]

   Header <iostream> synopsis

T  [must also include <istream> and <ostream>]
T   extern istream cin;
T   extern ostream cout;
T   extern ostream cerr;
T   extern ostream clog;

T   extern wistream wcin;
T   extern wostream wcout;
T   extern wostream wcerr;
T   extern wostream wclog;

   27.4  Iostreams base classes                      [lib.iostreams.base]

   Header <ios> synopsis

   #include <iosfwd>

T   typedef OFF_T  streamoff;
T   typedef SZ_T streamsize;
T   template <class stateT> class fpos;

    class ios_base;
    template <class charT, class traits = char_traits<charT> >
      class basic_ios;
   // _lib.std.ios.manip_, manipulators:
T   ios_base& boolalpha  (ios_base& str);
T   ios_base& noboolalpha(ios_base& str);
T   ios_base& showbase   (ios_base& str);
T   ios_base& noshowbase (ios_base& str);
T   ios_base& showpoint  (ios_base& str);
T   ios_base& noshowpoint(ios_base& str);
T   ios_base& showpos    (ios_base& str);
T   ios_base& noshowpos  (ios_base& str);
T   ios_base& skipws     (ios_base& str);
T   ios_base& noskipws   (ios_base& str);
T   ios_base& nouppercase(ios_base& str);
T   ios_base& uppercase  (ios_base& str);
M   ios_base& unitbuf    (ios_base& str);
M   ios_base& nounitbuf  (ios_base& str);
   // _lib.adjustfield.manip_ adjustfield:
T   ios_base& internal   (ios_base& str);
T   ios_base& left       (ios_base& str);
T   ios_base& right      (ios_base& str);
   // _lib.basefield.manip_ basefield:
T   ios_base& dec        (ios_base& str);
T   ios_base& hex        (ios_base& str);
T   ios_base& oct        (ios_base& str);

   // _lib.floatfield.manip_ floatfield:
T   ios_base& fixed      (ios_base& str);
T   ios_base& scientific (ios_base& str);


   27.4.2  Class ios_base                                  [lib.ios.base]

T   class ios_base {
    public:
      class failure;
T     typedef T1 fmtflags;
T     static const fmtflags boolalpha;
T     static const fmtflags dec;
T     static const fmtflags fixed;
T     static const fmtflags hex;
T     static const fmtflags internal;
T     static const fmtflags left;
T     static const fmtflags oct;
T     static const fmtflags right;
T     static const fmtflags scientific;
T     static const fmtflags showbase;
T     static const fmtflags showpoint;
T     static const fmtflags showpos;
T     static const fmtflags skipws;
X     static const fmtflags unitbuf;
T     static const fmtflags uppercase;
T     static const fmtflags adjustfield;
T     static const fmtflags basefield;
T     static const fmtflags floatfield;

      typedef T2 iostate;
T     static const iostate badbit;
T     static const iostate eofbit;
T     static const iostate failbit;
T     static const iostate goodbit;
T     typedef T3 openmode;
T     static const openmode app;
T     static const openmode ate;
T     static const openmode binary;
T     static const openmode in;
T     static const openmode out;
T     static const openmode trunc;
T     typedef T4 seekdir;
T     static const seekdir beg;
T     static const seekdir cur;
T     static const seekdir end;
T     class Init;
      // _lib.fmtflags.state_ fmtflags state:
T     fmtflags flags() const;
T     fmtflags flags(fmtflags fmtfl);
T     fmtflags setf(fmtflags fmtfl);
T     fmtflags setf(fmtflags fmtfl, fmtflags mask);
T     void unsetf(fmtflags mask);
T     streamsize precision() const;
T     streamsize precision(streamsize prec);
T     streamsize width() const;
T     streamsize width(streamsize wide);
      // _lib.ios.base.locales_ locales:
T     locale imbue(const locale& loc);
T     locale getloc() const;
      // _lib.ios.base.storage_ storage:
T     static int xalloc();
T     long&  iword(int index);
T     void*& pword(int index);
      // destructor
T     virtual ~ios_base();
      // _lib.ios.base.callback_ callbacks;
T     enum event { erase_event, imbue_event, copyfmt_event };
T     typedef void (*event_callback)(event, ios_base&, int index);
T     void register_callback(event_call_back fn, int index);
T     static bool sync_with_stdio(bool sync = true);
    protected:
T     ios_base();
    };

   27.4.2.1.1  Class ios_base::failure                 [lib.ios::failure]

T   class ios_base::failure : public exception {
    public:
T     explicit failure(const string& msg);
T     virtual ~failure();
T     virtual const char* what() const throw();
    };


   27.4.2.1.6  Class ios_base::Init                       [lib.ios::Init]

T   class ios_base::Init {
    public:
T     Init();
T    ~Init();
    };


   27.4.3  Template class fpos                                 [lib.fpos]

X   template <class stateT> class fpos {
    public:
      // _lib.fpos.members_ Members
T     stateT state() const;
T     void state(stateT);
    private;
T     stateT st; // exposition only
    };


   27.4.5  Template class basic_ios                             [lib.ios]

    template <class charT, class traits = char_traits<charT> >
X   class basic_ios : public ios_base {
    public:

      // Types:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
T     operator void*() const
T     bool operator!() const
T     iostate rdstate() const;
T     void clear(iostate state = goodbit);
T     void setstate(iostate state);
T     bool good() const;
T     bool eof()  const;
T     bool fail() const;
T     bool bad()  const;
T     iostate exceptions() const;
T     void exceptions(iostate except);
      // _lib.basic.ios.cons_ Constructor/destructor:
T     explicit basic_ios(basic_streambuf<charT,traits>* sb);
T     virtual ~basic_ios();
      // _lib.basic.ios.members_ Members:
T     basic_ostream<charT,traits>* tie() const;
T     basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);
T     basic_streambuf<charT,traits>* rdbuf() const;
T     basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);
X     basic_ios& copyfmt(const basic_ios& rhs);
T     char_type fill() const;
T     char_type fill(char_type ch);
      // _lib.ios.base.locales_ locales:
T     locale imbue(const locale& loc);
X     char     narrow(char_type c, char dfault) const;
X     char_type widen(char c) const;
    protected:
      basic_ios();
T     void init(basic_streambuf<charT,traits>* sb);
   private:
T     basic_ios(const basic_ios& );       // not defined
T     basic_ios& operator=(const basic_ios&);     // not defined
    };


   27.5  Stream buffers                              [lib.stream.buffers]

   Header <streambuf> synopsis

X   template <class charT, class traits = char_traits<charT> >
      class basic_streambuf;
T   typedef basic_streambuf<char>     streambuf;
T   typedef basic_streambuf<wchar_t> wstreambuf;

   27.5.2  Template class                                 [lib.streambuf]
       basic_streambuf<charT,traits>

    template <class charT, class traits = char_traits<charT> >
X   class basic_streambuf {
    public:

      // Types:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
T     virtual ~basic_streambuf();
      // _lib.streambuf.locales_ locales:
T     locale   pubimbue(const locale &loc);
T     locale   getloc() const;
      // _lib.streambuf.buffer_ buffer and positioning:
T     basic_streambuf<char_type,traits>*
               pubsetbuf(char_type* s, streamsize n);
T     pos_type pubseekoff(off_type off, ios_base::seekdir way,
                          ios_base::openmode which =
                              ios_base::in | ios_base::out);
T     pos_type pubseekpos(pos_type sp,
                          ios_base::openmode which =
                              ios_base::in | ios_base::out);
T     int      pubsync();

      // Get and put areas:
      // _lib.streambuf.pub.get_ Get area:
T     streamsize in_avail();
T     int_type snextc();
T     int_type sbumpc();
T     int_type sgetc();
T     streamsize sgetn(char_type* s, streamsize n);
      // _lib.streambuf.pub.pback_ Putback:
X     int_type sputbackc(char_type c);
X     int_type sungetc();
      // _lib.streambuf.pub.put_ Put area:
T     int_type   sputc(char_type c);
X     streamsize sputn(const char_type* s, streamsize n);
    protected:
T     basic_streambuf();
      // _lib.streambuf.get.area_ Get area:
T     char_type* eback() const;
T     char_type* gptr()  const;
T     char_type* egptr() const;
T     void       gbump(int n);
T     void       setg(char_type* gbeg, char_type* gnext, char_type* gend);
      // _lib.streambuf.put.area_ Put area:
T     char_type* pbase() const;
T     char_type* pptr() const;
T     char_type* epptr() const;
T     void       pbump(int n);
T     void       setp(char_type* pbeg, char_type* pend);
      // _lib.streambuf.virtuals_ virtual functions:
      // _lib.streambuf.virt.locales_ Locales:
T     virtual void imbue(const locale &loc);
      // _lib.streambuf.virt.buffer_ Buffer management and positioning:
T     virtual basic_streambuf<char_type,traits>*
                       setbuf(char_type* s, streamsize n);
T     virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                ios_base::openmode which = ios_base::in | ios_base::out);
T     virtual pos_type seekpos(pos_type sp,
                ios_base::openmode which = ios_base::in | ios_base::out);
T     virtual int      sync();
      // _lib.streambuf.virt.get_ Get area:
T     virtual int        showmanyc();
T     virtual streamsize xsgetn(char_type* s, streamsize n);
T     virtual int_type   underflow();
T     virtual int_type   uflow();
      // _lib.streambuf.virt.pback_ Putback:
T     virtual int_type   pbackfail(int_type c = traits::eof());
      // _lib.streambuf.virt.put_ Put area:
X     virtual streamsize xsputn(const char_type* s, streamsize n);
T     virtual int_type   overflow (int_type c = traits::eof());
    };

   27.6  Formatting and manipulators                [lib.iostream.format]

   Header <istream> synopsis

T   template <class charT, class traits = char_traits<charT> >
      class basic_istream;
T   typedef basic_istream<char>     istream;
T   typedef basic_istream<wchar_t> wistream;

T   template <class charT, class traits = char_traits<charT> >
      class basic_iostream;
T   typedef basic_iostream<char>    iostream;
T   typedef basic_iostream<wchar_t> wiostream;

X   template <class charT, class traits>
      basic_istream<charT,traits>& ws(basic_istream<charT,traits>& is);

   Header <ostream> synopsis

X   template <class charT, class traits = char_traits<charT> >
      class basic_ostream;
T   typedef basic_ostream<char>     ostream;
T   typedef basic_ostream<wchar_t> wostream;

T   template <class charT, class traits>
      basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);
T   template <class charT, class traits>
      basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);
T   template <class charT, class traits>
      basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);

   Header <iomanip> synopsis

      // Types T1, T2, ... are unspecified implementation types
T     T1 resetiosflags(ios_base::fmtflags mask);
T     T2 setiosflags  (ios_base::fmtflags mask);
T     T3 setbase(int base);
T     template<charT> T4 setfill(charT c);
T     T5 setprecision(int n);
T     T6 setw(int n);


   27.6.1.1  Template class basic_istream                   [lib.istream]

    template <class charT, class traits = char_traits<charT> >
T   class basic_istream : virtual public basic_ios<charT,traits> {
    public:
    // Types (inherited from basic_ios (_lib.ios_)):
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // _lib.istream.cons_ Constructor/destructor:
T     explicit basic_istream(basic_streambuf<charT,traits>* sb);
T     virtual ~basic_istream();
      // _lib.istream::sentry_ Prefix/suffix:
T     class sentry;

      // _lib.istream.formatted_ Formatted input:
T     basic_istream<charT,traits>& operator>>
          (basic_istream<charT,traits>& (*pf)(basic_istream<charT,traits>&))
T     basic_istream<charT,traits>& operator>>
          (basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&))
T     basic_istream<charT,traits>& operator>>
          (ios_base& (*pf)(ios_base&))
S     basic_istream<charT,traits>& operator>>(bool& n);
S     basic_istream<charT,traits>& operator>>(short& n);
S     basic_istream<charT,traits>& operator>>(unsigned short& n);
S     basic_istream<charT,traits>& operator>>(int& n);
S     basic_istream<charT,traits>& operator>>(unsigned int& n);
S     basic_istream<charT,traits>& operator>>(long& n);
S     basic_istream<charT,traits>& operator>>(unsigned long& n);
S     basic_istream<charT,traits>& operator>>(float& f);
S     basic_istream<charT,traits>& operator>>(double& f);
S     basic_istream<charT,traits>& operator>>(long double& f);
S     basic_istream<charT,traits>& operator>>(void*& p);
S     basic_istream<charT,traits>& operator>>
          (basic_streambuf<char_type,traits>* sb);
      // _lib.istream.unformatted_ Unformatted input:
T     streamsize gcount() const;
S     int_type get();
S     basic_istream<charT,traits>& get(char_type& c);
S     basic_istream<charT,traits>& get(char_type* s, streamsize n);
S     basic_istream<charT,traits>& get(char_type* s, streamsize n,
                        char_type delim);
S     basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb);
S     basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb,
                        char_type delim);
S     basic_istream<charT,traits>& getline(char_type* s, streamsize n);
S     basic_istream<charT,traits>& getline(char_type* s, streamsize n,
                        char_type delim);
S     basic_istream<charT,traits>& ignore
          (streamsize n = 1, int_type delim = traits::eof());
S     int_type                     peek();
S     basic_istream<charT,traits>& read    (char_type* s, streamsize n);
S     streamsize                   readsome(char_type* s, streamsize n);
S     basic_istream<charT,traits>& putback(char_type c);
S     basic_istream<charT,traits>& unget();
S     int sync();

S     pos_type tellg();
S     basic_istream<charT,traits>& seekg(pos_type);
S     basic_istream<charT,traits>& seekg(off_type, ios_base::seekdir);
    };

    // _lib.istream::extractors_ character extraction templates:
S   template<class charT, class traits>
      basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&,
                                              charT&);
S   template<class traits>
      basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                             unsigned char&);
S   template<class traits>
      basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                             signed char&);

S   template<class charT, class traits>
      basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&,
                                              charT*);
S   template<class traits>
      basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                             unsigned char*);
S   template<class traits>
      basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                             signed char*);

   27.6.1.1.2  Class basic_istream::sentry          [lib.istream::sentry]


    template <class charT,class traits = char_traits<charT> >
S   class basic_istream<charT,traits>::sentry {
      typedef traits traits_type;
S     bool ok_; // exposition only
     public:
S     explicit sentry(basic_istream<charT,traits>& is, bool noskipws = false);
S     ~sentry();
S     operator bool() const { return ok_; }
     private:
T     sentry(const sentry&); //   not defined
T     sentry& operator=(const sentry&); //   not defined
    };


   27.6.1.5  Template class basic_iostream            [lib.iostreamclass]

    template <class charT, class traits = char_traits<charT> >
T   class basic_iostream :
      public basic_istream<charT,traits>,
      public basic_ostream<charT,traits> {
    public:
      // constructor/destructor
T     explicit basic_iostream(basic_streambuf<charT,traits>* sb);
T     virtual ~basic_iostream();
    };


   27.6.2.1  Template class basic_ostream                   [lib.ostream]

    template <class charT, class traits = char_traits<charT> >
X   class basic_ostream : virtual public basic_ios<charT,traits> {
    public:
    // Types (inherited from basic_ios (_lib.ios_)):
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // _lib.ostream.cons_ Constructor/destructor:
T     explicit basic_ostream(basic_streambuf<char_type,traits>* sb);
T     virtual ~basic_ostream();
      // _lib.ostream::sentry_ Prefix/suffix:
T     class sentry;
      // _lib.ostream.formatted_ Formatted output:
T     basic_ostream<charT,traits>& operator<<
          (basic_ostream<charT,traits>& (*pf)(basic_ostream<charT,traits>&));
T     basic_ostream<charT,traits>& operator<<
          (basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
T     basic_ostream<charT,traits>& operator<<
          (ios_base& (*pf)(ios_base&));
T     basic_ostream<charT,traits>& operator<<(bool n);
T     basic_ostream<charT,traits>& operator<<(short n);
T     basic_ostream<charT,traits>& operator<<(unsigned short n);
T     basic_ostream<charT,traits>& operator<<(int n);
T     basic_ostream<charT,traits>& operator<<(unsigned int n);
T     basic_ostream<charT,traits>& operator<<(long n);
T     basic_ostream<charT,traits>& operator<<(unsigned long n);
S     basic_ostream<charT,traits>& operator<<(float f);
S     basic_ostream<charT,traits>& operator<<(double f);
S     basic_ostream<charT,traits>& operator<<(long double f);
T     basic_ostream<charT,traits>& operator<<(const void* p);
X     basic_ostream<charT,traits>& operator<<
          (basic_streambuf<char_type,traits>* sb);
      // _lib.ostream.unformatted_ Unformatted output:
T     basic_ostream<charT,traits>& put(char_type c);
T     basic_ostream<charT,traits>& write(const char_type* s, streamsize n);
X     basic_ostream<charT,traits>& flush();

      // _lib.ostream.seeks_ seeks:
S     pos_type tellp();
S     basic_ostream<charT,traits>& seekp(pos_type);
S     basic_ostream<charT,traits>& seekp(off_type, ios_base::seekdir);
    };
    // _lib.ostream.inserters.character_ character inserters
X   template<class charT, class traits>
    basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                            charT);
X   template<class charT, class traits>
    basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                            char);
    // specialization
X   template<class traits>
      basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                             char);
    // signed and unsigned
X   template<class traits>
      basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                             signed char);
X   template<class traits>
      basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                             unsigned char)
X   template<class charT, class traits>
      basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                              const charT*);
X   template<class charT, class traits>
      basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                              const char*);
    // partial specializationss
X   template<class traits>
      basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                             const char*);
    //  signed and unsigned
X   template<class traits>
      basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                             const signed char*);
X   template<class traits>
      basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                             const unsigned char*);


   27.6.2.3  Class basic_ostream::sentry            [lib.ostream::sentry]

    template <class charT,class traits = char_traits<charT> >
X   class basic_ostream<charT,traits>::sentry {
      bool ok_; // exposition only
     public:
X     explicit sentry(basic_ostream<charT,traits>& os);
X     ~sentry();
X     operator bool() const { return ok_; }
     private
X     sentry(const sentry&); //   not defined
X     sentry& operator=(const sentry&); //   not defined
    };

   27.7  String-based streams                        [lib.string.streams]

   Header <sstream> synopsis

X   template <class charT, class traits = char_traits<charT>,
                      class Allocator = allocator<charT> >
      class basic_stringbuf;

T   typedef basic_stringbuf<char>     stringbuf;
T   typedef basic_stringbuf<wchar_t> wstringbuf;

    template <class charT, class traits = char_traits<charT>,
                      class Allocator = allocator<charT> >
X     class basic_istringstream;

T   typedef basic_istringstream<char>     istringstream;
T   typedef basic_istringstream<wchar_t> wistringstream;

    template <class charT, class traits = char_traits<charT>,
                      class Allocator = allocator<charT> >
X     class basic_ostringstream;
T   typedef basic_ostringstream<char>     ostringstream;
T   typedef basic_ostringstream<wchar_t> wostringstream;

    template <class charT, class traits = char_traits<charT>,
                      class Allocator = allocator<charT> >
X     class basic_stringstream;
T   typedef basic_stringstream<char>     stringstream;
T   typedef basic_stringstream<wchar_t> wstringstream;

   27.7.1  Template class basic_stringbuf                 [lib.stringbuf]

    template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
X   class basic_stringbuf : public basic_streambuf<charT,traits> {
    public:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // _lib.stringbuf.cons_ Constructors:
S     explicit basic_stringbuf(ios_base::openmode which
                                = ios_base::in | ios_base::out);
S     explicit basic_stringbuf
          (const basic_string<charT,traits,Allocator>& str,
           ios_base::openmode which = ios_base::in | ios_base::out);
      // _lib.stringbuf.members_ Get and set:
S     basic_string<charT,traits,Allocator> str() const;
S     void               str(const basic_string<charT,traits,Allocator>& s);

    protected:
      // _lib.stringbuf.virtuals_ Overridden virtual functions:
S     virtual int_type   underflow();
S     virtual int_type   pbackfail(int_type c = traits::eof());
S     virtual int_type   overflow (int_type c = traits::eof());
S     virtual  basic_streambuf<charT,traits>* setbuf(charT*, streamsize);

S     virtual pos_type   seekoff(off_type off, ios_base::seekdir way,
                                 ios_base::openmode which
                                  = ios_base::in | ios_base::out);
S     virtual pos_type   seekpos(pos_type sp,
                                 ios_base::openmode which
                                  = ios_base::in | ios_base::out);
    };


   27.7.2  Template class basic_istringstream         [lib.istringstream]

    template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
X   class basic_istringstream : public basic_istream<charT,traits> {
    public:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // _lib.istringstream.cons_ Constructors:
S     explicit basic_istringstream(ios_base::openmode which = ios_base::in);
S     explicit basic_istringstream(
                         const basic_string<charT,traits,Allocator>& str,
                         ios_base::openmode which = ios_base::in);

      // _lib.istringstream.members_ Members:
S     basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
S     basic_string<charT,traits,Allocator> str() const;
S     void str(const basic_string<charT,traits,Allocator>& s);
   private:
   //  basic_stringbuf<charT,traits,Allocator> sb;   exposition only
    };

   27.7.3  Class basic_ostringstream                  [lib.ostringstream]

    template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
X   class basic_ostringstream : public basic_ostream<charT,traits> {
    public:

      // Types:
T     typedef charT            char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
      // _lib.ostringstream.cons_ Constructors/destructor:
S     explicit basic_ostringstream(ios_base::openmode which = ios_base::out);
S     explicit basic_ostringstream(
                           const basic_string<charT,traits,Allocator>& str,
                           ios_base::openmode which = ios_base::out);
      // _lib.ostringstream.members_ Members:
S     basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
S     basic_string<charT,traits,Allocator> str() const;
S     void    str(const basic_string<charT,traits,Allocator>& s);
    };


   27.7.4  Template class basic_stringstream           [lib.stringstream]

    template <class charT, class traits = char_traits<charT>,
              class Allocator = allocator<charT> >
X   class basic_stringstream
      : public basic_iostream<charT,traits> {
    public:
      // Types
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
      // constructors/destructors
S     explicit basic_stringstream(
          ios_base::openmode which = ios_base::out|ios_base::in);
S     explicit basic_stringstream(
          const basic_string<charT,traits,Allocator>& str,
          ios_base::openmode which = ios_base::out|ios_base::in);
      // Members:
S     basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
S     basic_string<charT,traits,Allocator> str() const;
S     void str(const basic_string<charT,traits,Allocator>& str);
    };



   27.8.1  File streams                                    [lib.fstreams]


   Header <fstream> synopsis

X   template <class charT, class traits = char_traits<charT> >
      class basic_filebuf;
T   typedef basic_filebuf<char>    filebuf;
T   typedef basic_filebuf<wchar_t> wfilebuf;

X   template <class charT, class traits = char_traits<charT> >
      class basic_ifstream;
T   typedef basic_ifstream<char>    ifstream;
T   typedef basic_ifstream<wchar_t> wifstream;

X   template <class charT, class traits = char_traits<charT> >
      class basic_ofstream;
T   typedef basic_ofstream<char>    ofstream;
T   typedef basic_ofstream<wchar_t> wofstream;

X   template <class charT, class traits = char_traits<charT> >
      class basic_fstream;
T   typedef basic_fstream<char>     fstream;
T   typedef basic_fstream<wchar_t> wfstream;

   27.8.1.1  Template class basic_filebuf                   [lib.filebuf]

    template <class charT, class traits = char_traits<charT> >
X   class basic_filebuf : public basic_streambuf<charT,traits> {
    public:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // _lib.filebuf.cons_ Constructors/destructor:
X     basic_filebuf();
X     virtual ~basic_filebuf();
       // _lib.filebuf.members_ Members:
T     bool is_open() const;
X     basic_filebuf<charT,traits>* open
          (const char* s, ios_base::openmode mode);
X     basic_filebuf<charT,traits>* close();
    protected:
      // _lib.filebuf.virtuals_ Overridden virtual functions:
X     virtual streamsize showmanyc();
X     virtual int_type underflow();
X     virtual int_type uflow();
X     virtual int_type pbackfail(int_type c = traits::eof());
X     virtual int_type overflow (int_type c = traits::eof());
S     virtual basic_streambuf<charT,traits>*
                       setbuf(char_type* s, streamsize n);
S     virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                               ios_base::openmode which
                                 = ios_base::in | ios_base::out);
S     virtual pos_type seekpos(pos_type sp, ios_base::openmode which
                                 = ios_base::in | ios_base::out);
S     virtual int      sync();
S     virtual void     imbue(const locale& loc);
    };



   27.8.1.5  Template class basic_ifstream                 [lib.ifstream]

    template <class charT, class traits = char_traits<charT> >
X   class basic_ifstream : public basic_istream<charT,traits> {
    public:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // _lib.ifstream.cons_ Constructors:
S     basic_ifstream();
S     explicit basic_ifstream(const char* s,
                              ios_base::openmode mode = ios_base::in);
      // _lib.ifstream.members_ Members:
S     basic_filebuf<charT,traits>* rdbuf() const;
S     bool is_open();
S     void open(const char* s, ios_base::openmode mode = ios_base::in);
S     void close();
    };


   27.8.1.8  Template class basic_ofstream                 [lib.ofstream]

    template <class charT, class traits = char_traits<charT> >
X   class basic_ofstream : public basic_ostream<charT,traits> {
    public:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // _lib.ofstream.cons_ Constructors:
X     basic_ofstream();
X     explicit basic_ofstream(const char* s,
                              ios_base::openmode mode
                                = ios_base::out);
      // _lib.ofstream.members_ Members:
X     basic_filebuf<charT,traits>* rdbuf() const;
T     bool is_open();
X     void open(const char* s, ios_base::openmode mode = ios_base::out);
X     void close();
    };


   27.8.1.11  Template class basic_fstream                  [lib.fstream]

    template <class charT, class traits=char_traits<charT> >
X   class basic_fstream
      : public basic_iostream<charT,traits> {
    public:
T     typedef charT                     char_type;
T     typedef typename traits::int_type int_type;
T     typedef typename traits::pos_type pos_type;
T     typedef typename traits::off_type off_type;
T     typedef traits                    traits_type;
      // constructors/destructor
S     basic_fstream();
S     explicit basic_fstream(
          const char* s,
          ios_base::openmode mode = ios_base::in|ios_base::out);

      // Members:
S     basic_filebuf<charT,traits>* rdbuf() const;
S     bool is_open();
S     void open(
          const char* s,
          ios_base::openmode mode = ios_base::in|ios_base::out);
S     void close();
    };



   27.8.2  C Library files                                  [lib.c.files]


                    Table 13--Header <cstdio> synopsis
    Macros:
X   BUFSIZ         L_tmpnam        SEEK_SET   TMP_MAX
X   EOF            NULL <cstdio>   stderr     _IOFBF
X   FILENAME_MAX   SEEK_CUR        stdin      _IOLBF
X   FOPEN_MAX      SEEK_END        stdout     _IONBF

X   Types:         FILE            fpos_t     size_t <cstdio>
    Functions:
X   clearerr       fgets           fscanf     gets     rewind
X   fclose         fopen           fseek      perror   scanf     tmpnam
X   feof           fprintf         fsetpos    printf   setbuf    ungetc
X   ferror         fputc           ftell      putc     setvbuf   vprintf
X   fflush         fputs           fwrite     puts     sprintf   vfprintf
X   fgetc          fread           getc       remove   sscanf    vsprintf
X   fgetpos        freopen         getchar    putchar  rename    tmpfile




   1.5  Standard C library headers                       [depr.c.headers]

X     <assert.h>   <iso646.h>   <setjmp.h>   <stdio.h>    <wchar.h>
      <ctype.h>    <limits.h>   <signal.h>   <stdlib.h>   <wctype.h>
      <errno.h>    <locale.h>   <stdarg.h>   <string.h>
      <float.h>    <math.h>     <stddef.h>   <time.h>

   1.6  Old iostreams members                          [depr.ios.members]

   [Note: these should be #ifdef'd to permit diagnostics if used.]
   namespace std {
    class ios_base {
    public:
T     typedef T1  io_state;
T     typedef T2 open_mode;
T     typedef T3  seek_dir;
T     typedef OFF_T  streamoff;
T     typedef OFF_T  streampos;
      // remainder unchanged
    };
   }

   [Note: these should be #ifdef'd to permit diagnostics if used.]
   namespace std {
    template<class charT, class traits = char_traits<charT> >
    class basic_streambuf {
    public:
T     void stossc();
      // remainder unchanged
    };
   }

   8 An implementation may provide  the  following  member  functions  that
   overload signatures specified in clause _lib.iostreams_:

   [Note: the following overloads should be #ifdef'd to permit
    diagnostics to be emitted, by default, if used.]

    template<class charT, class Traits> class basic_ios {
    public:
M     void clear(io_state state);
M     void setstate(io_state state);
      // remainder unchanged
    };
    class ios_base {
    public:
M     void exceptions(io_state);
      // remainder unchanged
    };
    template<class charT, class traits = char_traits<charT> >
    class basic_streambuf {
    public:
M     pos_type pubseekoff(off_type off, ios_base::seek_dir way,
                ios_base::open_mode which = ios_base::in | ios_base::out);
M     pos_type pubseekpos(pos_type sp,
                ios_base::open_mode which = ios_base::in | ios_base::out);
      // remainder unchanged
    };
    template <class charT, class traits = char_traits<charT> >
    class basic_filebuf : public basic_streambuf<charT,traits> {
    public:
M     basic_filebuf<charT,traits>* open
          (const char* s, ios_base::open_mode mode);
      // remainder unchanged
    };
    template <class charT, class traits = char_traits<charT> >
    class basic_ifstream : public basic_istream<charT,traits> {
    public:
M     void open(const char* s, ios_base::open_mode mode = in);
      // remainder unchanged
    };
    template <class charT, class traits = char_traits<charT> >
    class basic_ofstream : public basic_ostream<charT,traits> {
    public:
M     void open(const char* s, ios_base::open_mode mode = out | trunc);
      // remainder unchanged
    };
   }



   1.7.1  Class strstreambuf                          [depr.strstreambuf]

   [Note: It should be possible to adopt these components with only
    minor changes from the 2.8 version of the library.]

M   class strstreambuf : public basic_streambuf<char> {
    public:
M     explicit strstreambuf(streamsize alsize_arg = 0);
M     strstreambuf(void* (*palloc_arg)(size_t), void (*pfree_arg)(void*));
M     strstreambuf(char* gnext_arg, streamsize n, char* pbeg_arg = 0);
M     strstreambuf(const char* gnext_arg, streamsize n);
M     strstreambuf(signed char* gnext_arg, streamsize n,
                   signed char* pbeg_arg = 0);
M     strstreambuf(const signed char* gnext_arg, streamsize n);
M     strstreambuf(unsigned char* gnext_arg, streamsize n,
                   unsigned char* pbeg_arg = 0);
M     strstreambuf(const unsigned char* gnext_arg, streamsize n);
M     virtual ~strstreambuf();
M     void  freeze(bool freezefl = true);
M     char* str();
M     int   pcount();
    protected:
M     virtual int_type overflow (int_type c = EOF);
M     virtual int_type pbackfail(int_type c = EOF);
M     virtual int_type underflow();
M     virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                               ios_base::openmode which
                                = ios_base::in | ios_base::out);
M     virtual pos_type seekpos(pos_type sp, ios_base::openmode which
                                = ios_base::in | ios_base::out);
M     virtual streambuf<char>* setbuf(char* s, streamsize n);
   }

   1.7.4  Class strstream                                [depr.strstream]

M   class strstream
      : public basic_iostream<char> {
    public:
      // Types
M     typedef char                                char_type;
M     typedef typename char_traits<char>::int_type int_type
M     typedef typename char_traits<char>::pos_type pos_type;
M     typedef typename char_traits<char>::off_type off_type;
      // consturctors/destructor
M     strstream();
M     strstream(char* s, int n,
                ios_base::openmode mode = ios_base::in|ios_base::out);
M     virtual ~strstream();
      // Members:
M     strstreambuf* rdbuf() const;
M     void freeze(bool freezefl = true);
M     int pcount() const;
M     char* str();
    };

