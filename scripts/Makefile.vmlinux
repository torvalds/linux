# SPDX-License-Identifier: GPL-2.0-only

PHONY := __default
__default: vmlinux

include include/config/auto.conf
include $(srctree)/scripts/Kbuild.include
include $(srctree)/scripts/Makefile.lib

targets :=

%.o: %.c FORCE
	$(call if_changed_rule,cc_o_c)

%.o: %.S FORCE
	$(call if_changed_rule,as_o_S)

# Built-in dtb
# ---------------------------------------------------------------------------

quiet_cmd_wrap_dtbs = WRAP    $@
      cmd_wrap_dtbs = {							\
	echo '\#include <asm-generic/vmlinux.lds.h>';			\
	echo '.section .dtb.init.rodata,"a"';				\
	while read dtb; do						\
		symbase=__dtb_$$(basename -s .dtb "$${dtb}" | tr - _);	\
		echo '.balign STRUCT_ALIGNMENT';			\
		echo ".global $${symbase}_begin";			\
		echo "$${symbase}_begin:";				\
		echo '.incbin "'$$dtb'" ';				\
		echo ".global $${symbase}_end";				\
		echo "$${symbase}_end:";				\
	done < $<;							\
	} > $@

.builtin-dtbs.S: .builtin-dtbs-list FORCE
	$(call if_changed,wrap_dtbs)

quiet_cmd_gen_dtbs_list = GEN     $@
      cmd_gen_dtbs_list = \
	$(if $(CONFIG_BUILTIN_DTB_NAME), echo "arch/$(SRCARCH)/boot/dts/$(CONFIG_BUILTIN_DTB_NAME).dtb",:) > $@

.builtin-dtbs-list: arch/$(SRCARCH)/boot/dts/dtbs-list FORCE
	$(call if_changed,$(if $(CONFIG_BUILTIN_DTB_ALL),copy,gen_dtbs_list))

targets += .builtin-dtbs-list

ifdef CONFIG_GENERIC_BUILTIN_DTB
targets += .builtin-dtbs.S .builtin-dtbs.o
vmlinux.unstripped: .builtin-dtbs.o
endif

# vmlinux.unstripped
# ---------------------------------------------------------------------------

ifdef CONFIG_ARCH_WANTS_PRE_LINK_VMLINUX
vmlinux.unstripped: arch/$(SRCARCH)/tools/vmlinux.arch.o

arch/$(SRCARCH)/tools/vmlinux.arch.o: vmlinux.o FORCE
	$(Q)$(MAKE) $(build)=arch/$(SRCARCH)/tools $@
endif

ARCH_POSTLINK := $(wildcard $(srctree)/arch/$(SRCARCH)/Makefile.postlink)

# Final link of vmlinux with optional arch pass after final link
cmd_link_vmlinux =							\
	$< "$(LD)" "$(KBUILD_LDFLAGS)" "$(LDFLAGS_vmlinux)" "$@";	\
	$(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)

targets += vmlinux.unstripped .vmlinux.export.o
vmlinux.unstripped: scripts/link-vmlinux.sh vmlinux.o .vmlinux.export.o $(KBUILD_LDS) FORCE
	+$(call if_changed_dep,link_vmlinux)
ifdef CONFIG_DEBUG_INFO_BTF
vmlinux.unstripped: $(RESOLVE_BTFIDS)
endif

ifdef CONFIG_BUILDTIME_TABLE_SORT
vmlinux.unstripped: scripts/sorttable
endif

# vmlinux
# ---------------------------------------------------------------------------

remove-section-y                                   := .modinfo
remove-section-$(CONFIG_ARCH_VMLINUX_NEEDS_RELOCS) += '.rel*' '!.rel*.dyn'
# for compatibility with binutils < 2.32
# https://sourceware.org/git/?p=binutils-gdb.git;a=commit;h=c12d9fa2afe7abcbe407a00e15719e1a1350c2a7
remove-section-$(CONFIG_ARCH_VMLINUX_NEEDS_RELOCS) += '.rel.*'

remove-symbols := -w --strip-unneeded-symbol='__mod_device_table__*'

# To avoid warnings: "empty loadable segment detected at ..." from GNU objcopy,
# it is necessary to remove the PT_LOAD flag from the segment.
quiet_cmd_strip_relocs = OBJCOPY $@
      cmd_strip_relocs = $(OBJCOPY) $(patsubst %,--set-section-flags %=noload,$(remove-section-y)) $< $@; \
                         $(OBJCOPY) $(addprefix --remove-section=,$(remove-section-y)) $(remove-symbols) $@

targets += vmlinux
vmlinux: vmlinux.unstripped FORCE
	$(call if_changed,strip_relocs)

# modules.builtin.modinfo
# ---------------------------------------------------------------------------

# .modinfo in vmlinux.unstripped is aligned to 8 bytes for compatibility with
# tools that expect vmlinux to have sufficiently aligned sections but the
# additional bytes used for padding .modinfo to satisfy this requirement break
# certain versions of kmod with
#
#   depmod: ERROR: kmod_builtin_iter_next: unexpected string without modname prefix
#
# Strip the trailing padding bytes after extracting .modinfo to comply with
# what kmod expects to parse.
quiet_cmd_modules_builtin_modinfo = GEN     $@
      cmd_modules_builtin_modinfo = $(cmd_objcopy); \
                                    sed -i 's/\x00\+$$/\x00/g' $@

OBJCOPYFLAGS_modules.builtin.modinfo := -j .modinfo -O binary

targets += modules.builtin.modinfo
modules.builtin.modinfo: vmlinux.unstripped FORCE
	$(call if_changed,modules_builtin_modinfo)

# modules.builtin
# ---------------------------------------------------------------------------

__default: modules.builtin

# The second line aids cases where multiple modules share the same object.

quiet_cmd_modules_builtin = GEN     $@
      cmd_modules_builtin = \
	tr '\0' '\n' < $< | \
	sed -n 's/^[[:alnum:]:_]*\.file=//p' | \
	tr ' ' '\n' | uniq | sed -e 's:^:kernel/:' -e 's/$$/.ko/' > $@

targets += modules.builtin
modules.builtin: modules.builtin.modinfo FORCE
	$(call if_changed,modules_builtin)

# modules.builtin.ranges
# ---------------------------------------------------------------------------
ifdef CONFIG_BUILTIN_MODULE_RANGES
__default: modules.builtin.ranges

quiet_cmd_modules_builtin_ranges = GEN     $@
      cmd_modules_builtin_ranges = gawk -f $(real-prereqs) > $@

targets += modules.builtin.ranges
modules.builtin.ranges: $(srctree)/scripts/generate_builtin_ranges.awk \
			modules.builtin vmlinux.map vmlinux.o.map FORCE
	$(call if_changed,modules_builtin_ranges)

vmlinux.map: vmlinux.unstripped
	@:

endif

# Add FORCE to the prerequisites of a target to force it to be always rebuilt.
# ---------------------------------------------------------------------------

PHONY += FORCE
FORCE:

# Read all saved command lines and dependencies for the $(targets) we
# may be building above, using $(if_changed{,_dep}). As an
# optimization, we don't need to read them if the target does not
# exist, we will rebuild anyway in that case.

existing-targets := $(wildcard $(sort $(targets)))

-include $(foreach f,$(existing-targets),$(dir $(f)).$(notdir $(f)).cmd)

.PHONY: $(PHONY)
