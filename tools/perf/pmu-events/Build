pmu-events-y	+= pmu-events.o
JSON		=  $(shell find pmu-events/arch -name '*.json' -o -name '*.csv')
JSON_DIRS	=  $(shell find pmu-events/arch -type d)
JDIR_TEST	=  pmu-events/arch/test
JSON_TEST	=  $(shell [ -d $(JDIR_TEST) ] &&			\
			find $(JDIR_TEST) -name '*.json')
JEVENTS_PY	=  pmu-events/jevents.py
METRIC_PY	=  pmu-events/metric.py
METRIC_TEST_PY	=  pmu-events/metric_test.py
EMPTY_PMU_EVENTS_C = pmu-events/empty-pmu-events.c
PMU_EVENTS_C	=  $(OUTPUT)pmu-events/pmu-events.c
METRIC_TEST_LOG	=  $(OUTPUT)pmu-events/metric_test.log
TEST_EMPTY_PMU_EVENTS_C = $(OUTPUT)pmu-events/test-empty-pmu-events.c
EMPTY_PMU_EVENTS_TEST_LOG = $(OUTPUT)pmu-events/empty-pmu-events.log
LEGACY_CACHE_PY	=  pmu-events/make_legacy_cache.py
LEGACY_CACHE_JSON = $(OUTPUT)pmu-events/arch/common/common/legacy-cache.json

ifeq ($(JEVENTS_ARCH),)
JEVENTS_ARCH=$(SRCARCH)
endif
JEVENTS_MODEL ?= all

#
# Locate/process JSON files in pmu-events/arch/
# directory and create tables in pmu-events.c.
#

ifeq ($(NO_JEVENTS),1)
$(PMU_EVENTS_C): $(EMPTY_PMU_EVENTS_C)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)cp $< $@
else
# Functions to extract the model from a extra-metrics.json or extra-metricgroups.json path.
model_name = $(shell echo $(1)|sed -e 's@.\+/\(.*\)/extra-metric.*\.json@\1@')
vendor_name = $(shell echo $(1)|sed -e 's@.\+/\(.*\)/[^/]*/extra-metric.*\.json@\1@')

# Copy checked-in json to OUTPUT for generation if it's an out of source build
ifneq ($(OUTPUT),)
# Remove all output directories when any source directory timestamp changes
# so there are no stale deleted files
JSON_DIRS_ROOT = $(OUTPUT)pmu-events/arch/
$(JSON_DIRS_ROOT): $(JSON_DIRS)
	$(Q)$(call echo-cmd,gen)rm -rf $@
	$(Q)mkdir -p $@

$(OUTPUT)pmu-events/arch/%: pmu-events/arch/% $(JSON_DIRS_ROOT)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)cp $< $@
endif

$(LEGACY_CACHE_JSON): $(LEGACY_CACHE_PY) $(JSON_DIRS_ROOT)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $(LEGACY_CACHE_PY) > $@

GEN_METRIC_DEPS := pmu-events/metric.py pmu-events/common_metrics.py

# Generate AMD Json
ZENS = $(shell ls -d pmu-events/arch/x86/amdzen*)
ZEN_METRICS = $(foreach x,$(ZENS),$(OUTPUT)$(x)/extra-metrics.json)
ZEN_METRICGROUPS = $(foreach x,$(ZENS),$(OUTPUT)$(x)/extra-metricgroups.json)

$(ZEN_METRICS): pmu-events/amd_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< $(call model_name,$@) pmu-events/arch > $@

$(ZEN_METRICGROUPS): pmu-events/amd_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< -metricgroups $(call model_name,$@) pmu-events/arch > $@

# Generate ARM Json
ARMS = $(shell ls -d pmu-events/arch/arm64/arm/*|grep -v cmn)
ARM_METRICS = $(foreach x,$(ARMS),$(OUTPUT)$(x)/extra-metrics.json)
ARM_METRICGROUPS = $(foreach x,$(ARMS),$(OUTPUT)$(x)/extra-metricgroups.json)

$(ARM_METRICS): pmu-events/arm64_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< $(call vendor_name,$@) $(call model_name,$@) pmu-events/arch > $@

$(ARM_METRICGROUPS): pmu-events/arm64_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< -metricgroups $(call vendor_name,$@) $(call model_name,$@) pmu-events/arch > $@

# Generate Intel Json
INTELS = $(shell ls -d pmu-events/arch/x86/*|grep -v amdzen|grep -v mapfile.csv)
INTEL_METRICS = $(foreach x,$(INTELS),$(OUTPUT)$(x)/extra-metrics.json)
INTEL_METRICGROUPS = $(foreach x,$(INTELS),$(OUTPUT)$(x)/extra-metricgroups.json)

$(INTEL_METRICS): pmu-events/intel_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< $(call model_name,$@) pmu-events/arch > $@

$(INTEL_METRICGROUPS): pmu-events/intel_metrics.py $(GEN_METRIC_DEPS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $< -metricgroups $(call model_name,$@) pmu-events/arch > $@

GEN_JSON = $(patsubst %,$(OUTPUT)%,$(JSON)) \
            $(LEGACY_CACHE_JSON) \
            $(JSON_DIRS) \
            $(ZEN_METRICS) $(ZEN_METRICGROUPS) \
            $(ARM_METRICS) $(ARM_METRICGROUPS) \
            $(INTEL_METRICS) $(INTEL_METRICGROUPS)

$(METRIC_TEST_LOG): $(METRIC_TEST_PY) $(METRIC_PY)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,test)$(PYTHON) $< 2> $@ || (cat $@ && false)

$(TEST_EMPTY_PMU_EVENTS_C): $(GEN_JSON) $(JSON_TEST) $(JEVENTS_PY) $(METRIC_PY) $(METRIC_TEST_LOG)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $(JEVENTS_PY) none none $(OUTPUT)pmu-events/arch $@

$(EMPTY_PMU_EVENTS_TEST_LOG): $(EMPTY_PMU_EVENTS_C) $(TEST_EMPTY_PMU_EVENTS_C)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,test)diff -u $^ 2> $@ || (cat $@ && false)

ifdef MYPY
  PMU_EVENTS_PY_TESTS := $(wildcard *.py)
  PMU_EVENTS_MYPY_TEST_LOGS := $(JEVENTS_PY_TESTS:%=%.mypy_log)
else
  PMU_EVENTS_MYPY_TEST_LOGS :=
endif

$(OUTPUT)%.mypy_log: %
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,test)mypy "$<" > $@ || (cat $@ && rm $@ && false)

ifdef PYLINT
  PMU_EVENTS_PY_TESTS := $(wildcard *.py)
  PMU_EVENTS_PYLINT_TEST_LOGS := $(JEVENTS_PY_TESTS:%=%.pylint_log)
else
  PMU_EVENTS_PYLINT_TEST_LOGS :=
endif

$(OUTPUT)%.pylint_log: %
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,test)pylint "$<" > $@ || (cat $@ && rm $@ && false)

$(PMU_EVENTS_C): $(GEN_JSON) $(JSON_TEST) $(JEVENTS_PY) $(METRIC_PY) $(METRIC_TEST_LOG) \
    $(EMPTY_PMU_EVENTS_TEST_LOG) $(PMU_EVENTS_MYPY_TEST_LOGS) $(PMU_EVENTS_PYLINT_TEST_LOGS)
	$(call rule_mkdir)
	$(Q)$(call echo-cmd,gen)$(PYTHON) $(JEVENTS_PY) $(JEVENTS_ARCH) $(JEVENTS_MODEL) $(OUTPUT)pmu-events/arch $@
endif

# pmu-events.c file is generated in the OUTPUT directory so it needs a
# separate rule to depend on it properly
$(OUTPUT)pmu-events/pmu-events.o: $(PMU_EVENTS_C)
	$(call rule_mkdir)
	$(call if_changed_dep,cc_o_c)
