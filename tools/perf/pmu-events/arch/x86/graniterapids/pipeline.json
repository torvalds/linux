[
    {
        "BriefDescription": "Cycles when divide unit is busy executing divide or square root operations.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb0",
        "EventName": "ARITH.DIV_ACTIVE",
        "PublicDescription": "Counts cycles when divide unit is busy executing divide or square root operations. Accounts for integer and floating-point operations.",
        "SampleAfterValue": "1000003",
        "UMask": "0x9"
    },
    {
        "BriefDescription": "This event counts the cycles the integer divider is busy.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb0",
        "EventName": "ARITH.IDIV_ACTIVE",
        "SampleAfterValue": "1000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Number of occurrences where a microcode assist is invoked by hardware.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc1",
        "EventName": "ASSISTS.ANY",
        "PublicDescription": "Counts the number of occurrences where a microcode assist is invoked by hardware. Examples include AD (page Access Dirty), FP and AVX related assists.",
        "SampleAfterValue": "100003",
        "UMask": "0x1b"
    },
    {
        "BriefDescription": "All branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.ALL_BRANCHES",
        "PublicDescription": "Counts all branch instructions retired.",
        "SampleAfterValue": "400009"
    },
    {
        "BriefDescription": "Conditional branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND",
        "PublicDescription": "Counts conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x11"
    },
    {
        "BriefDescription": "Not taken branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_NTAKEN",
        "PublicDescription": "Counts not taken branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Taken conditional branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.COND_TAKEN",
        "PublicDescription": "Counts taken conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Far branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.FAR_BRANCH",
        "PublicDescription": "Counts far branch instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "Indirect near branch instructions retired (excluding returns)",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.INDIRECT",
        "PublicDescription": "Counts near indirect branch instructions retired excluding returns. TSX abort is an indirect branch.",
        "SampleAfterValue": "100003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Direct and indirect near call instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_CALL",
        "PublicDescription": "Counts both direct and indirect near call instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Return instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_RETURN",
        "PublicDescription": "Counts return instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Taken branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.NEAR_TAKEN",
        "PublicDescription": "Counts taken branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "All mispredicted branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.ALL_BRANCHES",
        "PublicDescription": "Counts all the retired branch instructions that were mispredicted by the processor. A branch misprediction occurs when the processor incorrectly predicts the destination of the branch.  When the misprediction is discovered at execution, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path.",
        "SampleAfterValue": "400009"
    },
    {
        "BriefDescription": "All mispredicted branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.ALL_BRANCHES_COST",
        "SampleAfterValue": "400009",
        "UMask": "0x44"
    },
    {
        "BriefDescription": "Mispredicted conditional branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND",
        "PublicDescription": "Counts mispredicted conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x11"
    },
    {
        "BriefDescription": "Mispredicted conditional branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_COST",
        "SampleAfterValue": "400009",
        "UMask": "0x51"
    },
    {
        "BriefDescription": "Mispredicted non-taken conditional branch instructions retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_NTAKEN",
        "PublicDescription": "Counts the number of conditional branch instructions retired that were mispredicted and the branch direction was not taken.",
        "SampleAfterValue": "400009",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Mispredicted non-taken conditional branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_NTAKEN_COST",
        "SampleAfterValue": "400009",
        "UMask": "0x50"
    },
    {
        "BriefDescription": "number of branch instructions retired that were mispredicted and taken.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN",
        "PublicDescription": "Counts taken conditional mispredicted branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Mispredicted taken conditional branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN_COST",
        "SampleAfterValue": "400009",
        "UMask": "0x41"
    },
    {
        "BriefDescription": "Miss-predicted near indirect branch instructions retired (excluding returns)",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT",
        "PublicDescription": "Counts miss-predicted near indirect branch instructions retired excluding returns. TSX abort is an indirect branch.",
        "SampleAfterValue": "100003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Mispredicted indirect CALL retired.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_CALL",
        "PublicDescription": "Counts retired mispredicted indirect (near taken) CALL instructions, including both register and memory indirect.",
        "SampleAfterValue": "400009",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Mispredicted indirect CALL retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_CALL_COST",
        "SampleAfterValue": "400009",
        "UMask": "0x42"
    },
    {
        "BriefDescription": "Mispredicted near indirect branch instructions retired (excluding returns). This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_COST",
        "SampleAfterValue": "100003",
        "UMask": "0xc0"
    },
    {
        "BriefDescription": "Number of near branch instructions retired that were mispredicted and taken.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.NEAR_TAKEN",
        "PublicDescription": "Counts number of near branch instructions retired that were mispredicted and taken.",
        "SampleAfterValue": "400009",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Mispredicted taken near branch instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.NEAR_TAKEN_COST",
        "SampleAfterValue": "400009",
        "UMask": "0x60"
    },
    {
        "BriefDescription": "This event counts the number of mispredicted ret instructions retired. Non PEBS",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.RET",
        "PublicDescription": "This is a non-precise version (that is, does not use PEBS) of the event that counts mispredicted return instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Mispredicted ret instructions retired. This precise event may be used to get the misprediction cost via the Retire_Latency field of PEBS. It fires on the instruction that immediately follows the mispredicted branch.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.RET_COST",
        "SampleAfterValue": "100007",
        "UMask": "0x48"
    },
    {
        "BriefDescription": "Core clocks when the thread is in the C0.1 light-weight slower wakeup time but more power saving optimized state.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.C01",
        "PublicDescription": "Counts core clocks when the thread is in the C0.1 light-weight slower wakeup time but more power saving optimized state.  This state can be entered via the TPAUSE or UMWAIT instructions.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Core clocks when the thread is in the C0.2 light-weight faster wakeup time but less power saving optimized state.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.C02",
        "PublicDescription": "Counts core clocks when the thread is in the C0.2 light-weight faster wakeup time but less power saving optimized state.  This state can be entered via the TPAUSE or UMWAIT instructions.",
        "SampleAfterValue": "2000003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Core clocks when the thread is in the C0.1 or C0.2 or running a PAUSE in C0 ACPI state.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.C0_WAIT",
        "PublicDescription": "Counts core clocks when the thread is in the C0.1 or C0.2 power saving optimized states (TPAUSE or UMWAIT instructions) or running the PAUSE instruction.",
        "SampleAfterValue": "2000003",
        "UMask": "0x70"
    },
    {
        "BriefDescription": "Cycle counts are evenly distributed between active threads in the Core.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.DISTRIBUTED",
        "PublicDescription": "This event distributes cycle counts between active hyperthreads, i.e., those in C0.  A hyperthread becomes inactive when it executes the HLT or MWAIT instructions.  If all other hyperthreads are inactive (or disabled or do not exist), all counts are attributed to this hyperthread. To obtain the full count when the Core is active, sum the counts from each hyperthread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Core crystal clock cycles when this thread is unhalted and the other thread is halted.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.ONE_THREAD_ACTIVE",
        "PublicDescription": "Counts Core crystal clock cycles when current thread is unhalted and the other thread is halted.",
        "SampleAfterValue": "25003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "CPU_CLK_UNHALTED.PAUSE",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.PAUSE",
        "SampleAfterValue": "2000003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "CPU_CLK_UNHALTED.PAUSE_INST",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xec",
        "EventName": "CPU_CLK_UNHALTED.PAUSE_INST",
        "SampleAfterValue": "2000003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "Core crystal clock cycles. Cycle counts are evenly distributed between active threads in the Core.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.REF_DISTRIBUTED",
        "PublicDescription": "This event distributes Core crystal clock cycle counts between active hyperthreads, i.e., those in C0 sleep-state. A hyperthread becomes inactive when it executes the HLT or MWAIT instructions. If one thread is active in a core, all counts are attributed to this hyperthread. To obtain the full count when the Core is active, sum the counts from each hyperthread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Reference cycles when the core is not in halt state.",
        "Counter": "Fixed counter 2",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC",
        "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. It is counted on a dedicated fixed counter, leaving the eight programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
        "SampleAfterValue": "2000003",
        "UMask": "0x3"
    },
    {
        "BriefDescription": "Reference cycles when the core is not in halt state.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC_P",
        "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. It is counted on a dedicated fixed counter, leaving the four (eight when Hyperthreading is disabled) programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Core cycles when the thread is not in halt state",
        "Counter": "Fixed counter 1",
        "EventName": "CPU_CLK_UNHALTED.THREAD",
        "PublicDescription": "Counts the number of core cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. This event is a component in many key event ratios. The core frequency may change from time to time due to transitions associated with Enhanced Intel SpeedStep Technology or TM2. For this reason this event may have a changing ratio with regards to time. When the core frequency is constant, this event can approximate elapsed time while the core was not in the halt state. It is counted on a dedicated fixed counter, leaving the eight programmable counters available for other events.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Thread cycles when thread is not in halt state",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.THREAD_P",
        "PublicDescription": "This is an architectural event that counts the number of thread cycles while the thread is not in a halt state. The thread enters the halt state when it is running the HLT instruction. The core frequency may change from time to time due to power or thermal throttling. For this reason, this event may have a changing ratio with regards to wall clock time.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "Cycles while L1 cache miss demand load is outstanding.",
        "Counter": "0,1,2,3",
        "CounterMask": "8",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_L1D_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Cycles while L2 cache miss demand load is outstanding.",
        "Counter": "0,1,2,3",
        "CounterMask": "1",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_L2_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles while memory subsystem has an outstanding load.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "16",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_MEM_ANY",
        "SampleAfterValue": "1000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Execution stalls while L1 cache miss demand load is outstanding.",
        "Counter": "0,1,2,3",
        "CounterMask": "12",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L1D_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0xc"
    },
    {
        "BriefDescription": "Execution stalls while L2 cache miss demand load is outstanding.",
        "Counter": "0,1,2,3",
        "CounterMask": "5",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L2_MISS",
        "SampleAfterValue": "1000003",
        "UMask": "0x5"
    },
    {
        "BriefDescription": "Total execution stalls.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "4",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_TOTAL",
        "SampleAfterValue": "1000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Cycles total of 1 uop is executed on all ports and Reservation Station was not empty.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.1_PORTS_UTIL",
        "PublicDescription": "Counts cycles during which a total of 1 uop was executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles total of 2 or 3 uops are executed on all ports and Reservation Station (RS) was not empty.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.2_3_PORTS_UTIL",
        "SampleAfterValue": "2000003",
        "UMask": "0xc"
    },
    {
        "BriefDescription": "Cycles total of 2 uops are executed on all ports and Reservation Station was not empty.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.2_PORTS_UTIL",
        "PublicDescription": "Counts cycles during which a total of 2 uops were executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Cycles total of 3 uops are executed on all ports and Reservation Station was not empty.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.3_PORTS_UTIL",
        "PublicDescription": "Cycles total of 3 uops are executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Cycles total of 4 uops are executed on all ports and Reservation Station was not empty.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.4_PORTS_UTIL",
        "PublicDescription": "Cycles total of 4 uops are executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Execution stalls while memory subsystem has an outstanding load.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "5",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.BOUND_ON_LOADS",
        "SampleAfterValue": "2000003",
        "UMask": "0x21"
    },
    {
        "BriefDescription": "Cycles where the Store Buffer was full and no loads caused an execution stall.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "2",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.BOUND_ON_STORES",
        "PublicDescription": "Counts cycles where the Store Buffer was full and no loads caused an execution stall.",
        "SampleAfterValue": "1000003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "Cycles no uop executed while RS was not empty, the SB was not full and there was no outstanding load.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.EXE_BOUND_0_PORTS",
        "PublicDescription": "Number of cycles total of 0 uops executed on all ports, Reservation Station (RS) was not empty, the Store Buffer (SB) was not full and there was no outstanding load.",
        "SampleAfterValue": "1000003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Instruction decoders utilized in a cycle",
        "Counter": "0,1,2,3",
        "EventCode": "0x75",
        "EventName": "INST_DECODED.DECODERS",
        "PublicDescription": "Number of decoders utilized in a cycle when the MITE (legacy decode pipeline) fetches instructions.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Number of instructions retired. Fixed Counter - architectural event",
        "Counter": "Fixed counter 0",
        "EventName": "INST_RETIRED.ANY",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Number of instructions retired. General Counter - architectural event",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.ANY_P",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "INST_RETIRED.MACRO_FUSED",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.MACRO_FUSED",
        "SampleAfterValue": "2000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Retired NOP instructions.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.NOP",
        "PublicDescription": "Counts all retired NOP or ENDBR32/64 or PREFETCHIT0/1 instructions",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Precise instruction retired with PEBS precise-distribution",
        "Counter": "Fixed counter 0",
        "EventName": "INST_RETIRED.PREC_DIST",
        "PublicDescription": "A version of INST_RETIRED that allows for a precise distribution of samples across instructions retired. It utilizes the Precise Distribution of Instructions Retired (PDIR++) feature to fix bias in how retired instructions get sampled. Use on Fixed Counter 0.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Iterations of Repeat string retired instructions.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.REP_ITERATION",
        "PublicDescription": "Number of iterations of Repeat (REP) string retired instructions such as MOVS, CMPS, and SCAS. Each has a byte, word, and doubleword version and string instructions can be repeated using a repetition prefix, REP, that allows their architectural execution to be repeated a number of times as specified by the RCX register. Note the number of iterations is implementation-dependent.",
        "SampleAfterValue": "2000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Clears speculative count",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xad",
        "EventName": "INT_MISC.CLEARS_COUNT",
        "PublicDescription": "Counts the number of speculative clears due to any type of branch misprediction or machine clears",
        "SampleAfterValue": "500009",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts cycles after recovery from a branch misprediction or machine clear till the first uop is issued from the resteered path.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.CLEAR_RESTEER_CYCLES",
        "PublicDescription": "Cycles after recovery from a branch misprediction or machine clear till the first uop is issued from the resteered path.",
        "SampleAfterValue": "500009",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "INT_MISC.MBA_STALLS",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.MBA_STALLS",
        "SampleAfterValue": "1000003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Core cycles the allocator was stalled due to recovery from earlier clear event for this thread",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.RECOVERY_CYCLES",
        "PublicDescription": "Counts core cycles when the Resource allocator was stalled due to recovery from an earlier branch misprediction or machine clear event.",
        "SampleAfterValue": "500009",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Bubble cycles of BAClear (Unknown Branch).",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.UNKNOWN_BRANCH_CYCLES",
        "MSRIndex": "0x3F7",
        "MSRValue": "0x7",
        "SampleAfterValue": "1000003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "TMA slots where uops got dropped",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.UOP_DROPPING",
        "PublicDescription": "Estimated number of Top-down Microarchitecture Analysis slots that got dropped due to non front-end reasons",
        "SampleAfterValue": "1000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.128BIT",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.128BIT",
        "SampleAfterValue": "1000003",
        "UMask": "0x13"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.256BIT",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.256BIT",
        "SampleAfterValue": "1000003",
        "UMask": "0xac"
    },
    {
        "BriefDescription": "integer ADD, SUB, SAD 128-bit vector instructions.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.ADD_128",
        "PublicDescription": "Number of retired integer ADD/SUB (regular or horizontal), SAD 128-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0x3"
    },
    {
        "BriefDescription": "integer ADD, SUB, SAD 256-bit vector instructions.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.ADD_256",
        "PublicDescription": "Number of retired integer ADD/SUB (regular or horizontal), SAD 256-bit vector instructions.",
        "SampleAfterValue": "1000003",
        "UMask": "0xc"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.MUL_256",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.MUL_256",
        "SampleAfterValue": "1000003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.SHUFFLES",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.SHUFFLES",
        "SampleAfterValue": "1000003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.VNNI_128",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.VNNI_128",
        "SampleAfterValue": "1000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "INT_VEC_RETIRED.VNNI_256",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.VNNI_256",
        "SampleAfterValue": "1000003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "False dependencies in MOB due to partial compare on address.",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.ADDRESS_ALIAS",
        "PublicDescription": "Counts the number of times a load got blocked due to false dependencies in MOB due to partial compare on address.",
        "SampleAfterValue": "100003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "The number of times that split load operations are temporarily blocked because all resources for handling the split accesses are in use.",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.NO_SR",
        "PublicDescription": "Counts the number of times that split load operations are temporarily blocked because all resources for handling the split accesses are in use.",
        "SampleAfterValue": "100003",
        "UMask": "0x88"
    },
    {
        "BriefDescription": "Loads blocked due to overlapping with a preceding store that cannot be forwarded.",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_FORWARD",
        "PublicDescription": "Counts the number of times where store forwarding was prevented for a load operation. The most common case is a load blocked due to the address of memory access (partially) overlapping with a preceding uncompleted store. Note: See the table of not supported store forwards in the Optimization Guide.",
        "SampleAfterValue": "100003",
        "UMask": "0x82"
    },
    {
        "BriefDescription": "Counts the number of demand load dispatches that hit L1D fill buffer (FB) allocated for software prefetch.",
        "Counter": "0,1,2,3",
        "EventCode": "0x4c",
        "EventName": "LOAD_HIT_PREFETCH.SWPF",
        "PublicDescription": "Counts all not software-prefetch load dispatches that hit the fill buffer (FB) allocated for the software prefetch. It can also be incremented by some lock instructions. So it should only be used with profiling so that the locks can be excluded by ASM (Assembly File) inspection of the nearby instructions.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles Uops delivered by the LSD, but didn't come from the decoder.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xa8",
        "EventName": "LSD.CYCLES_ACTIVE",
        "PublicDescription": "Counts the cycles when at least one uop is delivered by the LSD (Loop-stream detector).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles optimal number of Uops delivered by the LSD, but did not come from the decoder.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "6",
        "EventCode": "0xa8",
        "EventName": "LSD.CYCLES_OK",
        "PublicDescription": "Counts the cycles when optimal number of uops is delivered by the LSD (Loop-stream detector).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Number of Uops delivered by the LSD.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa8",
        "EventName": "LSD.UOPS",
        "PublicDescription": "Counts the number of uops delivered to the back-end by the LSD(Loop Stream Detector).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Number of machine clears (nukes) of any type.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.COUNT",
        "PublicDescription": "Counts the number of machine clears (nukes) of any type.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Self-modifying code (SMC) detected.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.SMC",
        "PublicDescription": "Counts self-modifying code (SMC) detected, which causes a machine clear.",
        "SampleAfterValue": "100003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "LFENCE instructions retired",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.LFENCE",
        "PublicDescription": "number of LFENCE retired instructions",
        "SampleAfterValue": "400009",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Increments whenever there is an update to the LBR array.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.LBR_INSERTS",
        "PublicDescription": "Increments when an entry is added to the Last Branch Record (LBR) array (or removed from the array in case of RETURNs in call stack mode). The event requires LBR enable via IA32_DEBUGCTL MSR and branch type selection via MSR_LBR_SELECT.",
        "SampleAfterValue": "100003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Cycles stalled due to no store buffers available. (not including draining form sync).",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa2",
        "EventName": "RESOURCE_STALLS.SB",
        "PublicDescription": "Counts allocation stall cycles caused by the store buffer (SB) being full. This counts cycles that the pipeline back-end blocked uop delivery from the front-end.",
        "SampleAfterValue": "100003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Counts cycles where the pipeline is stalled due to serializing operations.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa2",
        "EventName": "RESOURCE_STALLS.SCOREBOARD",
        "SampleAfterValue": "100003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "This event counts a subset of the Topdown Slots event that were not consumed by the back-end pipeline due to lack of back-end resources, as a result of memory subsystem delays, execution units limitations, or other conditions.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BACKEND_BOUND_SLOTS",
        "PublicDescription": "This event counts a subset of the Topdown Slots event that were not consumed by the back-end pipeline due to lack of back-end resources, as a result of memory subsystem delays, execution units limitations, or other conditions. The count is distributed among unhalted logical processors (hyper-threads) who share the same physical core, in processors that support Intel Hyper-Threading Technology. Software can use this event as the numerator for the Backend Bound metric (or top-level category) of the Top-down Microarchitecture Analysis method.",
        "SampleAfterValue": "10000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "TMA slots wasted due to incorrect speculations.",
        "Counter": "0",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BAD_SPEC_SLOTS",
        "PublicDescription": "Number of slots of TMA method that were wasted due to incorrect speculation. It covers all types of control-flow or data-related mis-speculations.",
        "SampleAfterValue": "10000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TMA slots wasted due to incorrect speculation by branch mispredictions",
        "Counter": "0",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BR_MISPREDICT_SLOTS",
        "PublicDescription": "Number of TMA slots that were wasted due to incorrect speculation by (any type of) branch mispredictions. This event estimates number of speculative operations that were issued but not retired as well as the out-of-order engine recovery past a branch misprediction.",
        "SampleAfterValue": "10000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "TOPDOWN.MEMORY_BOUND_SLOTS",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.MEMORY_BOUND_SLOTS",
        "SampleAfterValue": "10000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "TMA slots available for an unhalted logical processor. Fixed counter - architectural event",
        "Counter": "Fixed counter 3",
        "EventName": "TOPDOWN.SLOTS",
        "PublicDescription": "Number of available slots for an unhalted logical processor. The event increments by machine-width of the narrowest pipeline as employed by the Top-down Microarchitecture Analysis method (TMA). The count is distributed among unhalted logical processors (hyper-threads) who share the same physical core. Software can use this event as the denominator for the top-level metrics of the TMA method. This architectural event is counted on a designated fixed counter (Fixed Counter 3).",
        "SampleAfterValue": "10000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TMA slots available for an unhalted logical processor. General counter - architectural event",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.SLOTS_P",
        "PublicDescription": "Counts the number of available slots for an unhalted logical processor. The event increments by machine-width of the narrowest pipeline as employed by the Top-down Microarchitecture Analysis method. The count is distributed among unhalted logical processors (hyper-threads) who share the same physical core.",
        "SampleAfterValue": "10000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Number of non dec-by-all uops decoded by decoder",
        "Counter": "0,1,2,3",
        "EventCode": "0x76",
        "EventName": "UOPS_DECODED.DEC0_UOPS",
        "PublicDescription": "This event counts the number of not dec-by-all uops decoded by decoder 0.",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Uops executed on port 0",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_0",
        "PublicDescription": "Number of uops dispatch to execution  port 0.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Uops executed on port 1",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_1",
        "PublicDescription": "Number of uops dispatch to execution  port 1.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Uops executed on ports 2, 3 and 10",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_2_3_10",
        "PublicDescription": "Number of uops dispatch to execution ports 2, 3 and 10",
        "SampleAfterValue": "2000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Uops executed on ports 4 and 9",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_4_9",
        "PublicDescription": "Number of uops dispatch to execution ports 4 and 9",
        "SampleAfterValue": "2000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Uops executed on ports 5 and 11",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_5_11",
        "PublicDescription": "Number of uops dispatch to execution ports 5 and 11",
        "SampleAfterValue": "2000003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Uops executed on port 6",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_6",
        "PublicDescription": "Number of uops dispatch to execution  port 6.",
        "SampleAfterValue": "2000003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "Uops executed on ports 7 and 8",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_7_8",
        "PublicDescription": "Number of uops dispatch to execution  ports 7 and 8.",
        "SampleAfterValue": "2000003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Number of uops executed on the core.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE",
        "PublicDescription": "Counts the number of uops executed from any thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles at least 1 micro-op is executed from any thread on physical core.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_1",
        "PublicDescription": "Counts cycles when at least 1 micro-op is executed from any thread on physical core.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles at least 2 micro-op is executed from any thread on physical core.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "2",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_2",
        "PublicDescription": "Counts cycles when at least 2 micro-ops are executed from any thread on physical core.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles at least 3 micro-op is executed from any thread on physical core.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "3",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_3",
        "PublicDescription": "Counts cycles when at least 3 micro-ops are executed from any thread on physical core.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles at least 4 micro-op is executed from any thread on physical core.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "4",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_4",
        "PublicDescription": "Counts cycles when at least 4 micro-ops are executed from any thread on physical core.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles where at least 1 uop was executed per-thread",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_1",
        "PublicDescription": "Cycles where at least 1 uop was executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles where at least 2 uops were executed per-thread",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "2",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_2",
        "PublicDescription": "Cycles where at least 2 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles where at least 3 uops were executed per-thread",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "3",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_3",
        "PublicDescription": "Cycles where at least 3 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles where at least 4 uops were executed per-thread",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "4",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_4",
        "PublicDescription": "Cycles where at least 4 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts number of cycles no uops were dispatched to be executed on this thread.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.STALLS",
        "Invert": "1",
        "PublicDescription": "Counts cycles during which no uops were dispatched from the Reservation Station (RS) per thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts the number of uops to be executed per-thread each cycle.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.THREAD",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts the number of x87 uops dispatched.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.X87",
        "PublicDescription": "Counts the number of x87 uops executed.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Uops that RAT issues to RS",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.ANY",
        "PublicDescription": "Counts the number of uops that the Resource Allocation Table (RAT) issues to the Reservation Station (RS).",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "UOPS_ISSUED.CYCLES",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.CYCLES",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles with retired uop(s).",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.CYCLES",
        "PublicDescription": "Counts cycles where at least one uop has retired.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Retired uops except the last uop of each instruction.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.HEAVY",
        "PublicDescription": "Counts the number of retired micro-operations (uops) except the last uop of each instruction. An instruction that is decoded into less than two uops does not contribute to the count.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "UOPS_RETIRED.MS",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.MS",
        "MSRIndex": "0x3F7",
        "MSRValue": "0x8",
        "SampleAfterValue": "2000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "This event counts a subset of the Topdown Slots event that are utilized by operations that eventually get retired (committed) by the processor pipeline. Usually, this event positively correlates with higher performance  for example, as measured by the instructions-per-cycle metric.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.SLOTS",
        "PublicDescription": "This event counts a subset of the Topdown Slots event that are utilized by operations that eventually get retired (committed) by the processor pipeline. Usually, this event positively correlates with higher performance  for example, as measured by the instructions-per-cycle metric. Software can use this event as the numerator for the Retiring metric (or top-level category) of the Top-down Microarchitecture Analysis method.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles without actually retired uops.",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.STALLS",
        "Invert": "1",
        "PublicDescription": "This event counts cycles without actually retired uops.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2"
    }
]
