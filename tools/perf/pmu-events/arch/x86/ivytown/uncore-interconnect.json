[
    {
        "BriefDescription": "Number of qfclks",
        "EventCode": "0x14",
        "EventName": "UNC_Q_CLOCKTICKS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of clocks in the QPI LL.  This clock runs at 1/8th the GT/s speed of the QPI link.  For example, a 8GT/s link will have qfclk or 1GHz.  JKT does not support dynamic link speeds, so this frequency is fixed.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Count of CTO Events",
        "EventCode": "0x38",
        "EventName": "UNC_Q_CTO_COUNT",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of CTO (cluster trigger outs) events that were asserted across the two slots.  If both slots trigger in a given cycle, the event will increment by 2.  You can use edge detect to count the number of cases when both events triggered.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egress Credits",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn failed because there were not enough Egress credits.  Had there been enough credits, the spawn would have worked as the RBT bit was set and the RBT tag matched.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egress and RBT Miss",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_MISS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn failed because the RBT tag did not match and there weren't enough Egress credits.   The valid bit was set.",
        "UMask": "0x20",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egress and RBT Invalid",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn failed because there were not enough Egress credits AND the RBT bit was not set, but the RBT tag matched.",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - Egress and RBT Miss, Invalid",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_CREDITS_RBT_MISS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn failed because the RBT tag did not match, the valid bit was not set and there weren't enough Egress credits.",
        "UMask": "0x80",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT Miss",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_MISS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn failed because the RBT tag did not match although the valid bit was set and there were enough Egress credits.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT Invalid",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_HIT",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn failed because the route-back table (RBT) specified that the transaction should not trigger a direct2core transaction.  This is common for IO transactions.  There were enough Egress credits and the RBT tag matched but the valid bit was not set.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Failure - RBT Miss and Invalid",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.FAILURE_RBT_MISS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn failed because the RBT tag did not match and the valid bit was not set although there were enough Egress credits.",
        "UMask": "0x40",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Direct 2 Core Spawning; Spawn Success",
        "EventCode": "0x13",
        "EventName": "UNC_Q_DIRECT2CORE.SUCCESS_RBT_HIT",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of DRS packets that we attempted to do direct2core on.  There are 4 mutually exclusive filters.  Filter [0] can be used to get successful spawns, while [1:3] provide the different failure cases.  Note that this does not count packets that are not candidates for Direct2Core.  The only candidates for Direct2Core are DRS packets destined for Cbos.; The spawn was successful.  There were sufficient credits, the RBT valid bit was set and there was an RBT tag match.  The message was marked to spawn direct2core.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Cycles in L1",
        "EventCode": "0x12",
        "EventName": "UNC_Q_L1_POWER_CYCLES",
        "PerPkg": "1",
        "PublicDescription": "Number of QPI qfclk cycles spent in L1 power mode.  L1 is a mode that totally shuts down a QPI link.  Use edge detect to count the number of instances when the QPI link entered L1.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another. Because L1 totally shuts down the link, it takes a good amount of time to exit this mode.",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MATCH_MASK",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.AnyDataC",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.AnyResp",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.AnyResp11flits",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.AnyResp9flits",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.DataC_E",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.DataC_E_Cmp",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.DataC_E_FrcAckCnflt",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.DataC_F",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.DataC_F_Cmp",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.DataC_F_FrcAckCnflt",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.DataC_M",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.WbEData",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.WbIData",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.DRS.WbSData",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.AnyReq",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.AnyResp",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.RespFwd",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.RespFwdI",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.RespFwdIWb",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.RespFwdS",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.RespFwdSWb",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.RespIWb",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.HOM.RespSWb",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NCB.AnyInt",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NCB.AnyMsg",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NCB.AnyMsg11flits",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NCB.AnyMsg9flits",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NCS.AnyMsg1or2flits",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NCS.AnyMsg3flits",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NCS.NcRd",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.NDR.AnyCmp",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "EventCode": "0x38",
        "EventName": "UNC_Q_MESSAGE.SNP.AnySnp",
        "PerPkg": "1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Cycles in L0p",
        "EventCode": "0x10",
        "EventName": "UNC_Q_RxL0P_POWER_CYCLES",
        "PerPkg": "1",
        "PublicDescription": "Number of QPI qfclk cycles spent in L0p power mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing our bandwidth in order to save power.  It increases snoop and data transfer latencies and decreases overall bandwidth.  This mode can be very useful in NUMA optimized workloads that largely only utilize QPI for snoops and their responses.  Use edge detect to count the number of instances when the QPI link entered L0p.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Cycles in L0",
        "EventCode": "0xf",
        "EventName": "UNC_Q_RxL0_POWER_CYCLES",
        "PerPkg": "1",
        "PublicDescription": "Number of QPI qfclk cycles spent in L0 power mode in the Link Layer.  L0 is the default mode which provides the highest performance with the most power.  Use edge detect to count the number of instances that the link entered L0.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.  The phy layer  sometimes leaves L0 for training, which will not be captured by this event.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Bypassed",
        "EventCode": "0x9",
        "EventName": "UNC_Q_RxL_BYPASSED",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an incoming flit was able to bypass the flit buffer and pass directly across the BGF and into the Egress.  This is a latency optimization, and should generally be the common case.  If this value is less than the number of flits transferred, it implies that there was queueing getting onto the ring, and thus the transactions saw higher latency.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "CRC Errors Detected; LinkInit",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_CRC_ERRORS.LINK_INIT",
        "PerPkg": "1",
        "PublicDescription": "Number of CRC errors detected in the QPI Agent.  Each QPI flit incorporates 8 bits of CRC for error detection.  This counts the number of flits where the CRC was able to detect an error.  After an error has been detected, the QPI agent will send a request to the transmitting socket to resend the flit (as well as any flits that came after it).; CRC errors detected during link initialization.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "CRC Errors Detected; Normal Operations",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_CRC_ERRORS.NORMAL_OP",
        "PerPkg": "1",
        "PublicDescription": "Number of CRC errors detected in the QPI Agent.  Each QPI flit incorporates 8 bits of CRC for error detection.  This counts the number of flits where the CRC was able to detect an error.  After an error has been detected, the QPI agent will send a request to the transmitting socket to resend the flit (as well as any flits that came after it).; CRC errors detected during normal operation.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN0 Credit Consumed; DRS",
        "EventCode": "0x1e",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.DRS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN0 credit for the DRS message class.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN0 Credit Consumed; HOM",
        "EventCode": "0x1e",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.HOM",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN0 credit for the HOM message class.",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN0 Credit Consumed; NCB",
        "EventCode": "0x1e",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCB",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN0 credit for the NCB message class.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN0 Credit Consumed; NCS",
        "EventCode": "0x1e",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NCS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN0 credit for the NCS message class.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN0 Credit Consumed; NDR",
        "EventCode": "0x1e",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.NDR",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN0 credit for the NDR message class.",
        "UMask": "0x20",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN0 Credit Consumed; SNP",
        "EventCode": "0x1e",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN0.SNP",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN0 credit was consumed (i.e. message uses a VN0 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN0 credit for the SNP message class.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN1 Credit Consumed; DRS",
        "EventCode": "0x39",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.DRS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN1 credit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN1 credit for the DRS message class.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN1 Credit Consumed; HOM",
        "EventCode": "0x39",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.HOM",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN1 credit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN1 credit for the HOM message class.",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN1 Credit Consumed; NCB",
        "EventCode": "0x39",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NCB",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN1 credit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN1 credit for the NCB message class.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN1 Credit Consumed; NCS",
        "EventCode": "0x39",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NCS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN1 credit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN1 credit for the NCS message class.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN1 Credit Consumed; NDR",
        "EventCode": "0x39",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.NDR",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN1 credit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN1 credit for the NDR message class.",
        "UMask": "0x20",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VN1 Credit Consumed; SNP",
        "EventCode": "0x39",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VN1.SNP",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VN1 credit was consumed (i.e. message uses a VN1 credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.; VN1 credit for the SNP message class.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VNA Credit Consumed",
        "EventCode": "0x1d",
        "EventName": "UNC_Q_RxL_CREDITS_CONSUMED_VNA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an RxQ VNA credit was consumed (i.e. message uses a VNA credit for the Rx Buffer).  This includes packets that went through the RxQ and those that were bypasssed.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty",
        "EventCode": "0xa",
        "EventName": "UNC_Q_RxL_CYCLES_NE",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN0",
        "EventCode": "0xF",
        "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN0",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors DRS flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - DRS; for VN1",
        "EventCode": "0xF",
        "EventName": "UNC_Q_RxL_CYCLES_NE_DRS.VN1",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors DRS flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN0",
        "EventCode": "0x12",
        "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN0",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors HOM flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - HOM; for VN1",
        "EventCode": "0x12",
        "EventName": "UNC_Q_RxL_CYCLES_NE_HOM.VN1",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors HOM flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN0",
        "EventCode": "0x10",
        "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN0",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors NCB flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - NCB; for VN1",
        "EventCode": "0x10",
        "EventName": "UNC_Q_RxL_CYCLES_NE_NCB.VN1",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors NCB flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN0",
        "EventCode": "0x11",
        "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN0",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors NCS flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - NCS; for VN1",
        "EventCode": "0x11",
        "EventName": "UNC_Q_RxL_CYCLES_NE_NCS.VN1",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors NCS flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN0",
        "EventCode": "0x14",
        "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN0",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors NDR flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - NDR; for VN1",
        "EventCode": "0x14",
        "EventName": "UNC_Q_RxL_CYCLES_NE_NDR.VN1",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors NDR flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN0",
        "EventCode": "0x13",
        "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN0",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors SNP flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Cycles Not Empty - SNP; for VN1",
        "EventCode": "0x13",
        "EventName": "UNC_Q_RxL_CYCLES_NE_SNP.VN1",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles that the QPI RxQ was not empty.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy Accumulator event to calculate the average occupancy.  This monitors SNP flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 0; Data Tx Flits",
        "EventCode": "0x1",
        "EventName": "UNC_Q_RxL_FLITS_G0.DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of data flits received over QPI.  Each flit contains 64b of data.  This includes both DRS and NCB data flits (coherent and non-coherent).  This can be used to calculate the data bandwidth of the QPI link.  One can get a good picture of the QPI-link characteristics by evaluating the protocol flits, data flits, and idle/null flits.  This does not include the header flits that go in data packets.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 0; Idle and Null Flits",
        "EventCode": "0x1",
        "EventName": "UNC_Q_RxL_FLITS_G0.IDLE",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of flits received over QPI that do not hold protocol payload.  When QPI is not in a power saving state, it continuously transmits flits across the link.  When there are no protocol flits to send, it will send IDLE and NULL flits  across.  These flits sometimes do carry a payload, such as credit returns, but are generally not considered part of the QPI bandwidth.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 0; Non-Data protocol Tx Flits",
        "EventCode": "0x1",
        "EventName": "UNC_Q_RxL_FLITS_G0.NON_DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of non-NULL non-data flits received across QPI.  This basically tracks the protocol overhead on the QPI link.  One can get a good picture of the QPI-link characteristics by evaluating the protocol flits, data flits, and idle/null flits.  This includes the header flits for data packets.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 1; DRS Flits (both Header and Data)",
        "EventCode": "0x2",
        "EventName": "UNC_Q_RxL_FLITS_G1.DRS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of flits received over QPI on the DRS (Data Response) channel.  DRS flits are used to transmit data with coherency.  This does not count data flits received over the NCB channel which transmits non-coherent data.",
        "UMask": "0x18",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 1; DRS Data Flits",
        "EventCode": "0x2",
        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of data flits received over QPI on the DRS (Data Response) channel.  DRS flits are used to transmit data with coherency.  This does not count data flits received over the NCB channel which transmits non-coherent data.  This includes only the data flits (not the header).",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 1; DRS Header Flits",
        "EventCode": "0x2",
        "EventName": "UNC_Q_RxL_FLITS_G1.DRS_NONDATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of protocol flits received over QPI on the DRS (Data Response) channel.  DRS flits are used to transmit data with coherency.  This does not count data flits received over the NCB channel which transmits non-coherent data.  This includes only the header flits (not the data).  This includes extended headers.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 1; HOM Flits",
        "EventCode": "0x2",
        "EventName": "UNC_Q_RxL_FLITS_G1.HOM",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of flits received over QPI on the home channel.",
        "UMask": "0x6",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 1; HOM Non-Request Flits",
        "EventCode": "0x2",
        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_NONREQ",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of non-request flits received over QPI on the home channel.  These are most commonly snoop responses, and this event can be used as a proxy for that.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 1; HOM Request Flits",
        "EventCode": "0x2",
        "EventName": "UNC_Q_RxL_FLITS_G1.HOM_REQ",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of data request received over QPI on the home channel.  This basically counts the number of remote memory requests received over QPI.  In conjunction with the local read count in the Home Agent, one can calculate the number of LLC Misses.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 1; SNP Flits",
        "EventCode": "0x2",
        "EventName": "UNC_Q_RxL_FLITS_G1.SNP",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of snoop request flits received over QPI.  These requests are contained in the snoop channel.  This does not include snoop responses, which are received on the home channel.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 2; Non-Coherent Rx Flits",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_FLITS_G2.NCB",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of Non-Coherent Bypass flits.  These packets are generally used to transmit non-coherent data across QPI.",
        "UMask": "0xc",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 2; Non-Coherent data Rx Flits",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_FLITS_G2.NCB_DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of Non-Coherent Bypass data flits.  These flits are generally used to transmit non-coherent data across QPI.  This does not include a count of the DRS (coherent) data flits.  This only counts the data flits, not the NCB headers.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 2; Non-Coherent non-data Rx Flits",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_FLITS_G2.NCB_NONDATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of Non-Coherent Bypass non-data flits.  These packets are generally used to transmit non-coherent data across QPI, and the flits counted here are for headers and other non-data flits.  This includes extended headers.",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 2; Non-Coherent standard Rx Flits",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_FLITS_G2.NCS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of NCS (non-coherent standard) flits received over QPI.    This includes extended headers.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 2; Non-Data Response Rx Flits - AD",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AD",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of flits received over the NDR (Non-Data Response) channel.  This channel is used to send a variety of protocol flits including grants and completions.  This is only for NDR packets to the local socket which use the AK ring.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Received - Group 2; Non-Data Response Rx Flits - AK",
        "EventCode": "0x3",
        "EventName": "UNC_Q_RxL_FLITS_G2.NDR_AK",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits received from the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of flits received over the NDR (Non-Data Response) channel.  This channel is used to send a variety of protocol flits including grants and completions.  This is only for NDR packets destined for Route-thru to a remote socket.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations",
        "EventCode": "0x8",
        "EventName": "UNC_Q_RxL_INSERTS",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - DRS",
        "EventCode": "0x9",
        "EventName": "UNC_Q_RxL_INSERTS_DRS",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only DRS flits.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN0",
        "EventCode": "0x9",
        "EventName": "UNC_Q_RxL_INSERTS_DRS.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only DRS flits.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - DRS; for VN1",
        "EventCode": "0x9",
        "EventName": "UNC_Q_RxL_INSERTS_DRS.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only DRS flits.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - HOM",
        "EventCode": "0xc",
        "EventName": "UNC_Q_RxL_INSERTS_HOM",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only HOM flits.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN0",
        "EventCode": "0xC",
        "EventName": "UNC_Q_RxL_INSERTS_HOM.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only HOM flits.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - HOM; for VN1",
        "EventCode": "0xC",
        "EventName": "UNC_Q_RxL_INSERTS_HOM.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only HOM flits.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NCB",
        "EventCode": "0xa",
        "EventName": "UNC_Q_RxL_INSERTS_NCB",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCB flits.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NCB; for VN0",
        "EventCode": "0xA",
        "EventName": "UNC_Q_RxL_INSERTS_NCB.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCB flits.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NCB; for VN1",
        "EventCode": "0xA",
        "EventName": "UNC_Q_RxL_INSERTS_NCB.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCB flits.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NCS",
        "EventCode": "0xb",
        "EventName": "UNC_Q_RxL_INSERTS_NCS",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCS flits.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NCS; for VN0",
        "EventCode": "0xB",
        "EventName": "UNC_Q_RxL_INSERTS_NCS.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCS flits.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NCS; for VN1",
        "EventCode": "0xB",
        "EventName": "UNC_Q_RxL_INSERTS_NCS.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NCS flits.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NDR",
        "EventCode": "0xe",
        "EventName": "UNC_Q_RxL_INSERTS_NDR",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NDR flits.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NDR; for VN0",
        "EventCode": "0xE",
        "EventName": "UNC_Q_RxL_INSERTS_NDR.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NDR flits.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - NDR; for VN1",
        "EventCode": "0xE",
        "EventName": "UNC_Q_RxL_INSERTS_NDR.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only NDR flits.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - SNP",
        "EventCode": "0xd",
        "EventName": "UNC_Q_RxL_INSERTS_SNP",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only SNP flits.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - SNP; for VN0",
        "EventCode": "0xD",
        "EventName": "UNC_Q_RxL_INSERTS_SNP.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only SNP flits.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Rx Flit Buffer Allocations - SNP; for VN1",
        "EventCode": "0xD",
        "EventName": "UNC_Q_RxL_INSERTS_SNP.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Rx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.  This monitors only SNP flits.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - All Packets",
        "EventCode": "0xb",
        "EventName": "UNC_Q_RxL_OCCUPANCY",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - DRS",
        "EventCode": "0x15",
        "EventName": "UNC_Q_RxL_OCCUPANCY_DRS",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors DRS flits only.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - DRS; for VN0",
        "EventCode": "0x15",
        "EventName": "UNC_Q_RxL_OCCUPANCY_DRS.VN0",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors DRS flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - DRS; for VN1",
        "EventCode": "0x15",
        "EventName": "UNC_Q_RxL_OCCUPANCY_DRS.VN1",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors DRS flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - HOM",
        "EventCode": "0x18",
        "EventName": "UNC_Q_RxL_OCCUPANCY_HOM",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors HOM flits only.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - HOM; for VN0",
        "EventCode": "0x18",
        "EventName": "UNC_Q_RxL_OCCUPANCY_HOM.VN0",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors HOM flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - HOM; for VN1",
        "EventCode": "0x18",
        "EventName": "UNC_Q_RxL_OCCUPANCY_HOM.VN1",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors HOM flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NCB",
        "EventCode": "0x16",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NCB",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCB flits only.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NCB; for VN0",
        "EventCode": "0x16",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NCB.VN0",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCB flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NCB; for VN1",
        "EventCode": "0x16",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NCB.VN1",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCB flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NCS",
        "EventCode": "0x17",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NCS",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCS flits only.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NCS; for VN0",
        "EventCode": "0x17",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NCS.VN0",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCS flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NCS; for VN1",
        "EventCode": "0x17",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NCS.VN1",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NCS flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NDR",
        "EventCode": "0x1a",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NDR",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NDR flits only.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NDR; for VN0",
        "EventCode": "0x1A",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NDR.VN0",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NDR flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - NDR; for VN1",
        "EventCode": "0x1A",
        "EventName": "UNC_Q_RxL_OCCUPANCY_NDR.VN1",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors NDR flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - SNP",
        "EventCode": "0x19",
        "EventName": "UNC_Q_RxL_OCCUPANCY_SNP",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors SNP flits only.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - SNP; for VN0",
        "EventCode": "0x19",
        "EventName": "UNC_Q_RxL_OCCUPANCY_SNP.VN0",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors SNP flits only.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "RxQ Occupancy - SNP; for VN1",
        "EventCode": "0x19",
        "EventName": "UNC_Q_RxL_OCCUPANCY_SNP.VN1",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of elements in the QPI RxQ in each cycle.  Generally, when data is transmitted across QPI, it will bypass the RxQ and pass directly to the ring interface.  If things back up getting transmitted onto the ring, however, it may need to allocate into this buffer, thus increasing the latency.  This event can be used in conjunction with the Flit Buffer Not Empty event to calculate average occupancy, or with the Flit Buffer Allocations event to track average lifetime.  This monitors SNP flits only.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - HOM",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_DRS",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled a packet from the HOM message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - DRS",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_HOM",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled a packet from the DRS message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - SNP",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCB",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled a packet from the SNP message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - NDR",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NCS",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled a packet from the NDR message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - NCS",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_NDR",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled a packet from the NCS message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x20",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; BGF Stall - NCB",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.BGF_SNP",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled a packet from the NCB message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; Egress Credits",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.EGRESS_CREDITS",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled a packet because there were insufficient BGF credits.  For details on a message class granularity, use the Egress Credit Occupancy events.",
        "UMask": "0x40",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN0; GV",
        "EventCode": "0x35",
        "EventName": "UNC_Q_RxL_STALLS_VN0.GV",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 0; Stalled because a GV transition (frequency transition) was taking place.",
        "UMask": "0x80",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - HOM",
        "EventCode": "0x3a",
        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_DRS",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 1.; Stalled a packet from the HOM message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - DRS",
        "EventCode": "0x3a",
        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_HOM",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 1.; Stalled a packet from the DRS message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - SNP",
        "EventCode": "0x3a",
        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCB",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 1.; Stalled a packet from the SNP message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - NDR",
        "EventCode": "0x3a",
        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NCS",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 1.; Stalled a packet from the NDR message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - NCS",
        "EventCode": "0x3a",
        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_NDR",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 1.; Stalled a packet from the NCS message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x20",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Stalls Sending to R3QPI on VN1; BGF Stall - NCB",
        "EventCode": "0x3a",
        "EventName": "UNC_Q_RxL_STALLS_VN1.BGF_SNP",
        "PerPkg": "1",
        "PublicDescription": "Number of stalls trying to send to R3QPI on Virtual Network 1.; Stalled a packet from the NCB message class because there were not enough BGF credits.  In bypass mode, we will stall on the packet boundary, while in RxQ mode we will stall on the flit boundary.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Cycles in L0p",
        "EventCode": "0xd",
        "EventName": "UNC_Q_TxL0P_POWER_CYCLES",
        "PerPkg": "1",
        "PublicDescription": "Number of QPI qfclk cycles spent in L0p power mode.  L0p is a mode where we disable 1/2 of the QPI lanes, decreasing our bandwidth in order to save power.  It increases snoop and data transfer latencies and decreases overall bandwidth.  This mode can be very useful in NUMA optimized workloads that largely only utilize QPI for snoops and their responses.  Use edge detect to count the number of instances when the QPI link entered L0p.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Cycles in L0",
        "EventCode": "0xc",
        "EventName": "UNC_Q_TxL0_POWER_CYCLES",
        "PerPkg": "1",
        "PublicDescription": "Number of QPI qfclk cycles spent in L0 power mode in the Link Layer.  L0 is the default mode which provides the highest performance with the most power.  Use edge detect to count the number of instances that the link entered L0.  Link power states are per link and per direction, so for example the Tx direction could be in one state while Rx was in another.  The phy layer  sometimes leaves L0 for training, which will not be captured by this event.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Tx Flit Buffer Bypassed",
        "EventCode": "0x5",
        "EventName": "UNC_Q_TxL_BYPASSED",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of times that an incoming flit was able to bypass the Tx flit buffer and pass directly out the QPI Link. Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is almost full",
        "EventCode": "0x2",
        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.ALMOST_FULL",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles when the Tx side ran out of Link Layer Retry credits, causing the Tx to stall.; When LLR is almost full, we block some but not all packets.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Cycles Stalled with no LLR Credits; LLR is full",
        "EventCode": "0x2",
        "EventName": "UNC_Q_TxL_CRC_NO_CREDITS.FULL",
        "PerPkg": "1",
        "PublicDescription": "Number of cycles when the Tx side ran out of Link Layer Retry credits, causing the Tx to stall.; When LLR is totally full, we are not allowed to send any packets.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Tx Flit Buffer Cycles not Empty",
        "EventCode": "0x6",
        "EventName": "UNC_Q_TxL_CYCLES_NE",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of cycles when the TxQ is not empty. Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 0; Data Tx Flits",
        "EventName": "UNC_Q_TxL_FLITS_G0.DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of data flits transmitted over QPI.  Each flit contains 64b of data.  This includes both DRS and NCB data flits (coherent and non-coherent).  This can be used to calculate the data bandwidth of the QPI link.  One can get a good picture of the QPI-link characteristics by evaluating the protocol flits, data flits, and idle/null flits.  This does not include the header flits that go in data packets.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 0; Non-Data protocol Tx Flits",
        "EventName": "UNC_Q_TxL_FLITS_G0.NON_DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  It includes filters for Idle, protocol, and Data Flits.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time (for L0) or 4B instead of 8B for L0p.; Number of non-NULL non-data flits transmitted across QPI.  This basically tracks the protocol overhead on the QPI link.  One can get a good picture of the QPI-link characteristics by evaluating the protocol flits, data flits, and idle/null flits.  This includes the header flits for data packets.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 1; DRS Flits (both Header and Data)",
        "EventName": "UNC_Q_TxL_FLITS_G1.DRS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of flits transmitted over QPI on the DRS (Data Response) channel.  DRS flits are used to transmit data with coherency.",
        "UMask": "0x18",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 1; DRS Data Flits",
        "EventName": "UNC_Q_TxL_FLITS_G1.DRS_DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of data flits transmitted over QPI on the DRS (Data Response) channel.  DRS flits are used to transmit data with coherency.  This does not count data flits transmitted over the NCB channel which transmits non-coherent data.  This includes only the data flits (not the header).",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 1; DRS Header Flits",
        "EventName": "UNC_Q_TxL_FLITS_G1.DRS_NONDATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of protocol flits transmitted over QPI on the DRS (Data Response) channel.  DRS flits are used to transmit data with coherency.  This does not count data flits transmitted over the NCB channel which transmits non-coherent data.  This includes only the header flits (not the data).  This includes extended headers.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 1; HOM Flits",
        "EventName": "UNC_Q_TxL_FLITS_G1.HOM",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of flits transmitted over QPI on the home channel.",
        "UMask": "0x6",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 1; HOM Non-Request Flits",
        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_NONREQ",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of non-request flits transmitted over QPI on the home channel.  These are most commonly snoop responses, and this event can be used as a proxy for that.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 1; HOM Request Flits",
        "EventName": "UNC_Q_TxL_FLITS_G1.HOM_REQ",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of data request transmitted over QPI on the home channel.  This basically counts the number of remote memory requests transmitted over QPI.  In conjunction with the local read count in the Home Agent, one can calculate the number of LLC Misses.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 1; SNP Flits",
        "EventName": "UNC_Q_TxL_FLITS_G1.SNP",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for SNP, HOM, and DRS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the number of snoop request flits transmitted over QPI.  These requests are contained in the snoop channel.  This does not include snoop responses, which are transmitted on the home channel.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent Bypass Tx Flits",
        "EventCode": "0x1",
        "EventName": "UNC_Q_TxL_FLITS_G2.NCB",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of Non-Coherent Bypass flits.  These packets are generally used to transmit non-coherent data across QPI.",
        "UMask": "0xc",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent data Tx Flits",
        "EventCode": "0x1",
        "EventName": "UNC_Q_TxL_FLITS_G2.NCB_DATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of Non-Coherent Bypass data flits.  These flits are generally used to transmit non-coherent data across QPI.  This does not include a count of the DRS (coherent) data flits.  This only counts the data flits, not the NCB headers.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent non-data Tx Flits",
        "EventCode": "0x1",
        "EventName": "UNC_Q_TxL_FLITS_G2.NCB_NONDATA",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of Non-Coherent Bypass non-data flits.  These packets are generally used to transmit non-coherent data across QPI, and the flits counted here are for headers and other non-data flits.  This includes extended headers.",
        "UMask": "0x8",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 2; Non-Coherent standard Tx Flits",
        "EventCode": "0x1",
        "EventName": "UNC_Q_TxL_FLITS_G2.NCS",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Number of NCS (non-coherent standard) flits transmitted over QPI.    This includes extended headers.",
        "UMask": "0x10",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 2; Non-Data Response Tx Flits - AD",
        "EventCode": "0x1",
        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AD",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of flits transmitted over the NDR (Non-Data Response) channel.  This channel is used to send a variety of protocol flits including grants and completions.  This is only for NDR packets to the local socket which use the AK ring.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Flits Transferred - Group 2; Non-Data Response Tx Flits - AK",
        "EventCode": "0x1",
        "EventName": "UNC_Q_TxL_FLITS_G2.NDR_AK",
        "PerPkg": "1",
        "PublicDescription": "Counts the number of flits transmitted across the QPI Link.  This is one of three groups that allow us to track flits.  It includes filters for NDR, NCB, and NCS message classes.  Each flit is made up of 80 bits of information (in addition to some ECC data).  In full-width (L0) mode, flits are made up of four fits, each of which contains 20 bits of data (along with some additional ECC data).   In half-width (L0p) mode, the fits are only 10 bits, and therefore it takes twice as many fits to transmit a flit.  When one talks about QPI speed (for example, 8.0 GT/s), the transfers here refer to fits.  Therefore, in L0, the system will transfer 1 flit at the rate of 1/4th the QPI speed.  One can calculate the bandwidth of the link by taking: flits*80b/time.  Note that this is not the same as data bandwidth.  For example, when we are transferring a 64B cacheline across QPI, we will break it into 9 flits -- 1 with header information and 8 with 64 bits of actual data and an additional 16 bits of other information.  To calculate data bandwidth, one should therefore do: data flits * 8B / time.; Counts the total number of flits transmitted over the NDR (Non-Data Response) channel.  This channel is used to send a variety of protocol flits including grants and completions.  This is only for NDR packets destined for Route-thru to a remote socket.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Tx Flit Buffer Allocations",
        "EventCode": "0x4",
        "EventName": "UNC_Q_TxL_INSERTS",
        "PerPkg": "1",
        "PublicDescription": "Number of allocations into the QPI Tx Flit Buffer.  Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link.  This event can be used in conjunction with the Flit Buffer Occupancy event in order to calculate the average flit buffer lifetime.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "Tx Flit Buffer Occupancy",
        "EventCode": "0x7",
        "EventName": "UNC_Q_TxL_OCCUPANCY",
        "PerPkg": "1",
        "PublicDescription": "Accumulates the number of flits in the TxQ.  Generally, when data is transmitted across QPI, it will bypass the TxQ and pass directly to the link.  However, the TxQ will be used with L0p and when LLR occurs, increasing latency to transfer out to the link. This can be used with the cycles not empty event to track average occupancy, or the allocations event to track average lifetime in the TxQ.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - HOM; for VN0",
        "EventCode": "0x26",
        "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_ACQUIRED.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of link layer credits into the R3 (for transactions across the BGF) acquired each cycle. Flow Control FIFO for Home messages on AD.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - HOM; for VN1",
        "EventCode": "0x26",
        "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_ACQUIRED.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of link layer credits into the R3 (for transactions across the BGF) acquired each cycle. Flow Control FIFO for Home messages on AD.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD HOM; for VN0",
        "EventCode": "0x22",
        "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_OCCUPANCY.VN0",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of link layer credits into the R3 (for transactions across the BGF) available in each cycle.  Flow Control FIFO for HOM messages on AD.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD HOM; for VN1",
        "EventCode": "0x22",
        "EventName": "UNC_Q_TxR_AD_HOM_CREDIT_OCCUPANCY.VN1",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of link layer credits into the R3 (for transactions across the BGF) available in each cycle.  Flow Control FIFO for HOM messages on AD.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for VN0",
        "EventCode": "0x28",
        "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_ACQUIRED.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of link layer credits into the R3 (for transactions across the BGF) acquired each cycle.  Flow Control FIFO for NDR messages on AD.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for VN1",
        "EventCode": "0x28",
        "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_ACQUIRED.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of link layer credits into the R3 (for transactions across the BGF) acquired each cycle.  Flow Control FIFO for NDR messages on AD.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for VN0",
        "EventCode": "0x24",
        "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_OCCUPANCY.VN0",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of link layer credits into the R3 (for transactions across the BGF) available in each cycle. Flow Control FIFO  for NDR messages on AD.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD NDR; for VN1",
        "EventCode": "0x24",
        "EventName": "UNC_Q_TxR_AD_NDR_CREDIT_OCCUPANCY.VN1",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of link layer credits into the R3 (for transactions across the BGF) available in each cycle. Flow Control FIFO  for NDR messages on AD.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - SNP; for VN0",
        "EventCode": "0x27",
        "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_ACQUIRED.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of link layer credits into the R3 (for transactions across the BGF) acquired each cycle.  Flow Control FIFO for Snoop messages on AD.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - SNP; for VN1",
        "EventCode": "0x27",
        "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_ACQUIRED.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of link layer credits into the R3 (for transactions across the BGF) acquired each cycle.  Flow Control FIFO for Snoop messages on AD.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD SNP; for VN0",
        "EventCode": "0x23",
        "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_OCCUPANCY.VN0",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of link layer credits into the R3 (for transactions across the BGF) available in each cycle.  Flow Control FIFO for Snoop messages on AD.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AD SNP; for VN1",
        "EventCode": "0x23",
        "EventName": "UNC_Q_TxR_AD_SNP_CREDIT_OCCUPANCY.VN1",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of link layer credits into the R3 (for transactions across the BGF) available in each cycle.  Flow Control FIFO for Snoop messages on AD.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR",
        "EventCode": "0x29",
        "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_ACQUIRED",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. Local NDR message class to AK Egress.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR: for VN0",
        "EventCode": "0x29",
        "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_ACQUIRED.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. Local NDR message class to AK Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR: for VN1",
        "EventCode": "0x29",
        "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_ACQUIRED.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. Local NDR message class to AK Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR",
        "EventCode": "0x25",
        "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_OCCUPANCY",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  Local NDR message class to AK Egress.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR: for VN0",
        "EventCode": "0x25",
        "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_OCCUPANCY.VN0",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  Local NDR message class to AK Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - AK NDR: for VN1",
        "EventCode": "0x25",
        "EventName": "UNC_Q_TxR_AK_NDR_CREDIT_OCCUPANCY.VN1",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  Local NDR message class to AK Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for VN0",
        "EventCode": "0x2a",
        "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. DRS message class to BL Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for VN1",
        "EventCode": "0x2a",
        "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. DRS message class to BL Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - DRS; for Shared VN",
        "EventCode": "0x2a",
        "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_ACQUIRED.VN_SHR",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. DRS message class to BL Egress.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for VN0",
        "EventCode": "0x1f",
        "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN0",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  DRS message class to BL Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for VN1",
        "EventCode": "0x1f",
        "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN1",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  DRS message class to BL Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - BL DRS; for Shared VN",
        "EventCode": "0x1f",
        "EventName": "UNC_Q_TxR_BL_DRS_CREDIT_OCCUPANCY.VN_SHR",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  DRS message class to BL Egress.",
        "UMask": "0x4",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - NCB; for VN0",
        "EventCode": "0x2b",
        "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_ACQUIRED.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. NCB message class to BL Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - NCB; for VN1",
        "EventCode": "0x2b",
        "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_ACQUIRED.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. NCB message class to BL Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCB; for VN0",
        "EventCode": "0x20",
        "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_OCCUPANCY.VN0",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  NCB message class to BL Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCB; for VN1",
        "EventCode": "0x20",
        "EventName": "UNC_Q_TxR_BL_NCB_CREDIT_OCCUPANCY.VN1",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  NCB message class to BL Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - NCS; for VN0",
        "EventCode": "0x2c",
        "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_ACQUIRED.VN0",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. NCS message class to BL Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - NCS; for VN1",
        "EventCode": "0x2c",
        "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_ACQUIRED.VN1",
        "PerPkg": "1",
        "PublicDescription": "Number of credits into the R3 (for transactions across the BGF) acquired each cycle. NCS message class to BL Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCS; for VN0",
        "EventCode": "0x21",
        "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_OCCUPANCY.VN0",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  NCS message class to BL Egress.",
        "UMask": "0x1",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "R3QPI Egress Credit Occupancy - BL NCS; for VN1",
        "EventCode": "0x21",
        "EventName": "UNC_Q_TxR_BL_NCS_CREDIT_OCCUPANCY.VN1",
        "PerPkg": "1",
        "PublicDescription": "Occupancy event that tracks the number of credits into the R3 (for transactions across the BGF) available in each cycle.  NCS message class to BL Egress.",
        "UMask": "0x2",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VNA Credits Returned",
        "EventCode": "0x1c",
        "EventName": "UNC_Q_VNA_CREDIT_RETURNS",
        "PerPkg": "1",
        "PublicDescription": "Number of VNA credits returned.",
        "Unit": "QPI LL"
    },
    {
        "BriefDescription": "VNA Credits Pending Return - Occupancy",
        "EventCode": "0x1b",
        "EventName": "UNC_Q_VNA_CREDIT_RETURN_OCCUPANCY",
        "PerPkg": "1",
        "PublicDescription": "Number of VNA credits in the Rx side that are waitng to be returned back across the link.",
        "Unit": "QPI LL"
    }
]
