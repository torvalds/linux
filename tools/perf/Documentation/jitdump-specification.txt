JITDUMP specification version 2
Last Revised: 09/15/2016
Author: Stephane Eranian <eranian@gmail.com>

--------------------------------------------------------
| Revision  |    Date    | Description                 |
--------------------------------------------------------
|   1       | 09/07/2016 | Initial revision            |
--------------------------------------------------------
|   2       | 09/15/2016 | Add JIT_CODE_UNWINDING_INFO |
--------------------------------------------------------


I/ Introduction


This document describes the jitdump file format. The file is generated by Just-In-time compiler runtimes to save meta-data information about the generated code, such as address, size, and name of generated functions, the native code generated, the source line information. The data may then be used by performance tools, such as Linux perf to generate function and assembly level profiles.

The format is not specific to any particular programming language. It can be extended as need be.

The format of the file is binary. It is self-describing in terms of endianness and is portable across multiple processor architectures.


II/ Overview of the format


The format requires only sequential accesses, i.e., append only mode. The file starts with a fixed size file header describing the version of the specification, the endianness.

The header is followed by a series of records, each starting with a fixed size header describing the type of record and its size. It is, itself, followed by the payload for the record. Records can have a variable size even for a given type.

Each entry in the file is timestamped. All timestamps must use the same clock source. The CLOCK_MONOTONIC clock source is recommended.


III/ Jitdump file header format

Each jitdump file starts with a fixed size header containing the following fields in order:


* uint32_t magic     : a magic number tagging the file type. The value is 4-byte long and represents the string "JiTD" in ASCII form. It written is as 0x4A695444. The reader will detect an endian mismatch when it reads 0x4454694a.
* uint32_t version   : a 4-byte value representing the format version. It is currently set to 1
* uint32_t total_size: size in bytes of file header
* uint32_t elf_mach  : ELF architecture encoding (ELF e_machine value as specified in /usr/include/elf.h)
* uint32_t pad1      : padding. Reserved for future use
* uint32_t pid       : JIT runtime process identification (OS specific)
* uint64_t timestamp : timestamp of when the file was created
* uint64_t flags     : a bitmask of flags

The flags currently defined are as follows:
 * bit 0: JITDUMP_FLAGS_ARCH_TIMESTAMP : set if the jitdump file is using an architecture-specific timestamp clock source. For instance, on x86, one could use TSC directly

IV/ Record header

The file header is immediately followed by records. Each record starts with a fixed size header describing the record that follows.

The record header is specified in order as follows:
* uint32_t id        : a value identifying the record type (see below)
* uint32_t total_size: the size in bytes of the record including the header.
* uint64_t timestamp : a timestamp of when the record was created.

The following record types are defined:
 * Value 0 : JIT_CODE_LOAD      : record describing a jitted function
 * Value 1 : JIT_CODE_MOVE      : record describing an already jitted function which is moved
 * Value 2 : JIT_CODE_DEBUG_INFO: record describing the debug information for a jitted function
 * Value 3 : JIT_CODE_CLOSE     : record marking the end of the jit runtime (optional)
 * Value 4 : JIT_CODE_UNWINDING_INFO: record describing a function unwinding information

 The payload of the record must immediately follow the record header without padding.

V/ JIT_CODE_LOAD record


  The record has the following fields following the fixed-size record header in order:
  * uint32_t pid: OS process id of the runtime generating the jitted code
  * uint32_t tid: OS thread identification of the runtime thread generating the jitted code
  * uint64_t vma: virtual address of jitted code start
  * uint64_t code_addr: code start address for the jitted code. By default vma = code_addr
  * uint64_t code_size: size in bytes of the generated jitted code
  * uint64_t code_index: unique identifier for the jitted code (see below)
  * char[n]: function name in ASCII including the null termination
  * native code: raw byte encoding of the jitted code

  The record header total_size field is inclusive of all components:
  * record header
  * fixed-sized fields
  * function name string, including termination
  * native code length
  * record specific variable data (e.g., array of data entries)

The code_index is used to uniquely identify each jitted function. The index can be a monotonically increasing 64-bit value. Each time a function is jitted it gets a new number. This value is used in case the code for a function is moved and avoids having to issue another JIT_CODE_LOAD record.

The format supports empty functions with no native code.


VI/ JIT_CODE_MOVE record

  The record type is optional.

  The record has the following fields following the fixed-size record header in order:
  * uint32_t pid          : OS process id of the runtime generating the jitted code
  * uint32_t tid          : OS thread identification of the runtime thread generating the jitted code
  * uint64_t vma          : new virtual address of jitted code start
  * uint64_t old_code_addr: previous code address for the same function
  * uint64_t new_code_addr: alternate new code started address for the jitted code. By default it should be equal to the vma address.
  * uint64_t code_size    : size in bytes of the jitted code
  * uint64_t code_index   : index referring to the JIT_CODE_LOAD code_index record of when the function was initially jitted


The MOVE record can be used in case an already jitted function is simply moved by the runtime inside the code cache.

The JIT_CODE_MOVE record cannot come before the JIT_CODE_LOAD record for the same function name. The function cannot have changed name, otherwise a new JIT_CODE_LOAD record must be emitted.

The code size of the function cannot change.


VII/ JIT_DEBUG_INFO record

The record type is optional.

The record contains source lines debug information, i.e., a way to map a code address back to a source line. This information may be used by the performance tool.

The record has the following fields following the fixed-size record header in order:
  * uint64_t code_addr: address of function for which the debug information is generated
  * uint64_t nr_entry : number of debug entries for the function
  * debug_entry[n]: array of nr_entry debug entries for the function

The debug_entry describes the source line information. It is defined as follows in order:
* uint64_t code_addr: address of function for which the debug information is generated
* uint32_t line     : source file line number (starting at 1)
* uint32_t discrim  : column discriminator, 0 is default
* char name[n]      : source file name in ASCII, including null termination

The debug_entry entries are saved in sequence but given that they have variable sizes due to the file name string, they cannot be indexed directly.
They need to be walked sequentially. The next debug_entry is found at sizeof(debug_entry) + strlen(name) + 1.

IMPORTANT:
  The JIT_CODE_DEBUG for a given function must always be generated BEFORE the JIT_CODE_LOAD for the function. This facilitates greatly the parser for the jitdump file.


VIII/ JIT_CODE_CLOSE record


The record type is optional.

The record is used as a marker for the end of the jitted runtime. It can be replaced by the end of the file.

The JIT_CODE_CLOSE record does not have any specific fields, the record header contains all the information needed.


IX/ JIT_CODE_UNWINDING_INFO


The record type is optional.

The record is used to describe the unwinding information for a jitted function.

The record has the following fields following the fixed-size record header in order:

uint64_t unwind_data_size   : the size in bytes of the unwinding data table at the end of the record
uint64_t eh_frame_hdr_size  : the size in bytes of the DWARF EH Frame Header at the start of the unwinding data table at the end of the record
uint64_t mapped_size        : the size of the unwinding data mapped in memory
const char unwinding_data[n]: an array of unwinding data, consisting of the EH Frame Header, followed by the actual EH Frame


The EH Frame header follows the Linux Standard Base (LSB) specification as described in the document at https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/ehframehdr.html


The EH Frame follows the LSB specification as described in the document at https://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/ehframechpt.html


NOTE: The mapped_size is generally either the same as unwind_data_size (if the unwinding data was mapped in memory by the running process) or zero (if the unwinding data is not mapped by the process). If the unwinding data was not mapped, then only the EH Frame Header will be read, which can be used to specify FP based unwinding for a function which does not have unwinding information.
