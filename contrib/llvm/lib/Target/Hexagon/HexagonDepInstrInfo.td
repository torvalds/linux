//===----------------------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Automatically generated file, please consult code owner before editing.
//===----------------------------------------------------------------------===//

def A2_abs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = abs($Rs32)",
tc_cf8126ae, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_absp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = abs($Rss32)",
tc_cf8126ae, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000100;
let prefersSlot3 = 1;
}
def A2_abssat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = abs($Rs32):sat",
tc_cf8126ae, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_add : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_5ab2be, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_addh_h16_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.h):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_addh_h16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.l):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_addh_h16_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_addh_h16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_addh_h16_sat_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.h):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_addh_h16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.h,$Rs32.l):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_addh_h16_sat_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_addh_h16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_addh_l16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h)",
tc_4414d8b1, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_addh_l16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l)",
tc_4414d8b1, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_addh_l16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.h):sat",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_addh_l16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = add($Rt32.l,$Rs32.l):sat",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_addi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = add($Rs32,#$Ii)",
tc_5a2711e5, TypeALU32_ADDI>, Enc_cb9321, PredNewRel, ImmRegRel {
let Inst{31-28} = 0b1011;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isPredicable = 1;
let isAdd = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def A2_addp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32)",
tc_946df596, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let isCommutable = 1;
let isAdd = 1;
}
def A2_addpsat : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32):sat",
tc_779080bf, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let isCommutable = 1;
}
def A2_addsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add($Rs32,$Rt32):sat",
tc_61830035, TypeALU32_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
let isCommutable = 1;
}
def A2_addsp : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rs32,$Rtt32)",
tc_679309b8, TypeALU64> {
let isPseudo = 1;
}
def A2_addsph : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32):raw:hi",
tc_679309b8, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_addspl : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = add($Rss32,$Rtt32):raw:lo",
tc_679309b8, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_and : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = and($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_5ab2be, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_and";
let InputType = "reg";
let BaseOpcode = "A2_and";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_andir : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = and($Rs32,#$Ii)",
tc_5a2711e5, TypeALU32_2op>, Enc_140c83, ImmRegRel {
let Inst{31-22} = 0b0111011000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_and";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def A2_andp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = and($Rss32,$Rtt32)",
tc_946df596, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let isCommutable = 1;
}
def A2_aslh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = aslh($Rs32)",
tc_57890846, TypeALU32_2op>, Enc_5e2823, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000000;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_aslh";
let isPredicable = 1;
}
def A2_asrh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = asrh($Rs32)",
tc_57890846, TypeALU32_2op>, Enc_5e2823, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000001;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_asrh";
let isPredicable = 1;
}
def A2_combine_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.h,$Rs32.h)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011100;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combine_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.h,$Rs32.l)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011101;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combine_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.l,$Rs32.h)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011110;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combine_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = combine($Rt32.l,$Rs32.l)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011111;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_combineii : HInst<
(outs DoubleRegs:$Rdd32),
(ins s32_0Imm:$Ii, s8_0Imm:$II),
"$Rdd32 = combine(#$Ii,#$II)",
tc_5a2711e5, TypeALU32_2op>, Enc_18c338 {
let Inst{31-23} = 0b011111000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_combinew : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = combine($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_be32a5, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110101000;
let InputType = "reg";
let BaseOpcode = "A2_combinew";
let isPredicable = 1;
}
def A2_max : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = max($Rs32,$Rt32)",
tc_779080bf, TypeALU64>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_maxp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = max($Rss32,$Rtt32)",
tc_779080bf, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_maxu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = maxu($Rs32,$Rt32)",
tc_779080bf, TypeALU64>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_maxup : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = maxu($Rss32,$Rtt32)",
tc_779080bf, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_min : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = min($Rt32,$Rs32)",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_minp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = min($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_minu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = minu($Rt32,$Rs32)",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_minup : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = minu($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_neg : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = neg($Rs32)",
tc_57890846, TypeALU32_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_negp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = neg($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000100;
}
def A2_negsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = neg($Rs32):sat",
tc_cf8126ae, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_nop : HInst<
(outs),
(ins),
"nop",
tc_2eabeebe, TypeALU32_2op>, Enc_e3b0c4 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b0111111100000000;
}
def A2_not : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = not($Rs32)",
tc_57890846, TypeALU32_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_notp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = not($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000100;
}
def A2_or : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = or($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_5ab2be, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001001;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_or";
let InputType = "reg";
let BaseOpcode = "A2_or";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_orir : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = or($Rs32,#$Ii)",
tc_5a2711e5, TypeALU32_2op>, Enc_140c83, ImmRegRel {
let Inst{31-22} = 0b0111011010;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_or";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def A2_orp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = or($Rss32,$Rtt32)",
tc_946df596, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let isCommutable = 1;
}
def A2_paddf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = add($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_paddfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = add($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_paddif : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if (!$Pu4) $Rd32 = add($Rs32,#$Ii)",
tc_4c5ba658, TypeALU32_2op>, Enc_e38e1f, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011101001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_paddifnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if (!$Pu4.new) $Rd32 = add($Rs32,#$Ii)",
tc_05c070ec, TypeALU32_2op>, Enc_e38e1f, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-23} = 0b011101001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_paddit : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if ($Pu4) $Rd32 = add($Rs32,#$Ii)",
tc_4c5ba658, TypeALU32_2op>, Enc_e38e1f, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011101000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_padditnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"if ($Pu4.new) $Rd32 = add($Rs32,#$Ii)",
tc_05c070ec, TypeALU32_2op>, Enc_e38e1f, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-23} = 0b011101000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "imm";
let BaseOpcode = "A2_addi";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A2_paddt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = add($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_paddtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = add($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel, ImmRegRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_add";
let InputType = "reg";
let BaseOpcode = "A2_add";
}
def A2_pandf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = and($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_and";
}
def A2_pandfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = and($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_and";
}
def A2_pandt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = and($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_and";
}
def A2_pandtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = and($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_and";
}
def A2_porf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = or($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_or";
}
def A2_porfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = or($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_or";
}
def A2_port : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = or($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_or";
}
def A2_portnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = or($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_or";
}
def A2_psubf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = sub($Rt32,$Rs32)",
tc_4c5ba658, TypeALU32_3op>, Enc_9b0bc1, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sub";
}
def A2_psubfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = sub($Rt32,$Rs32)",
tc_05c070ec, TypeALU32_3op>, Enc_9b0bc1, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sub";
}
def A2_psubt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = sub($Rt32,$Rs32)",
tc_4c5ba658, TypeALU32_3op>, Enc_9b0bc1, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sub";
}
def A2_psubtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rt32, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = sub($Rt32,$Rs32)",
tc_05c070ec, TypeALU32_3op>, Enc_9b0bc1, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sub";
}
def A2_pxorf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rd32 = xor($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_xor";
}
def A2_pxorfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rd32 = xor($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_xor";
}
def A2_pxort : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rd32 = xor($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_xor";
}
def A2_pxortnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rd32 = xor($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_ea4c54, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111001011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_xor";
}
def A2_roundsat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = round($Rss32):sat",
tc_cf8126ae, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_sat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = sat($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_satb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = satb($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_sath : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sath($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_satub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = satub($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_satuh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = satuh($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def A2_sub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32,$Rs32)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011, PredNewRel, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011001;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_sub";
let InputType = "reg";
let BaseOpcode = "A2_sub";
let isPredicable = 1;
}
def A2_subh_h16_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.h):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_subh_h16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.l):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_subh_h16_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_subh_h16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l):<<16",
tc_679309b8, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_subh_h16_sat_hh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.h):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_subh_h16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.h,$Rs32.l):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_subh_h16_sat_lh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_subh_h16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l):sat:<<16",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_subh_l16_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h)",
tc_4414d8b1, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_subh_l16_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l)",
tc_4414d8b1, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A2_subh_l16_sat_hl : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.h):sat",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_subh_l16_sat_ll : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32.l,$Rs32.l):sat",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_subp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = sub($Rtt32,$Rss32)",
tc_946df596, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_subri : HInst<
(outs IntRegs:$Rd32),
(ins s32_0Imm:$Ii, IntRegs:$Rs32),
"$Rd32 = sub(#$Ii,$Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_140c83, PredNewRel, ImmRegRel {
let Inst{31-22} = 0b0111011001;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_sub";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def A2_subsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32,$Rs32):sat",
tc_61830035, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
}
def A2_svaddh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vaddh($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110000;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let isCommutable = 1;
}
def A2_svaddhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vaddh($Rs32,$Rt32):sat",
tc_61830035, TypeALU32_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
let isCommutable = 1;
}
def A2_svadduhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vadduh($Rs32,$Rt32):sat",
tc_61830035, TypeALU32_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
let isCommutable = 1;
}
def A2_svavgh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vavgh($Rs32,$Rt32)",
tc_1c80410a, TypeALU32_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110111000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let isCommutable = 1;
}
def A2_svavghs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vavgh($Rs32,$Rt32):rnd",
tc_d08ee0f4, TypeALU32_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110111001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let isCommutable = 1;
}
def A2_svnavgh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vnavgh($Rt32,$Rs32)",
tc_1c80410a, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110111011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
}
def A2_svsubh : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vsubh($Rt32,$Rs32)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110100;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A2_svsubhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vsubh($Rt32,$Rs32):sat",
tc_61830035, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
}
def A2_svsubuhs : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = vsubuh($Rt32,$Rs32):sat",
tc_61830035, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
}
def A2_swiz : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = swiz($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_sxtb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sxtb($Rs32)",
tc_57890846, TypeALU32_2op>, Enc_5e2823, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000101;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxtb";
let isPredicable = 1;
}
def A2_sxth : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sxth($Rs32)",
tc_57890846, TypeALU32_2op>, Enc_5e2823, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000111;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxth";
let isPredicable = 1;
}
def A2_sxtw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = sxtw($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000100010;
}
def A2_tfr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = $Rs32",
tc_57890846, TypeALU32_2op>, Enc_5e2823, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000011;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPredicable = 1;
}
def A2_tfrcrr : HInst<
(outs IntRegs:$Rd32),
(ins CtrRegs:$Cs32),
"$Rd32 = $Cs32",
tc_b9272d6c, TypeCR>, Enc_0cb018 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01101010000;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_tfrf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = $Rs32",
tc_4c5ba658, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_tfrfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = $Rs32",
tc_05c070ec, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_tfrih : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, u16_0Imm:$Ii),
"$Rx32.h = #$Ii",
tc_5a2711e5, TypeALU32_2op>, Enc_51436c {
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01110010;
let hasNewValue = 1;
let opNewValue = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def A2_tfril : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, u16_0Imm:$Ii),
"$Rx32.l = #$Ii",
tc_5a2711e5, TypeALU32_2op>, Enc_51436c {
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01110001;
let hasNewValue = 1;
let opNewValue = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def A2_tfrp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = $Rss32",
tc_5a2711e5, TypeALU32_2op>, PredNewRel {
let BaseOpcode = "A2_tfrp";
let isPredicable = 1;
let isPseudo = 1;
}
def A2_tfrpf : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if (!$Pu4) $Rdd32 = $Rss32",
tc_5a2711e5, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrpfnew : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if (!$Pu4.new) $Rdd32 = $Rss32",
tc_1ae57e39, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let isPredicatedFalse = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrpi : HInst<
(outs DoubleRegs:$Rdd32),
(ins s8_0Imm:$Ii),
"$Rdd32 = #$Ii",
tc_5a2711e5, TypeALU64> {
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
let isMoveImm = 1;
let isPseudo = 1;
}
def A2_tfrpt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if ($Pu4) $Rdd32 = $Rss32",
tc_5a2711e5, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrptnew : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32),
"if ($Pu4.new) $Rdd32 = $Rss32",
tc_1ae57e39, TypeALU32_2op>, PredNewRel {
let isPredicated = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_tfrp";
let isPseudo = 1;
}
def A2_tfrrcr : HInst<
(outs CtrRegs:$Cd32),
(ins IntRegs:$Rs32),
"$Cd32 = $Rs32",
tc_434c8e1e, TypeCR>, Enc_bd811a {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01100010001;
let hasNewValue = 1;
let opNewValue = 0;
}
def A2_tfrsi : HInst<
(outs IntRegs:$Rd32),
(ins s32_0Imm:$Ii),
"$Rd32 = #$Ii",
tc_57890846, TypeALU32_2op>, Enc_5e87ce, PredNewRel, ImmRegRel {
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01111000;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isPredicable = 1;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def A2_tfrt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = $Rs32",
tc_4c5ba658, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_tfrtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = $Rs32",
tc_05c070ec, TypeALU32_2op>, PredNewRel, ImmRegRel {
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "reg";
let BaseOpcode = "A2_tfr";
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_vabsh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsh($Rss32)",
tc_cf8126ae, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000010;
let prefersSlot3 = 1;
}
def A2_vabshsat : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsh($Rss32):sat",
tc_cf8126ae, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vabsw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsw($Rss32)",
tc_cf8126ae, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000010;
let prefersSlot3 = 1;
}
def A2_vabswsat : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vabsw($Rss32):sat",
tc_cf8126ae, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vaddb_map : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddb($Rss32,$Rtt32)",
tc_946df596, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_vaddh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddh($Rss32,$Rtt32)",
tc_946df596, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
}
def A2_vaddhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddh($Rss32,$Rtt32):sat",
tc_779080bf, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vaddub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddub($Rss32,$Rtt32)",
tc_946df596, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
}
def A2_vaddubs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddub($Rss32,$Rtt32):sat",
tc_779080bf, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vadduhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vadduh($Rss32,$Rtt32):sat",
tc_779080bf, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vaddw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddw($Rss32,$Rtt32)",
tc_946df596, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
}
def A2_vaddws : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vaddw($Rss32,$Rtt32):sat",
tc_779080bf, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vavgh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgh($Rss32,$Rtt32)",
tc_6132ba3d, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavghcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgh($Rss32,$Rtt32):crnd",
tc_002cb246, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavghr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgh($Rss32,$Rtt32):rnd",
tc_e4a7f9f0, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavgub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgub($Rss32,$Rtt32)",
tc_6132ba3d, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavgubr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgub($Rss32,$Rtt32):rnd",
tc_e4a7f9f0, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavguh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguh($Rss32,$Rtt32)",
tc_6132ba3d, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavguhr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguh($Rss32,$Rtt32):rnd",
tc_e4a7f9f0, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011010;
let prefersSlot3 = 1;
}
def A2_vavguw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguw($Rss32,$Rtt32)",
tc_6132ba3d, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_vavguwr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavguw($Rss32,$Rtt32):rnd",
tc_e4a7f9f0, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_vavgw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgw($Rss32,$Rtt32)",
tc_6132ba3d, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_vavgwcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgw($Rss32,$Rtt32):crnd",
tc_002cb246, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_vavgwr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vavgw($Rss32,$Rtt32):rnd",
tc_e4a7f9f0, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011011;
let prefersSlot3 = 1;
}
def A2_vcmpbeq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpb.eq($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b110000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpbgtu : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpb.gtu($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b111000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpheq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmph.eq($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmphgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmph.gt($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmphgtu : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmph.gtu($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpweq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpw.eq($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpwgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpw.gt($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vcmpwgtu : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpw.gtu($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010000;
}
def A2_vconj : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vconj($Rss32):sat",
tc_cf8126ae, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vmaxb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxb($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_vmaxh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxh($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_vmaxub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxub($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_vmaxuh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxuh($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_vmaxuw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxuw($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_vmaxw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vmaxw($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_vminb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminb($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011110;
let prefersSlot3 = 1;
}
def A2_vminh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminh($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_vminub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminub($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_vminuh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminuh($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_vminuw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminuw($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_vminw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vminw($Rtt32,$Rss32)",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011101;
let prefersSlot3 = 1;
}
def A2_vnavgh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgh($Rtt32,$Rss32)",
tc_6132ba3d, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
}
def A2_vnavghcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgh($Rtt32,$Rss32):crnd:sat",
tc_002cb246, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vnavghr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgh($Rtt32,$Rss32):rnd:sat",
tc_002cb246, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vnavgw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgw($Rtt32,$Rss32)",
tc_6132ba3d, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
}
def A2_vnavgwcr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgw($Rtt32,$Rss32):crnd:sat",
tc_002cb246, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vnavgwr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vnavgw($Rtt32,$Rss32):rnd:sat",
tc_002cb246, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vraddub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vraddub($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def A2_vraddub_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vraddub($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A2_vrsadub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrsadub($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def A2_vrsadub_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrsadub($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A2_vsubb_map : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vsubb($Rss32,$Rtt32)",
tc_946df596, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_vsubh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubh($Rtt32,$Rss32)",
tc_946df596, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_vsubhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubh($Rtt32,$Rss32):sat",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vsubub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubub($Rtt32,$Rss32)",
tc_946df596, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_vsububs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubub($Rtt32,$Rss32):sat",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vsubuhs : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubuh($Rtt32,$Rss32):sat",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_vsubw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubw($Rtt32,$Rss32)",
tc_946df596, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
}
def A2_vsubws : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vsubw($Rtt32,$Rss32):sat",
tc_779080bf, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A2_xor : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = xor($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_5ab2be, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001011;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
let BaseOpcode = "A2_xor";
let isCommutable = 1;
let isPredicable = 1;
}
def A2_xorp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = xor($Rss32,$Rtt32)",
tc_946df596, TypeALU64>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let isCommutable = 1;
}
def A2_zxtb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = zxtb($Rs32)",
tc_5a2711e5, TypeALU32_2op>, PredNewRel {
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxtb";
let isPredicable = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def A2_zxth : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = zxth($Rs32)",
tc_57890846, TypeALU32_2op>, Enc_5e2823, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01110000110;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxth";
let isPredicable = 1;
}
def A4_addp_c : HInst<
(outs DoubleRegs:$Rdd32, PredRegs:$Px4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, PredRegs:$Px4in),
"$Rdd32 = add($Rss32,$Rtt32,$Px4):carry",
tc_9c3ecd83, TypeS_3op>, Enc_2b3f60 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010110;
let isPredicateLate = 1;
let Constraints = "$Px4 = $Px4in";
}
def A4_andn : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = and($Rt32,~$Rs32)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001100;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A4_andnp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = and($Rtt32,~$Rss32)",
tc_946df596, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
}
def A4_bitsplit : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = bitsplit($Rs32,$Rt32)",
tc_4414d8b1, TypeALU64>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010100001;
let prefersSlot3 = 1;
}
def A4_bitspliti : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rdd32 = bitsplit($Rs32,#$Ii)",
tc_4414d8b1, TypeS_2op>, Enc_311abd {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001000110;
let prefersSlot3 = 1;
}
def A4_boundscheck : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Pd4 = boundscheck($Rs32,$Rtt32)",
tc_85d5d03f, TypeALU64> {
let isPseudo = 1;
}
def A4_boundscheck_hi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = boundscheck($Rss32,$Rtt32):raw:hi",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_boundscheck_lo : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = boundscheck($Rss32,$Rtt32):raw:lo",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_cmpbeq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmpb.eq($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b110000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpbeq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def A4_cmpbeqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u8_0Imm:$Ii),
"$Pd4 = cmpb.eq($Rs32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_08d755, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101000;
let CextOpcode = "A4_cmpbeq";
let InputType = "imm";
let isCommutable = 1;
let isCompare = 1;
}
def A4_cmpbgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmpb.gt($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpbgt";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmpbgti : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s8_0Imm:$Ii),
"$Pd4 = cmpb.gt($Rs32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_08d755, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101001;
let CextOpcode = "A4_cmpbgt";
let InputType = "imm";
let isCompare = 1;
}
def A4_cmpbgtu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmpb.gtu($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b111000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpbgtu";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmpbgtui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = cmpb.gtu($Rs32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_02553a, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011101010;
let CextOpcode = "A4_cmpbgtu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 0;
}
def A4_cmpheq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmph.eq($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmpheq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def A4_cmpheqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmph.eq($Rs32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_08d755, ImmRegRel {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101000;
let CextOpcode = "A4_cmpheq";
let InputType = "imm";
let isCommutable = 1;
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_cmphgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmph.gt($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmphgt";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmphgti : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmph.gt($Rs32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_08d755, ImmRegRel {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011101001;
let CextOpcode = "A4_cmphgt";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_cmphgtu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmph.gtu($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111110;
let CextOpcode = "A4_cmphgtu";
let InputType = "reg";
let isCompare = 1;
}
def A4_cmphgtui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = cmph.gtu($Rs32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_02553a, ImmRegRel {
let Inst{4-2} = 0b010;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011101010;
let CextOpcode = "A4_cmphgtu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 0;
}
def A4_combineii : HInst<
(outs DoubleRegs:$Rdd32),
(ins s8_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = combine(#$Ii,#$II)",
tc_5a2711e5, TypeALU32_2op>, Enc_f0cca7 {
let Inst{31-21} = 0b01111100100;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def A4_combineir : HInst<
(outs DoubleRegs:$Rdd32),
(ins s32_0Imm:$Ii, IntRegs:$Rs32),
"$Rdd32 = combine(#$Ii,$Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_9cdba7 {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011001;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_combineri : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rdd32 = combine($Rs32,#$Ii)",
tc_5a2711e5, TypeALU32_2op>, Enc_9cdba7 {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011000;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_cround_ri : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = cround($Rs32,#$Ii)",
tc_002cb246, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_cround_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cround($Rs32,$Rt32)",
tc_002cb246, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_ext : HInst<
(outs),
(ins u26_6Imm:$Ii),
"immext(#$Ii)",
tc_862b3e70, TypeEXTENDER>, Enc_2b518f {
let Inst{31-28} = 0b0000;
}
def A4_modwrapu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = modwrap($Rs32,$Rt32)",
tc_779080bf, TypeALU64>, Enc_5ab2be {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_orn : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = or($Rt32,~$Rs32)",
tc_5a2711e5, TypeALU32_3op>, Enc_bd6011 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110001101;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def A4_ornp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = or($Rtt32,~$Rss32)",
tc_946df596, TypeALU64>, Enc_ea23e4 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010011111;
}
def A4_paslhf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = aslh($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_aslh";
}
def A4_paslhfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = aslh($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_aslh";
}
def A4_paslht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = aslh($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_aslh";
}
def A4_paslhtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = aslh($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_aslh";
}
def A4_pasrhf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = asrh($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_asrh";
}
def A4_pasrhfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = asrh($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_asrh";
}
def A4_pasrht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = asrh($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_asrh";
}
def A4_pasrhtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = asrh($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_asrh";
}
def A4_psxtbf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = sxtb($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxtb";
}
def A4_psxtbfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = sxtb($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxtb";
}
def A4_psxtbt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = sxtb($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxtb";
}
def A4_psxtbtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = sxtb($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000101;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxtb";
}
def A4_psxthf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = sxth($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxth";
}
def A4_psxthfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = sxth($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxth";
}
def A4_psxtht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = sxth($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_sxth";
}
def A4_psxthtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = sxth($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000111;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_sxth";
}
def A4_pzxtbf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = zxtb($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxtbfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = zxtb($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxtbt : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = zxtb($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxtbtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = zxtb($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxtb";
}
def A4_pzxthf : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) $Rd32 = zxth($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxth";
}
def A4_pzxthfnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) $Rd32 = zxth($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1011;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxth";
}
def A4_pzxtht : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) $Rd32 = zxth($Rs32)",
tc_5a2711e5, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let BaseOpcode = "A2_zxth";
}
def A4_pzxthtnew : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) $Rd32 = zxth($Rs32)",
tc_1ae57e39, TypeALU32_2op>, Enc_fb6577, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b01110000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let BaseOpcode = "A2_zxth";
}
def A4_rcmpeq : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmp.eq($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_5ab2be, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011010;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpeq";
let InputType = "reg";
let isCommutable = 1;
}
def A4_rcmpeqi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = cmp.eq($Rs32,#$Ii)",
tc_5a2711e5, TypeALU32_2op>, Enc_b8c967, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011010;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpeqi";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_rcmpneq : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = !cmp.eq($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_5ab2be, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110011011;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpneq";
let InputType = "reg";
let isCommutable = 1;
}
def A4_rcmpneqi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = !cmp.eq($Rs32,#$Ii)",
tc_5a2711e5, TypeALU32_2op>, Enc_b8c967, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b01110011011;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A4_rcmpeqi";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def A4_round_ri : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = round($Rs32,#$Ii)",
tc_002cb246, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_round_ri_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = round($Rs32,#$Ii):sat",
tc_002cb246, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A4_round_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = round($Rs32,$Rt32)",
tc_002cb246, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def A4_round_rr_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = round($Rs32,$Rt32):sat",
tc_002cb246, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A4_subp_c : HInst<
(outs DoubleRegs:$Rdd32, PredRegs:$Px4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, PredRegs:$Px4in),
"$Rdd32 = sub($Rss32,$Rtt32,$Px4):carry",
tc_9c3ecd83, TypeS_3op>, Enc_2b3f60 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010111;
let isPredicateLate = 1;
let Constraints = "$Px4 = $Px4in";
}
def A4_tfrcpp : HInst<
(outs DoubleRegs:$Rdd32),
(ins CtrRegs64:$Css32),
"$Rdd32 = $Css32",
tc_b9272d6c, TypeCR>, Enc_667b39 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01101000000;
}
def A4_tfrpcp : HInst<
(outs CtrRegs64:$Cdd32),
(ins DoubleRegs:$Rss32),
"$Cdd32 = $Rss32",
tc_434c8e1e, TypeCR>, Enc_0ed752 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01100011001;
}
def A4_tlbmatch : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Pd4 = tlbmatch($Rss32,$Rt32)",
tc_4837eefb, TypeALU64>, Enc_03833b {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
let isPredicateLate = 1;
}
def A4_vcmpbeq_any : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = any8(vcmpb.eq($Rss32,$Rtt32))",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_vcmpbeqi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u8_0Imm:$Ii),
"$Pd4 = vcmpb.eq($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_0d8adb {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100000;
}
def A4_vcmpbgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = vcmpb.gt($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A4_vcmpbgti : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmpb.gt($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_0d8adb {
let Inst{4-2} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100001;
}
def A4_vcmpbgtui : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u7_0Imm:$Ii),
"$Pd4 = vcmpb.gtu($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_3680c2 {
let Inst{4-2} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011100010;
}
def A4_vcmpheqi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmph.eq($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_0d8adb {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100000;
}
def A4_vcmphgti : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmph.gt($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_0d8adb {
let Inst{4-2} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100001;
}
def A4_vcmphgtui : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u7_0Imm:$Ii),
"$Pd4 = vcmph.gtu($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_3680c2 {
let Inst{4-2} = 0b010;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011100010;
}
def A4_vcmpweqi : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmpw.eq($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_0d8adb {
let Inst{4-2} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100000;
}
def A4_vcmpwgti : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, s8_0Imm:$Ii),
"$Pd4 = vcmpw.gt($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_0d8adb {
let Inst{4-2} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11011100001;
}
def A4_vcmpwgtui : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u7_0Imm:$Ii),
"$Pd4 = vcmpw.gtu($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_3680c2 {
let Inst{4-2} = 0b100;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b11011100010;
}
def A4_vrmaxh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxh($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrmaxuh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxuh($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrmaxuw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxuw($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrmaxw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrmaxw($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminh($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminuh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminuh($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminuw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminuw($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A4_vrminw : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Ru32),
"$Rxx32 = vrminw($Rss32,$Ru32)",
tc_5b54b33f, TypeS_3op>, Enc_412ff0 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def A5_ACS : HInst<
(outs DoubleRegs:$Rxx32, PredRegs:$Pe4),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32,$Pe4 = vacsh($Rss32,$Rtt32)",
tc_d1aa9eaa, TypeM>, Enc_831a7d, Requires<[HasV55]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let isPredicateLate = 1;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def A5_vaddhubs : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vaddhub($Rss32,$Rtt32):sat",
tc_002cb246, TypeS_3op>, Enc_d2216a {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def A6_vcmpbeq_notany : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = !any8(vcmpb.eq($Rss32,$Rtt32))",
tc_1fc97744, TypeALU64>, Enc_fcf7a7, Requires<[HasV65]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11010010000;
}
def A6_vminub_RdP : HInst<
(outs DoubleRegs:$Rdd32, PredRegs:$Pe4),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32,$Pe4 = vminub($Rtt32,$Rss32)",
tc_f9058dd7, TypeM>, Enc_d2c7f1, Requires<[HasV62]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let isPredicateLate = 1;
let prefersSlot3 = 1;
}
def C2_all8 : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = all8($Ps4)",
tc_de554571, TypeCR>, Enc_65d691 {
let Inst{13-2} = 0b000000000000;
let Inst{31-18} = 0b01101011101000;
}
def C2_and : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = and($Pt4,$Ps4)",
tc_640086b5, TypeCR>, Enc_454a26 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011000000;
}
def C2_andn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = and($Pt4,!$Ps4)",
tc_640086b5, TypeCR>, Enc_454a26 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011011000;
}
def C2_any8 : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = any8($Ps4)",
tc_de554571, TypeCR>, Enc_65d691 {
let Inst{13-2} = 0b000000000000;
let Inst{31-18} = 0b01101011100000;
}
def C2_bitsclr : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = bitsclr($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111100;
}
def C2_bitsclri : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u6_0Imm:$Ii),
"$Pd4 = bitsclr($Rs32,#$Ii)",
tc_643b4717, TypeS_2op>, Enc_5d6c34 {
let Inst{7-2} = 0b000000;
let Inst{31-21} = 0b10000101100;
}
def C2_bitsset : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = bitsset($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111010;
}
def C2_ccombinewf : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4) $Rdd32 = combine($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_cb4b4e, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let BaseOpcode = "A2_combinew";
}
def C2_ccombinewnewf : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pu4.new) $Rdd32 = combine($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_cb4b4e, PredNewRel {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_combinew";
}
def C2_ccombinewnewt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4.new) $Rdd32 = combine($Rs32,$Rt32)",
tc_05c070ec, TypeALU32_3op>, Enc_cb4b4e, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let isPredicatedNew = 1;
let BaseOpcode = "A2_combinew";
}
def C2_ccombinewt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pu4) $Rdd32 = combine($Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_cb4b4e, PredNewRel {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11111101000;
let isPredicated = 1;
let BaseOpcode = "A2_combinew";
}
def C2_cmoveif : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if (!$Pu4) $Rd32 = #$Ii",
tc_5a2711e5, TypeALU32_2op>, Enc_cda00a, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmoveit : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if ($Pu4) $Rd32 = #$Ii",
tc_5a2711e5, TypeALU32_2op>, Enc_cda00a, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmovenewif : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if (!$Pu4.new) $Rd32 = #$Ii",
tc_1ae57e39, TypeALU32_2op>, Enc_cda00a, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmovenewit : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii),
"if ($Pu4.new) $Rd32 = #$Ii",
tc_1ae57e39, TypeALU32_2op>, Enc_cda00a, PredNewRel, ImmRegRel {
let Inst{13-13} = 0b1;
let Inst{20-20} = 0b0;
let Inst{31-23} = 0b011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let isPredicatedNew = 1;
let CextOpcode = "A2_tfr";
let InputType = "imm";
let BaseOpcode = "A2_tfrsi";
let isMoveImm = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 0;
}
def C2_cmpeq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.eq($Rs32,$Rt32)",
tc_de4df740, TypeALU32_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010000;
let CextOpcode = "C2_cmpeq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def C2_cmpeqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmp.eq($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op>, Enc_bd0b33, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{31-22} = 0b0111010100;
let CextOpcode = "C2_cmpeq";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C2_cmpeqp : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = cmp.eq($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010100;
let isCommutable = 1;
let isCompare = 1;
}
def C2_cmpgei : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s8_0Imm:$Ii),
"$Pd4 = cmp.ge($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op> {
let isCompare = 1;
let isPseudo = 1;
}
def C2_cmpgeui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u8_0Imm:$Ii),
"$Pd4 = cmp.geu($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op> {
let isCompare = 1;
let isPseudo = 1;
}
def C2_cmpgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.gt($Rs32,$Rt32)",
tc_de4df740, TypeALU32_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010010;
let CextOpcode = "C2_cmpgt";
let InputType = "reg";
let isCompare = 1;
}
def C2_cmpgti : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = cmp.gt($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op>, Enc_bd0b33, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{31-22} = 0b0111010101;
let CextOpcode = "C2_cmpgt";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C2_cmpgtp : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = cmp.gt($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010100;
let isCompare = 1;
}
def C2_cmpgtu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.gtu($Rs32,$Rt32)",
tc_de4df740, TypeALU32_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010011;
let CextOpcode = "C2_cmpgtu";
let InputType = "reg";
let isCompare = 1;
}
def C2_cmpgtui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = cmp.gtu($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op>, Enc_c0cdde, ImmRegRel {
let Inst{4-2} = 0b000;
let Inst{31-21} = 0b01110101100;
let CextOpcode = "C2_cmpgtu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 0;
}
def C2_cmpgtup : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = cmp.gtu($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010100;
let isCompare = 1;
}
def C2_cmplt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.lt($Rs32,$Rt32)",
tc_56f114f4, TypeALU32_3op> {
let isCompare = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def C2_cmpltu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = cmp.ltu($Rs32,$Rt32)",
tc_56f114f4, TypeALU32_3op> {
let isCompare = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def C2_mask : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4),
"$Rdd32 = mask($Pt4)",
tc_0ae0825c, TypeS_2op>, Enc_78e566 {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0000;
let Inst{31-16} = 0b1000011000000000;
}
def C2_mux : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mux($Pu4,$Rs32,$Rt32)",
tc_4c5ba658, TypeALU32_3op>, Enc_ea4c54 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110100000;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "reg";
}
def C2_muxii : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii, s8_0Imm:$II),
"$Rd32 = mux($Pu4,#$Ii,#$II)",
tc_4c5ba658, TypeALU32_2op>, Enc_830e5d {
let Inst{31-25} = 0b0111101;
let hasNewValue = 1;
let opNewValue = 0;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def C2_muxir : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = mux($Pu4,$Rs32,#$Ii)",
tc_4c5ba658, TypeALU32_2op>, Enc_e38e1f {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011100110;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def C2_muxri : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pu4, s32_0Imm:$Ii, IntRegs:$Rs32),
"$Rd32 = mux($Pu4,#$Ii,$Rs32)",
tc_4c5ba658, TypeALU32_2op>, Enc_e38e1f {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b011100111;
let hasNewValue = 1;
let opNewValue = 0;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def C2_not : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = not($Ps4)",
tc_de554571, TypeCR>, Enc_65d691 {
let Inst{13-2} = 0b000000000000;
let Inst{31-18} = 0b01101011110000;
}
def C2_or : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = or($Pt4,$Ps4)",
tc_640086b5, TypeCR>, Enc_454a26 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011001000;
}
def C2_orn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Pt4, PredRegs:$Ps4),
"$Pd4 = or($Pt4,!$Ps4)",
tc_640086b5, TypeCR>, Enc_454a26 {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011111000;
}
def C2_pxfer_map : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4),
"$Pd4 = $Ps4",
tc_640086b5, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def C2_tfrpr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Ps4),
"$Rd32 = $Ps4",
tc_0ae0825c, TypeS_2op>, Enc_f5e933 {
let Inst{13-5} = 0b000000000;
let Inst{31-18} = 0b10001001010000;
let hasNewValue = 1;
let opNewValue = 0;
}
def C2_tfrrp : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32),
"$Pd4 = $Rs32",
tc_cfd8378a, TypeS_2op>, Enc_48b75f {
let Inst{13-2} = 0b000000000000;
let Inst{31-21} = 0b10000101010;
}
def C2_vitpack : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Rd32 = vitpack($Ps4,$Pt4)",
tc_4414d8b1, TypeS_2op>, Enc_527412 {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b10001001000000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def C2_vmux : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pu4, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmux($Pu4,$Rss32,$Rtt32)",
tc_b4b5c03a, TypeALU64>, Enc_329361 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010001000;
}
def C2_xor : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Pd4 = xor($Ps4,$Pt4)",
tc_640086b5, TypeCR>, Enc_284ebb {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011010000;
}
def C4_addipc : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = add(pc,#$Ii)",
tc_a813cf9a, TypeCR>, Enc_607661 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0110101001001001;
let hasNewValue = 1;
let opNewValue = 0;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def C4_and_and : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,and($Pt4,$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011000100;
}
def C4_and_andn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,and($Pt4,!$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011100100;
}
def C4_and_or : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,or($Pt4,$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011001100;
}
def C4_and_orn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = and($Ps4,or($Pt4,!$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011101100;
}
def C4_cmplte : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !cmp.gt($Rs32,$Rt32)",
tc_de4df740, TypeALU32_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010010;
let CextOpcode = "C4_cmplte";
let InputType = "reg";
let isCompare = 1;
}
def C4_cmpltei : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = !cmp.gt($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op>, Enc_bd0b33, ImmRegRel {
let Inst{4-2} = 0b100;
let Inst{31-22} = 0b0111010101;
let CextOpcode = "C4_cmplte";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C4_cmplteu : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !cmp.gtu($Rs32,$Rt32)",
tc_de4df740, TypeALU32_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010011;
let CextOpcode = "C4_cmplteu";
let InputType = "reg";
let isCompare = 1;
}
def C4_cmplteui : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Pd4 = !cmp.gtu($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op>, Enc_c0cdde, ImmRegRel {
let Inst{4-2} = 0b100;
let Inst{31-21} = 0b01110101100;
let CextOpcode = "C4_cmplteu";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 0;
}
def C4_cmpneq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !cmp.eq($Rs32,$Rt32)",
tc_de4df740, TypeALU32_3op>, Enc_c2b48e, ImmRegRel {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110010000;
let CextOpcode = "C4_cmpneq";
let InputType = "reg";
let isCommutable = 1;
let isCompare = 1;
}
def C4_cmpneqi : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Pd4 = !cmp.eq($Rs32,#$Ii)",
tc_56f114f4, TypeALU32_2op>, Enc_bd0b33, ImmRegRel {
let Inst{4-2} = 0b100;
let Inst{31-22} = 0b0111010100;
let CextOpcode = "C4_cmpneq";
let InputType = "imm";
let isCompare = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
}
def C4_fastcorner9 : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Pd4 = fastcorner9($Ps4,$Pt4)",
tc_640086b5, TypeCR>, Enc_284ebb {
let Inst{7-2} = 0b100100;
let Inst{13-10} = 0b1000;
let Inst{31-18} = 0b01101011000000;
}
def C4_fastcorner9_not : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4),
"$Pd4 = !fastcorner9($Ps4,$Pt4)",
tc_640086b5, TypeCR>, Enc_284ebb {
let Inst{7-2} = 0b100100;
let Inst{13-10} = 0b1000;
let Inst{31-18} = 0b01101011000100;
}
def C4_nbitsclr : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !bitsclr($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111101;
}
def C4_nbitsclri : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u6_0Imm:$Ii),
"$Pd4 = !bitsclr($Rs32,#$Ii)",
tc_643b4717, TypeS_2op>, Enc_5d6c34 {
let Inst{7-2} = 0b000000;
let Inst{31-21} = 0b10000101101;
}
def C4_nbitsset : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !bitsset($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111011;
}
def C4_or_and : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,and($Pt4,$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011010100;
}
def C4_or_andn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,and($Pt4,!$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011110100;
}
def C4_or_or : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,or($Pt4,$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011011100;
}
def C4_or_orn : HInst<
(outs PredRegs:$Pd4),
(ins PredRegs:$Ps4, PredRegs:$Pt4, PredRegs:$Pu4),
"$Pd4 = or($Ps4,or($Pt4,!$Pu4))",
tc_b31c2e97, TypeCR>, Enc_9ac432 {
let Inst{5-2} = 0b0000;
let Inst{13-10} = 0b0000;
let Inst{31-18} = 0b01101011111100;
}
def F2_conv_d2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_d2df($Rss32)",
tc_3a867367, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000011;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_d2sf : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_d2sf($Rss32)",
tc_3a867367, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2d : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2d($Rss32)",
tc_3a867367, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2d_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2d($Rss32):chop",
tc_3a867367, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2sf : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2sf($Rss32)",
tc_3a867367, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2ud : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2ud($Rss32)",
tc_3a867367, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2ud_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_df2ud($Rss32):chop",
tc_3a867367, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2uw : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2uw($Rss32)",
tc_3a867367, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2uw_chop : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2uw($Rss32):chop",
tc_3a867367, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000101;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2w : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2w($Rss32)",
tc_3a867367, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_df2w_chop : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_df2w($Rss32):chop",
tc_3a867367, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000111;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2d : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2d($Rs32)",
tc_3a867367, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2d_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2d($Rs32):chop",
tc_3a867367, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2df($Rs32)",
tc_3a867367, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2ud : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2ud($Rs32)",
tc_3a867367, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000011;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2ud_chop : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_sf2ud($Rs32):chop",
tc_3a867367, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2uw : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2uw($Rs32)",
tc_3a867367, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2uw_chop : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2uw($Rs32):chop",
tc_3a867367, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001011011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2w : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2w($Rs32)",
tc_3a867367, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_sf2w_chop : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_sf2w($Rs32):chop",
tc_3a867367, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_ud2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = convert_ud2df($Rss32)",
tc_3a867367, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000000111;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_ud2sf : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = convert_ud2sf($Rss32)",
tc_3a867367, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10001000001;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_uw2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_uw2df($Rs32)",
tc_3a867367, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_uw2sf : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_uw2sf($Rs32)",
tc_3a867367, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011001;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_w2df : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = convert_w2df($Rs32)",
tc_3a867367, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000100100;
let isFP = 1;
let Uses = [USR];
}
def F2_conv_w2sf : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = convert_w2sf($Rs32)",
tc_3a867367, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011010;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def F2_dfadd : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = dfadd($Rss32,$Rtt32)",
tc_2f7c551d, TypeM>, Enc_a56825, Requires<[HasV66]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let isFP = 1;
let Uses = [USR];
}
def F2_dfclass : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Pd4 = dfclass($Rss32,#$Ii)",
tc_643b4717, TypeALU64>, Enc_1f19b5 {
let Inst{4-2} = 0b100;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b11011100100;
let isFP = 1;
let Uses = [USR];
}
def F2_dfcmpeq : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.eq($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfcmpge : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.ge($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfcmpgt : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.gt($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfcmpuo : HInst<
(outs PredRegs:$Pd4),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Pd4 = dfcmp.uo($Rss32,$Rtt32)",
tc_85d5d03f, TypeALU64>, Enc_fcf7a7 {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010010111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_dfimm_n : HInst<
(outs DoubleRegs:$Rdd32),
(ins u10_0Imm:$Ii),
"$Rdd32 = dfmake(#$Ii):neg",
tc_9e313203, TypeALU64>, Enc_e6c957 {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101100101;
let prefersSlot3 = 1;
}
def F2_dfimm_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins u10_0Imm:$Ii),
"$Rdd32 = dfmake(#$Ii):pos",
tc_9e313203, TypeALU64>, Enc_e6c957 {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101100100;
let prefersSlot3 = 1;
}
def F2_dfsub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = dfsub($Rss32,$Rtt32)",
tc_2f7c551d, TypeM>, Enc_a56825, Requires<[HasV66]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let isFP = 1;
let Uses = [USR];
}
def F2_sfadd : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfadd($Rs32,$Rt32)",
tc_3b470976, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
let isCommutable = 1;
}
def F2_sfclass : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Pd4 = sfclass($Rs32,#$Ii)",
tc_643b4717, TypeS_2op>, Enc_83ee64 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000101111;
let isFP = 1;
let Uses = [USR];
}
def F2_sfcmpeq : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.eq($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sfcmpge : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.ge($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sfcmpgt : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.gt($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sfcmpuo : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = sfcmp.uo($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111111;
let isFP = 1;
let Uses = [USR];
let isCompare = 1;
}
def F2_sffixupd : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sffixupd($Rs32,$Rt32)",
tc_3b470976, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011110;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
}
def F2_sffixupn : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sffixupn($Rs32,$Rt32)",
tc_3b470976, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011110;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
}
def F2_sffixupr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = sffixupr($Rs32)",
tc_3a867367, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001011101;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
}
def F2_sffma : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += sfmpy($Rs32,$Rt32)",
tc_a58fd5cc, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffma_lib : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += sfmpy($Rs32,$Rt32):lib",
tc_a58fd5cc, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffma_sc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32, PredRegs:$Pu4),
"$Rx32 += sfmpy($Rs32,$Rt32,$Pu4):scale",
tc_4560740b, TypeM>, Enc_437f33 {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111011;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffms : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= sfmpy($Rs32,$Rt32)",
tc_a58fd5cc, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sffms_lib : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= sfmpy($Rs32,$Rt32):lib",
tc_a58fd5cc, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
let Constraints = "$Rx32 = $Rx32in";
}
def F2_sfimm_n : HInst<
(outs IntRegs:$Rd32),
(ins u10_0Imm:$Ii),
"$Rd32 = sfmake(#$Ii):neg",
tc_9e313203, TypeALU64>, Enc_6c9440 {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101011001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def F2_sfimm_p : HInst<
(outs IntRegs:$Rd32),
(ins u10_0Imm:$Ii),
"$Rd32 = sfmake(#$Ii):pos",
tc_9e313203, TypeALU64>, Enc_6c9440 {
let Inst{20-16} = 0b00000;
let Inst{31-22} = 0b1101011000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def F2_sfinvsqrta : HInst<
(outs IntRegs:$Rd32, PredRegs:$Pe4),
(ins IntRegs:$Rs32),
"$Rd32,$Pe4 = sfinvsqrta($Rs32)",
tc_b8bffe55, TypeS_2op>, Enc_890909 {
let Inst{13-7} = 0b0000000;
let Inst{31-21} = 0b10001011111;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let isPredicateLate = 1;
}
def F2_sfmax : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfmax($Rs32,$Rt32)",
tc_88b4f13d, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_sfmin : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfmin($Rs32,$Rt32)",
tc_88b4f13d, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011100;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let prefersSlot3 = 1;
let Uses = [USR];
}
def F2_sfmpy : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfmpy($Rs32,$Rt32)",
tc_3b470976, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011010;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
let isCommutable = 1;
}
def F2_sfrecipa : HInst<
(outs IntRegs:$Rd32, PredRegs:$Pe4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32,$Pe4 = sfrecipa($Rs32,$Rt32)",
tc_2ff964b4, TypeM>, Enc_a94f3b {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011111;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let isPredicateLate = 1;
}
def F2_sfsub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = sfsub($Rs32,$Rt32)",
tc_3b470976, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101011000;
let hasNewValue = 1;
let opNewValue = 0;
let isFP = 1;
let Uses = [USR];
}
def G4_tfrgcpp : HInst<
(outs DoubleRegs:$Rdd32),
(ins GuestRegs64:$Gss32),
"$Rdd32 = $Gss32",
tc_0d8f5752, TypeCR>, Enc_0aa344 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01101000001;
}
def G4_tfrgcrr : HInst<
(outs IntRegs:$Rd32),
(ins GuestRegs:$Gs32),
"$Rd32 = $Gs32",
tc_0d8f5752, TypeCR>, Enc_44271f {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01101010001;
let hasNewValue = 1;
let opNewValue = 0;
}
def G4_tfrgpcp : HInst<
(outs GuestRegs64:$Gdd32),
(ins DoubleRegs:$Rss32),
"$Gdd32 = $Rss32",
tc_bcf98408, TypeCR>, Enc_ed5027 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01100011000;
let hasNewValue = 1;
let opNewValue = 0;
}
def G4_tfrgrcr : HInst<
(outs GuestRegs:$Gd32),
(ins IntRegs:$Rs32),
"$Gd32 = $Rs32",
tc_bcf98408, TypeCR>, Enc_621fba {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b01100010000;
let hasNewValue = 1;
let opNewValue = 0;
}
def J2_call : HInst<
(outs),
(ins a30_2Imm:$Ii),
"call $Ii",
tc_4ae7b58b, TypeJ>, Enc_81ac1d, PredRel {
let Inst{0-0} = 0b0;
let Inst{31-25} = 0b0101101;
let isCall = 1;
let prefersSlot3 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let BaseOpcode = "J2_call";
let isPredicable = 1;
let hasSideEffects = 1;
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 24;
let opExtentAlign = 2;
}
def J2_callf : HInst<
(outs),
(ins PredRegs:$Pu4, a30_2Imm:$Ii),
"if (!$Pu4) call $Ii",
tc_1d81e60e, TypeJ>, Enc_daea09, PredRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isCall = 1;
let prefersSlot3 = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let BaseOpcode = "J2_call";
let hasSideEffects = 1;
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_callr : HInst<
(outs),
(ins IntRegs:$Rs32),
"callr $Rs32",
tc_3bd75825, TypeJ>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010000101;
let isCall = 1;
let prefersSlot3 = 1;
let cofMax1 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let hasSideEffects = 1;
}
def J2_callrf : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) callr $Rs32",
tc_1ad90acd, TypeJ>, Enc_88d4d9 {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isCall = 1;
let prefersSlot3 = 1;
let cofMax1 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let hasSideEffects = 1;
let isTaken = Inst{12};
}
def J2_callrt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) callr $Rs32",
tc_1ad90acd, TypeJ>, Enc_88d4d9 {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010001000;
let isPredicated = 1;
let isCall = 1;
let prefersSlot3 = 1;
let cofMax1 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let hasSideEffects = 1;
let isTaken = Inst{12};
}
def J2_callt : HInst<
(outs),
(ins PredRegs:$Pu4, a30_2Imm:$Ii),
"if ($Pu4) call $Ii",
tc_1d81e60e, TypeJ>, Enc_daea09, PredRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011101;
let isPredicated = 1;
let isCall = 1;
let prefersSlot3 = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [R29];
let Defs = [PC, R31];
let BaseOpcode = "J2_call";
let hasSideEffects = 1;
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_endloop0 : HInst<
(outs),
(ins),
"endloop0",
tc_1b6f7cec, TypeJ> {
let Uses = [LC0, SA0];
let Defs = [LC0, P3, PC, USR];
let isBranch = 1;
let isTerminator = 1;
let isPseudo = 1;
}
def J2_endloop01 : HInst<
(outs),
(ins),
"endloop01",
tc_1b6f7cec, TypeJ> {
let Uses = [LC0, LC1, SA0, SA1];
let Defs = [LC0, LC1, P3, PC, USR];
let isPseudo = 1;
}
def J2_endloop1 : HInst<
(outs),
(ins),
"endloop1",
tc_1b6f7cec, TypeJ> {
let Uses = [LC1, SA1];
let Defs = [LC1, PC];
let isBranch = 1;
let isTerminator = 1;
let isPseudo = 1;
}
def J2_jump : HInst<
(outs),
(ins b30_2Imm:$Ii),
"jump $Ii",
tc_ae53734a, TypeJ>, Enc_81ac1d, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{31-25} = 0b0101100;
let isTerminator = 1;
let isBranch = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isBarrier = 1;
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 24;
let opExtentAlign = 2;
}
def J2_jumpf : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4) jump:nt $Ii",
tc_db2bce9c, TypeJ>, Enc_daea09, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpf_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, b15_2Imm:$Ii),
"if (!$Pu4) jump $Ii",
tc_db2bce9c, TypeMAPPING>, Requires<[HasV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumpfnew : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4.new) jump:nt $Ii",
tc_20cdee80, TypeJ>, Enc_daea09, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b010;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpfnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4.new) jump:t $Ii",
tc_20cdee80, TypeJ>, Enc_daea09, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b110;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpfpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if (!$Pu4) jump:t $Ii",
tc_cd374165, TypeJ>, Enc_daea09, Requires<[HasV60]>, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b100;
let Inst{21-21} = 0b1;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpr : HInst<
(outs),
(ins IntRegs:$Rs32),
"jumpr $Rs32",
tc_d5b7b0c1, TypeJ>, Enc_ecbcc8, PredNewRel {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010010100;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isBarrier = 1;
let isPredicable = 1;
}
def J2_jumprf : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) jumpr:nt $Rs32",
tc_85c9c08f, TypeJ>, Enc_88d4d9, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprf_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) jumpr $Rs32",
tc_85c9c08f, TypeMAPPING>, Requires<[HasV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumprfnew : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) jumpr:nt $Rs32",
tc_b51dc29a, TypeJ>, Enc_88d4d9, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0010;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprfnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4.new) jumpr:t $Rs32",
tc_b51dc29a, TypeJ>, Enc_88d4d9, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0110;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprfpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if (!$Pu4) jumpr:t $Rs32",
tc_e78647bd, TypeJ>, Enc_88d4d9, Requires<[HasV60]>, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0100;
let Inst{31-21} = 0b01010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprgtez : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32>=#0) jump:nt $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000101;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprgtezpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32>=#0) jump:t $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000101;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprltez : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32<=#0) jump:nt $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000111;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprltezpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32<=#0) jump:t $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000111;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprnz : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32==#0) jump:nt $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprnzpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32==#0) jump:t $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) jumpr:nt $Rs32",
tc_85c9c08f, TypeJ>, Enc_88d4d9, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprt_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) jumpr $Rs32",
tc_85c9c08f, TypeMAPPING>, Requires<[HasV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumprtnew : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) jumpr:nt $Rs32",
tc_b51dc29a, TypeJ>, Enc_88d4d9, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0010;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprtnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4.new) jumpr:t $Rs32",
tc_b51dc29a, TypeJ>, Enc_88d4d9, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0110;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprtpt : HInst<
(outs),
(ins PredRegs:$Pu4, IntRegs:$Rs32),
"if ($Pu4) jumpr:t $Rs32",
tc_e78647bd, TypeJ>, Enc_88d4d9, Requires<[HasV60]>, PredNewRel {
let Inst{7-0} = 0b00000000;
let Inst{13-10} = 0b0100;
let Inst{31-21} = 0b01010011010;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "reg";
let BaseOpcode = "J2_jumpr";
let isTaken = Inst{12};
}
def J2_jumprz : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32!=#0) jump:nt $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b0;
let Inst{31-22} = 0b0110000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumprzpt : HInst<
(outs),
(ins IntRegs:$Rs32, b13_2Imm:$Ii),
"if ($Rs32!=#0) jump:t $Ii",
tc_d9d43ecb, TypeCR>, Enc_0fa531 {
let Inst{0-0} = 0b0;
let Inst{12-12} = 0b1;
let Inst{31-22} = 0b0110000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isTaken = Inst{12};
}
def J2_jumpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4) jump:nt $Ii",
tc_db2bce9c, TypeJ>, Enc_daea09, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b000;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumpt_nopred_map : HInst<
(outs),
(ins PredRegs:$Pu4, b15_2Imm:$Ii),
"if ($Pu4) jump $Ii",
tc_db2bce9c, TypeMAPPING>, Requires<[HasV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J2_jumptnew : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4.new) jump:nt $Ii",
tc_20cdee80, TypeJ>, Enc_daea09, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b010;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumptnewpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4.new) jump:t $Ii",
tc_20cdee80, TypeJ>, Enc_daea09, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b110;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_jumptpt : HInst<
(outs),
(ins PredRegs:$Pu4, b30_2Imm:$Ii),
"if ($Pu4) jump:t $Ii",
tc_cd374165, TypeJ>, Enc_daea09, Requires<[HasV60]>, PredNewRel {
let Inst{0-0} = 0b0;
let Inst{12-10} = 0b100;
let Inst{21-21} = 0b0;
let Inst{31-24} = 0b01011100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let InputType = "imm";
let BaseOpcode = "J2_jump";
let isTaken = Inst{12};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 17;
let opExtentAlign = 2;
}
def J2_loop0i : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"loop0($Ii,#$II)",
tc_a9d88b22, TypeCR>, Enc_4dc228 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001000;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_loop0r : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"loop0($Ii,$Rs32)",
tc_df3319ed, TypeCR>, Enc_864a5a {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000000;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_loop1i : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"loop1($Ii,#$II)",
tc_a9d88b22, TypeCR>, Enc_4dc228 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001001;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC1, SA1];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_loop1r : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"loop1($Ii,$Rs32)",
tc_df3319ed, TypeCR>, Enc_864a5a {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000001;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC1, SA1];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_pause : HInst<
(outs),
(ins u8_0Imm:$Ii),
"pause(#$Ii)",
tc_8d9d0154, TypeJ>, Enc_a51a9a {
let Inst{1-0} = 0b00;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0101010001000000;
let isSolo = 1;
}
def J2_ploop1si : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"p3 = sp1loop0($Ii,#$II)",
tc_1c4528a2, TypeCR>, Enc_4dc228 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001101;
let isPredicateLate = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop1sr : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"p3 = sp1loop0($Ii,$Rs32)",
tc_32779c6f, TypeCR>, Enc_864a5a {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000101;
let isPredicateLate = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop2si : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"p3 = sp2loop0($Ii,#$II)",
tc_1c4528a2, TypeCR>, Enc_4dc228 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001110;
let isPredicateLate = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop2sr : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"p3 = sp2loop0($Ii,$Rs32)",
tc_32779c6f, TypeCR>, Enc_864a5a {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000110;
let isPredicateLate = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop3si : HInst<
(outs),
(ins b30_2Imm:$Ii, u10_0Imm:$II),
"p3 = sp3loop0($Ii,#$II)",
tc_1c4528a2, TypeCR>, Enc_4dc228 {
let Inst{2-2} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01101001111;
let isPredicateLate = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_ploop3sr : HInst<
(outs),
(ins b30_2Imm:$Ii, IntRegs:$Rs32),
"p3 = sp3loop0($Ii,$Rs32)",
tc_32779c6f, TypeCR>, Enc_864a5a {
let Inst{2-0} = 0b000;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01100000111;
let isPredicateLate = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let Defs = [LC0, P3, SA0, USR];
let isExtendable = 1;
let opExtendable = 0;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 2;
}
def J2_trap0 : HInst<
(outs),
(ins u8_0Imm:$Ii),
"trap0(#$Ii)",
tc_fc3999b4, TypeJ>, Enc_a51a9a {
let Inst{1-0} = 0b00;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0101010000000000;
let isSolo = 1;
let hasSideEffects = 1;
}
def J2_trap1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, u8_0Imm:$Ii),
"trap1($Rx32,#$Ii)",
tc_b9e09e03, TypeJ>, Enc_33f8ba {
let Inst{1-0} = 0b00;
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01010100100;
let hasNewValue = 1;
let opNewValue = 0;
let isSolo = 1;
let Uses = [GOSP];
let Defs = [GOSP, PC];
let hasSideEffects = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def J2_trap1_noregmap : HInst<
(outs),
(ins u8_0Imm:$Ii),
"trap1(#$Ii)",
tc_b9e09e03, TypeMAPPING> {
let hasSideEffects = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def J4_cmpeq_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,$Rt32)) jump:nt $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,$Rt32)) jump:t $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (!p0.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (!p0.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (!p1.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (!p1.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,$Rt32)) jump:nt $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,$Rt32)) jump:t $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeq_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (p0.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,$Rt16); if (p0.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (p1.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeq_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,$Rt16); if (p1.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$II)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$II)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (!p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (!p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (!p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (!p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$II)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$II)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqi";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqi_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$II); if (p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqi_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$II); if (p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$n1)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_e90a15, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.eq($Ns8.new,#$n1)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_5a18b3, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (!p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_1de724, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (!p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14640c, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (!p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_668704, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (!p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_800e04, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$n1)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_4aca3a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.eq($Ns8.new,#$n1)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_f7ea77, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpeqn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpeqn1_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_405228, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.eq($Rs16,#$n1); if (p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_3a2484, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpeqn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_736575, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpeqn1_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.eq($Rs16,#$n1); if (p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_8e583a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpeqn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,$Rt32)) jump:nt $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,$Rt32)) jump:t $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (!p0.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (!p0.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (!p1.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (!p1.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,$Rt32)) jump:nt $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,$Rt32)) jump:t $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgt_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (p0.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,$Rt16); if (p0.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtp0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (p1.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgt_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,$Rt16); if (p1.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtp1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$II)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$II)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (!p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (!p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (!p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (!p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$II)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$II)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgti_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$II); if (p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgti_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$II); if (p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$n1)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_3694bd, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (!cmp.gt($Ns8.new,#$n1)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_a6853f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (!p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_a42857, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (!p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_f6fe0b, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (!p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_3e3989, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (!p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_b909d2, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$n1)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_f82302, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, n1Const:$n1, b30_2Imm:$Ii),
"if (cmp.gt($Ns8.new,#$n1)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_6413b6, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010011010;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtn1r";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtn1_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_b78edd, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p0 = cmp.gt($Rs16,#$n1); if (p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_041d7b, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtn1p0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_b1e1fb, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000001;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtn1_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, n1Const:$n1, b30_2Imm:$Ii),
"p1 = cmp.gt($Rs16,#$n1); if (p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_178717, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100001;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtn1p1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,$Rt32)) jump:nt $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,$Rt32)) jump:t $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (!p0.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (!p0.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (!p1.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (!p1.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,$Rt32)) jump:nt $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, IntRegs:$Rt32, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,$Rt32)) jump:t $Ii",
tc_9bfd761f, TypeNCJ>, Enc_c9a18e, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtu_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (p0.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,$Rt16); if (p0.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b10;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtup0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (p1.new) jump:nt $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtu_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, GeneralSubRegs:$Rt16, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,$Rt16); if (p1.new) jump:t $Ii",
tc_56336eb0, TypeCJ>, Enc_6a5972, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b11;
let Inst{31-22} = 0b0001010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtup1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,#$II)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (!cmp.gtu($Ns8.new,#$II)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (!p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (!p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (!p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (!p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,#$II)) jump:nt $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, u5_0Imm:$II, b30_2Imm:$Ii),
"if (cmp.gtu($Ns8.new,#$II)) jump:t $Ii",
tc_bd8382d1, TypeNCJ>, Enc_eafd18, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpgtuir";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_cmpgtui_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (p0.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p0 = cmp.gtu($Rs16,#$II); if (p0.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001000100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let BaseOpcode = "J4_cmpgtuip0";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (p1.new) jump:nt $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-22} = 0b0001001100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmpgtui_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u5_0Imm:$II, b30_2Imm:$Ii),
"p1 = cmp.gtu($Rs16,#$II); if (p1.new) jump:t $Ii",
tc_3d495a39, TypeCJ>, Enc_14d27a, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-22} = 0b0001001100;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let BaseOpcode = "J4_cmpgtuip1";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_cmplt_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gt($Rt32,$Ns8.new)) jump:nt $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmplt_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gt($Rt32,$Ns8.new)) jump:t $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmplt_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gt($Rt32,$Ns8.new)) jump:nt $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmplt_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gt($Rt32,$Ns8.new)) jump:t $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltr";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gtu($Rt32,$Ns8.new)) jump:nt $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!cmp.gtu($Rt32,$Ns8.new)) jump:t $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gtu($Rt32,$Ns8.new)) jump:nt $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b0;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_cmpltu_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Rt32, IntRegs:$Ns8, b30_2Imm:$Ii),
"if (cmp.gtu($Rt32,$Ns8.new)) jump:t $Ii",
tc_b343892a, TypeNCJ>, Enc_5de85f, PredRel {
let Inst{0-0} = 0b0;
let Inst{13-13} = 0b1;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010001000;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let BaseOpcode = "J4_cmpltur";
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 1;
}
def J4_hintjumpr : HInst<
(outs),
(ins IntRegs:$Rs32),
"hintjr($Rs32)",
tc_d5b7b0c1, TypeJ>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010010101;
let isTerminator = 1;
let isIndirectBranch = 1;
let isBranch = 1;
let cofMax1 = 1;
}
def J4_jumpseti : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u6_0Imm:$II, b30_2Imm:$Ii),
"$Rd16 = #$II ; jump $Ii",
tc_0663f615, TypeCJ>, Enc_9e4c3f {
let Inst{0-0} = 0b0;
let Inst{31-22} = 0b0001011000;
let hasNewValue = 1;
let opNewValue = 0;
let isTerminator = 1;
let isBranch = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_jumpsetr : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"$Rd16 = $Rs16 ; jump $Ii",
tc_0663f615, TypeCJ>, Enc_66bce1 {
let Inst{0-0} = 0b0;
let Inst{13-12} = 0b00;
let Inst{31-22} = 0b0001011100;
let hasNewValue = 1;
let opNewValue = 0;
let isTerminator = 1;
let isBranch = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Defs = [PC];
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_f_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!tstbit($Ns8.new,#0)) jump:nt $Ii",
tc_8c945be0, TypeNCJ>, Enc_69d63b {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_f_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (!tstbit($Ns8.new,#0)) jump:t $Ii",
tc_8c945be0, TypeNCJ>, Enc_69d63b {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_fp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (!p0.new) jump:nt $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_fp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (!p0.new) jump:t $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_fp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (!p1.new) jump:nt $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_fp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (!p1.new) jump:t $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_t_jumpnv_nt : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (tstbit($Ns8.new,#0)) jump:nt $Ii",
tc_8c945be0, TypeNCJ>, Enc_69d63b {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_t_jumpnv_t : HInst<
(outs),
(ins IntRegs:$Ns8, b30_2Imm:$Ii),
"if (tstbit($Ns8.new,#0)) jump:t $Ii",
tc_8c945be0, TypeNCJ>, Enc_69d63b {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100000;
let Inst{19-19} = 0b0;
let Inst{31-22} = 0b0010010110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isNewValue = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let Defs = [PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
let opNewValue = 0;
}
def J4_tstbit0_tp0_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (p0.new) jump:nt $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_tp0_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p0 = tstbit($Rs16,#0); if (p0.new) jump:t $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001000110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P0];
let Defs = [P0, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_tp1_jump_nt : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (p1.new) jump:nt $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b000011;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def J4_tstbit0_tp1_jump_t : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, b30_2Imm:$Ii),
"p1 = tstbit($Rs16,#0); if (p1.new) jump:t $Ii",
tc_2332b92e, TypeCJ>, Enc_ad1c74 {
let Inst{0-0} = 0b0;
let Inst{13-8} = 0b100011;
let Inst{31-22} = 0b0001001110;
let isPredicated = 1;
let isTerminator = 1;
let isBranch = 1;
let isPredicatedNew = 1;
let cofRelax1 = 1;
let cofRelax2 = 1;
let cofMax1 = 1;
let Uses = [P1];
let Defs = [P1, PC];
let isTaken = Inst{13};
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 2;
}
def L2_deallocframe : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = deallocframe($Rs32):raw",
tc_15aa71c5, TypeLD>, Enc_3a3d62 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10010000000;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [FRAMEKEY];
let Defs = [R29];
}
def L2_loadalignb_io : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Ryy32 = memb_fifo($Rs32+#$Ii)",
tc_5ef37dc4, TypeLD>, Enc_a27588 {
let Inst{24-21} = 0b0100;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadalignb_pbr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++$Mu2:brev)",
tc_3c76b0ff, TypeLD>, Enc_1f5d8f {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pci : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++#$Ii:circ($Mu2))",
tc_785f65a7, TypeLD>, Enc_74aef2 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pcr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++I:circ($Mu2))",
tc_3c76b0ff, TypeLD>, Enc_1f5d8f {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pi : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_0Imm:$Ii),
"$Ryy32 = memb_fifo($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_6b197f {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_pr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memb_fifo($Rx32++$Mu2)",
tc_3c76b0ff, TypeLD>, Enc_1f5d8f {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100100;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignb_zomap : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32),
"$Ryy32 = memb_fifo($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadalignh_io : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32, s31_1Imm:$Ii),
"$Ryy32 = memh_fifo($Rs32+#$Ii)",
tc_5ef37dc4, TypeLD>, Enc_5cd7e9 {
let Inst{24-21} = 0b0010;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadalignh_pbr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++$Mu2:brev)",
tc_3c76b0ff, TypeLD>, Enc_1f5d8f {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pci : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++#$Ii:circ($Mu2))",
tc_785f65a7, TypeLD>, Enc_9e2e1c {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pcr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++I:circ($Mu2))",
tc_3c76b0ff, TypeLD>, Enc_1f5d8f {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pi : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Ryy32 = memh_fifo($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_bd1cbc {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_pr : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Rx32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rx32in, ModRegs:$Mu2),
"$Ryy32 = memh_fifo($Rx32++$Mu2)",
tc_3c76b0ff, TypeLD>, Enc_1f5d8f {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Ryy32 = $Ryy32in, $Rx32 = $Rx32in";
}
def L2_loadalignh_zomap : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rs32),
"$Ryy32 = memh_fifo($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L2_loadbsw2_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = membh($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_de0214 {
let Inst{24-21} = 0b0001;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadbsw2_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_e83554 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = membh($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_152467 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = membh($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw2_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = membh($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadbsw4_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s30_2Imm:$Ii),
"$Rdd32 = membh($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_2d7491 {
let Inst{24-21} = 0b0111;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def L2_loadbsw4_pbr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pci : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_70b24b {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pcr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii),
"$Rdd32 = membh($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_71f1b4 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_pr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = membh($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100111;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbsw4_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = membh($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadbzw2_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = memubh($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_de0214 {
let Inst{24-21} = 0b0011;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadbzw2_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_e83554 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = memubh($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_152467 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memubh($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw2_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memubh($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadbzw4_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s30_2Imm:$Ii),
"$Rdd32 = memubh($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_2d7491 {
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def L2_loadbzw4_pbr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011110101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pci : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_70b24b {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011000101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pcr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011000101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii),
"$Rdd32 = memubh($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_71f1b4 {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011010101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_pr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memubh($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011100101;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadbzw4_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = memubh($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrb_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = memb($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_211aaa, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
}
def L2_loadrb_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_e0a47a {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii),
"$Rd32 = memb($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_222336, PredNewRel, PostInc_BaseImm {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memb($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrb_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memb($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrbgp : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memb(gp+#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_25bef0, AddrModeRel {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrb_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def L2_loadrd_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, s29_3Imm:$Ii),
"$Rdd32 = memd($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_fa3ba4, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 14;
let opExtentAlign = 3;
}
def L2_loadrd_pbr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pci : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_b05839 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pcr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii),
"$Rdd32 = memd($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_5bdd42, PredNewRel, PostInc_BaseImm {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_pr : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rdd32 = memd($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_7eee72 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrd_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = memd($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrdgp : HInst<
(outs DoubleRegs:$Rdd32),
(ins u29_3Imm:$Ii),
"$Rdd32 = memd(gp+#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_509701, AddrModeRel {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b01001;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrd_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def L2_loadrh_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = memh($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_de0214, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadrh_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_e83554 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = memh($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_152467, PredNewRel, PostInc_BaseImm {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memh($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrh_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memh($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrhgp : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memh(gp+#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_8df4be, AddrModeRel {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrh_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def L2_loadri_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s30_2Imm:$Ii),
"$Rd32 = memw($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_2a3787, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def L2_loadri_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_27fd0e {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii),
"$Rd32 = memw($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_3d920a, PredNewRel, PostInc_BaseImm {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memw($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadri_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memw($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrigp : HInst<
(outs IntRegs:$Rd32),
(ins u30_2Imm:$Ii),
"$Rd32 = memw(gp+#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_4f4ed7, AddrModeRel {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = WordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadri_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def L2_loadrub_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rd32 = memub($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_211aaa, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1001;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
}
def L2_loadrub_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_e0a47a {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii),
"$Rd32 = memub($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_222336, PredNewRel, PostInc_BaseImm {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memub($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadrub_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memub($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadrubgp : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memub(gp+#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_25bef0, AddrModeRel {
let Inst{24-21} = 0b1001;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = ByteAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadrub_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def L2_loadruh_io : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s31_1Imm:$Ii),
"$Rd32 = memuh($Rs32+#$Ii)",
tc_17e0d2cd, TypeLD>, Enc_de0214, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def L2_loadruh_pbr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++$Mu2:brev)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011111011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pci : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++#$Ii:circ($Mu2))",
tc_e93a3d71, TypeLD>, Enc_e83554 {
let Inst{12-9} = 0b0000;
let Inst{31-21} = 0b10011001011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pcr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++I:circ($Mu2))",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b10011001011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii),
"$Rd32 = memuh($Rx32++#$Ii)",
tc_44d3da28, TypeLD>, Enc_152467, PredNewRel, PostInc_BaseImm {
let Inst{13-9} = 0b00000;
let Inst{31-21} = 0b10011011011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_pr : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Rd32 = memuh($Rx32++$Mu2)",
tc_44d3da28, TypeLD>, Enc_74d4e5 {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b10011101011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def L2_loadruh_zomap : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memuh($Rs32)",
tc_17e0d2cd, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_loadruhgp : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memuh(gp+#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_8df4be, AddrModeRel {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let Uses = [GP];
let BaseOpcode = "L4_loadruh_abs";
let isPredicable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def L2_loadw_locked : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = memw_locked($Rs32)",
tc_b43e7930, TypeLD>, Enc_5e2823 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10010010000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = WordAccess;
let mayLoad = 1;
let isSoloAX = 1;
}
def L2_ploadrbf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memb($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memb($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memb($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrbfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memb($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memb($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memb($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrbt_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memb($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbt_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4) $Rd32 = memb($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbt_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memb($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrbtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memb($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L2_loadrb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrbtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memb($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrb_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrbtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memb($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdf_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if (!$Pt4) $Rdd32 = memd($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_acd6ed, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdf_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if (!$Pt4) $Rdd32 = memd($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_9d1247, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdf_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rdd32 = memd($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdfnew_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if (!$Pt4.new) $Rdd32 = memd($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_acd6ed, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdfnew_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if (!$Pt4.new) $Rdd32 = memd($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_9d1247, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdfnew_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rdd32 = memd($Rs32)",
tc_44d3da28, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdt_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if ($Pt4) $Rdd32 = memd($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_acd6ed, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdt_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if ($Pt4) $Rdd32 = memd($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_9d1247, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdt_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rdd32 = memd($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrdtnew_io : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u29_3Imm:$Ii),
"if ($Pt4.new) $Rdd32 = memd($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_acd6ed, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L2_loadrd_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def L2_ploadrdtnew_pi : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_3Imm:$Ii),
"if ($Pt4.new) $Rdd32 = memd($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_9d1247, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrdtnew_zomap : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rdd32 = memd($Rs32)",
tc_44d3da28, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrhf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memh($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrhf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memh($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrhf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memh($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrhfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memh($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrhfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memh($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrhfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memh($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrht_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4) $Rd32 = memh($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrht_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4) $Rd32 = memh($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrht_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memh($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrhtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memh($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L2_loadrh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadrhtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memh($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrhtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memh($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrif_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if (!$Pt4) $Rd32 = memw($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_f82eaf, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadrif_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if (!$Pt4) $Rd32 = memw($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_b97f71, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrif_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memw($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrifnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memw($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_f82eaf, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadrifnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memw($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_b97f71, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrifnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memw($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrit_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if ($Pt4) $Rd32 = memw($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_f82eaf, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadrit_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if ($Pt4) $Rd32 = memw($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_b97f71, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrit_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memw($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadritnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u30_2Imm:$Ii),
"if ($Pt4.new) $Rd32 = memw($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_f82eaf, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L2_loadri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L2_ploadritnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_2Imm:$Ii),
"if ($Pt4.new) $Rd32 = memw($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_b97f71, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadri_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadritnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memw($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memub($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memub($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memub($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memub($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memub($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memub($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubt_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memub($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubt_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4) $Rd32 = memub($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubt_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memub($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadrubtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memub($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a21d47, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L2_loadrub_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L2_ploadrubtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memub($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_f4413a, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadrub_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadrubtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memub($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruhf_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memuh($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000101011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruhf_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4) $Rd32 = memuh($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruhf_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4) $Rd32 = memuh($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruhfnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memuh($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruhfnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memuh($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruhfnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if (!$Pt4.new) $Rd32 = memuh($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruht_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4) $Rd32 = memuh($Rs32+#$Ii)",
tc_5ef37dc4, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000001011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruht_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4) $Rd32 = memuh($Rx32++#$Ii)",
tc_3c76b0ff, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruht_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4) $Rd32 = memuh($Rs32)",
tc_5ef37dc4, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L2_ploadruhtnew_io : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32, u31_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memuh($Rs32+#$Ii)",
tc_44d3da28, TypeV2LDST>, Enc_a198f6, AddrModeRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b01000011011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L2_loadruh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L2_ploadruhtnew_pi : HInst<
(outs IntRegs:$Rd32, IntRegs:$Rx32),
(ins PredRegs:$Pt4, IntRegs:$Rx32in, s4_1Imm:$Ii),
"if ($Pt4.new) $Rd32 = memuh($Rx32++#$Ii)",
tc_e9f3243f, TypeLD>, Enc_733b27, PredNewRel {
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011011011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let BaseOpcode = "L2_loadruh_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def L2_ploadruhtnew_zomap : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, IntRegs:$Rs32),
"if ($Pt4.new) $Rd32 = memuh($Rs32)",
tc_44d3da28, TypeMAPPING> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_add_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) += $Rt32",
tc_7186d325, TypeV4LDST>, Enc_d44e31 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_add_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) += $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_add_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) += $Rt32",
tc_7186d325, TypeV4LDST>, Enc_163a3c {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_add_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) += $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_add_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) += $Rt32",
tc_7186d325, TypeV4LDST>, Enc_226535 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_add_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) += $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_and_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) &= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_d44e31 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_and_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) &= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_and_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) &= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_163a3c {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_and_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) &= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_and_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) &= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_226535 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_and_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) &= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iadd_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) += #$II",
tc_096199d3, TypeV4LDST>, Enc_46c951 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_iadd_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) += #$II",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iadd_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) += #$II",
tc_096199d3, TypeV4LDST>, Enc_e66a97 {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_iadd_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) += #$II",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iadd_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) += #$II",
tc_096199d3, TypeV4LDST>, Enc_84b2cd {
let Inst{6-5} = 0b00;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_iadd_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) += #$II",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iand_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) = clrbit(#$II)",
tc_096199d3, TypeV4LDST>, Enc_46c951 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_iand_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) = clrbit(#$II)",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iand_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) = clrbit(#$II)",
tc_096199d3, TypeV4LDST>, Enc_e66a97 {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_iand_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) = clrbit(#$II)",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_iand_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) = clrbit(#$II)",
tc_096199d3, TypeV4LDST>, Enc_84b2cd {
let Inst{6-5} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_iand_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) = clrbit(#$II)",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ior_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) = setbit(#$II)",
tc_096199d3, TypeV4LDST>, Enc_46c951 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ior_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) = setbit(#$II)",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ior_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) = setbit(#$II)",
tc_096199d3, TypeV4LDST>, Enc_e66a97 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_ior_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) = setbit(#$II)",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ior_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) = setbit(#$II)",
tc_096199d3, TypeV4LDST>, Enc_84b2cd {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_ior_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) = setbit(#$II)",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_isub_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, u5_0Imm:$II),
"memb($Rs32+#$Ii) -= #$II",
tc_096199d3, TypeV4LDST>, Enc_46c951 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_isub_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memb($Rs32) -= #$II",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_isub_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, u5_0Imm:$II),
"memh($Rs32+#$Ii) -= #$II",
tc_096199d3, TypeV4LDST>, Enc_e66a97 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_isub_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memh($Rs32) -= #$II",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_isub_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, u5_0Imm:$II),
"memw($Rs32+#$Ii) -= #$II",
tc_096199d3, TypeV4LDST>, Enc_84b2cd {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111111010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_isub_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, u5_0Imm:$II),
"memw($Rs32) -= #$II",
tc_096199d3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_loadalignb_ap : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Re32),
(ins DoubleRegs:$Ryy32in, u32_0Imm:$II),
"$Ryy32 = memb_fifo($Re32=#$II)",
tc_7a91e76a, TypeLD>, Enc_f394d3 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010100;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadalignb_ur : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Ryy32 = memb_fifo($Rt32<<#$Ii+#$II)",
tc_a5d4aeec, TypeLD>, Enc_04c959 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100100;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 4;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadalignh_ap : HInst<
(outs DoubleRegs:$Ryy32, IntRegs:$Re32),
(ins DoubleRegs:$Ryy32in, u32_0Imm:$II),
"$Ryy32 = memh_fifo($Re32=#$II)",
tc_7a91e76a, TypeLD>, Enc_f394d3 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010010;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadalignh_ur : HInst<
(outs DoubleRegs:$Ryy32),
(ins DoubleRegs:$Ryy32in, IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Ryy32 = memh_fifo($Rt32<<#$Ii+#$II)",
tc_a5d4aeec, TypeLD>, Enc_04c959 {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100010;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 4;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let Constraints = "$Ryy32 = $Ryy32in";
}
def L4_loadbsw2_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = membh($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_323f2d {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbsw2_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = membh($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_4f677b {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbsw4_ap : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rdd32 = membh($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_7fa7f6 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010111;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbsw4_ur : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = membh($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_6185fe {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100111;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw2_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memubh($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_323f2d {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw2_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memubh($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_4f677b {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw4_ap : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rdd32 = memubh($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_7fa7f6 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011010101;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadbzw4_ur : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = memubh($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_6185fe {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011100101;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadd_locked : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = memd_locked($Rs32)",
tc_b43e7930, TypeLD>, Enc_3a3d62 {
let Inst{13-5} = 0b010000000;
let Inst{31-21} = 0b10010010000;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let isSoloAX = 1;
}
def L4_loadrb_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memb($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_323f2d {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrb_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memb($Rs32+$Rt32<<#$Ii)",
tc_bf061958, TypeLD>, Enc_da664b, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
let isPredicable = 1;
}
def L4_loadrb_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memb($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_4f677b, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrb";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrd_ap : HInst<
(outs DoubleRegs:$Rdd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rdd32 = memd($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_7fa7f6 {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011110;
let addrMode = AbsoluteSet;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrd_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
tc_bf061958, TypeLD>, Enc_84bff1, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010110;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
let isPredicable = 1;
}
def L4_loadrd_ur : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rdd32 = memd($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_6185fe, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101110;
let addrMode = BaseLongOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrd";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrh_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memh($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_323f2d {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrh_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memh($Rs32+$Rt32<<#$Ii)",
tc_bf061958, TypeLD>, Enc_da664b, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
let isPredicable = 1;
}
def L4_loadrh_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memh($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_4f677b, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrh";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadri_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memw($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_323f2d {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadri_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memw($Rs32+$Rt32<<#$Ii)",
tc_bf061958, TypeLD>, Enc_da664b, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
let isPredicable = 1;
}
def L4_loadri_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memw($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_4f677b, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadri";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrub_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memub($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_323f2d {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadrub_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memub($Rs32+$Rt32<<#$Ii)",
tc_bf061958, TypeLD>, Enc_da664b, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
let isPredicable = 1;
}
def L4_loadrub_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memub($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_4f677b, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrub";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadruh_ap : HInst<
(outs IntRegs:$Rd32, IntRegs:$Re32),
(ins u32_0Imm:$II),
"$Rd32 = memuh($Re32=#$II)",
tc_3b5b7ef9, TypeLD>, Enc_323f2d {
let Inst{7-7} = 0b0;
let Inst{13-12} = 0b01;
let Inst{31-21} = 0b10011011011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_loadruh_rr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
tc_bf061958, TypeLD>, Enc_da664b, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111010011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
let isPredicable = 1;
}
def L4_loadruh_ur : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, u2_0Imm:$Ii, u32_0Imm:$II),
"$Rd32 = memuh($Rt32<<#$Ii+#$II)",
tc_bab0eed9, TypeLD>, Enc_4f677b, AddrModeRel, ImmRegShl {
let Inst{12-12} = 0b1;
let Inst{31-21} = 0b10011101011;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadruh";
let InputType = "imm";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_or_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) |= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_d44e31 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_or_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) |= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_or_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) |= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_163a3c {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_or_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) |= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_or_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) |= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_226535 {
let Inst{6-5} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_or_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) |= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_ploadrbf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memb(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110001000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrbfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memb(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrbt_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memb(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbt_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrbtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memb(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrbtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memb($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110010000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrb";
let InputType = "reg";
let BaseOpcode = "L4_loadrb_rr";
}
def L4_ploadrdf_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rdd32 = memd(#$Ii)",
tc_7646c131, TypeLD>, Enc_2a7b91, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdf_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_98c0b8, AddrModeRel {
let Inst{31-21} = 0b00110001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrdfnew_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rdd32 = memd(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2a7b91, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdfnew_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_98c0b8, AddrModeRel {
let Inst{31-21} = 0b00110011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrdt_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rdd32 = memd(#$Ii)",
tc_7646c131, TypeLD>, Enc_2a7b91, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdt_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_98c0b8, AddrModeRel {
let Inst{31-21} = 0b00110000110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrdtnew_abs : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rdd32 = memd(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2a7b91, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111110;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrdtnew_rr : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rdd32 = memd($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_98c0b8, AddrModeRel {
let Inst{31-21} = 0b00110010110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrd";
let InputType = "reg";
let BaseOpcode = "L4_loadrd_rr";
}
def L4_ploadrhf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memh(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrhf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110001010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrhfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memh(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrhfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrht_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memh(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrht_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110000010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrhtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memh(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrhtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memh($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110010010;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrh";
let InputType = "reg";
let BaseOpcode = "L4_loadrh_rr";
}
def L4_ploadrif_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memw(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrif_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadrifnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memw(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrifnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadrit_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memw(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrit_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadritnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memw(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadritnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memw($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110010100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadri";
let InputType = "reg";
let BaseOpcode = "L4_loadri_rr";
}
def L4_ploadrubf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memub(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110001001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadrubfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memub(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110011001;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadrubt_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memub(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubt_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110000001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadrubtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memub(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadrubtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memub($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110010001;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadrub";
let InputType = "reg";
let BaseOpcode = "L4_loadrub_rr";
}
def L4_ploadruhf_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4) $Rd32 = memuh(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruhf_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110001011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_ploadruhfnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if (!$Pt4.new) $Rd32 = memuh(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b111;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruhfnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if (!$Pv4.new) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_ploadruht_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4) $Rd32 = memuh(#$Ii)",
tc_7646c131, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruht_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
tc_e4b3cb20, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110000011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_ploadruhtnew_abs : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pt4, u32_0Imm:$Ii),
"if ($Pt4.new) $Rd32 = memuh(#$Ii)",
tc_3b5b7ef9, TypeLD>, Enc_2301d6, AddrModeRel {
let Inst{7-5} = 0b100;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10011111011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_ploadruhtnew_rr : HInst<
(outs IntRegs:$Rd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32, u2_0Imm:$Ii),
"if ($Pv4.new) $Rd32 = memuh($Rs32+$Rt32<<#$Ii)",
tc_25a78932, TypeLD>, Enc_2e1979, AddrModeRel {
let Inst{31-21} = 0b00110010011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let CextOpcode = "L2_loadruh";
let InputType = "reg";
let BaseOpcode = "L4_loadruh_rr";
}
def L4_return : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = dealloc_return($Rs32):raw",
tc_675e4897, TypeLD>, Enc_3a3d62, PredNewRel {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10010110000;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY];
let Defs = [PC, R29];
let BaseOpcode = "L4_return";
let isBarrier = 1;
let isPredicable = 1;
let isTaken = 1;
}
def L4_return_f : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32),
"if (!$Pv4) $Rdd32 = dealloc_return($Rs32):raw",
tc_2b8da4c2, TypeLD>, Enc_b7fad3, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1100;
let Inst{31-21} = 0b10010110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY];
let Defs = [PC, R29];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_fnew_pnt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32),
"if (!$Pv4.new) $Rdd32 = dealloc_return($Rs32):nt:raw",
tc_9da59d12, TypeLD>, Enc_b7fad3, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1010;
let Inst{31-21} = 0b10010110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY];
let Defs = [PC, R29];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_fnew_pt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32),
"if (!$Pv4.new) $Rdd32 = dealloc_return($Rs32):t:raw",
tc_9da59d12, TypeLD>, Enc_b7fad3, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b1110;
let Inst{31-21} = 0b10010110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY];
let Defs = [PC, R29];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_map_to_raw_f : HInst<
(outs),
(ins PredRegs:$Pv4),
"if (!$Pv4) dealloc_return",
tc_2b8da4c2, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_return_map_to_raw_fnew_pnt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if (!$Pv4.new) dealloc_return:nt",
tc_9da59d12, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_return_map_to_raw_fnew_pt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if (!$Pv4.new) dealloc_return:t",
tc_9da59d12, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_return_map_to_raw_t : HInst<
(outs),
(ins PredRegs:$Pv4),
"if ($Pv4) dealloc_return",
tc_4d5fa3a1, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_return_map_to_raw_tnew_pnt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if ($Pv4.new) dealloc_return:nt",
tc_e06f432a, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_return_map_to_raw_tnew_pt : HInst<
(outs),
(ins PredRegs:$Pv4),
"if ($Pv4.new) dealloc_return:t",
tc_e06f432a, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_return_t : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32),
"if ($Pv4) $Rdd32 = dealloc_return($Rs32):raw",
tc_2b8da4c2, TypeLD>, Enc_b7fad3, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0100;
let Inst{31-21} = 0b10010110000;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY];
let Defs = [PC, R29];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_tnew_pnt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32),
"if ($Pv4.new) $Rdd32 = dealloc_return($Rs32):nt:raw",
tc_9da59d12, TypeLD>, Enc_b7fad3, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0010;
let Inst{31-21} = 0b10010110000;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY];
let Defs = [PC, R29];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_return_tnew_pt : HInst<
(outs DoubleRegs:$Rdd32),
(ins PredRegs:$Pv4, IntRegs:$Rs32),
"if ($Pv4.new) $Rdd32 = dealloc_return($Rs32):t:raw",
tc_9da59d12, TypeLD>, Enc_b7fad3, PredNewRel {
let Inst{7-5} = 0b000;
let Inst{13-10} = 0b0110;
let Inst{31-21} = 0b10010110000;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY];
let Defs = [PC, R29];
let BaseOpcode = "L4_return";
let isTaken = Inst{12};
}
def L4_sub_memopb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) -= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_d44e31 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def L4_sub_memopb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) -= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_sub_memoph_io : HInst<
(outs),
(ins IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) -= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_163a3c {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def L4_sub_memoph_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) -= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L4_sub_memopw_io : HInst<
(outs),
(ins IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) -= $Rt32",
tc_7186d325, TypeV4LDST>, Enc_226535 {
let Inst{6-5} = 0b01;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00111110010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def L4_sub_memopw_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) -= $Rt32",
tc_7186d325, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L6_deallocframe_map_to_raw : HInst<
(outs),
(ins),
"deallocframe",
tc_15aa71c5, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def L6_memcpy : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32, ModRegs:$Mu2),
"memcpy($Rs32,$Rt32,$Mu2)",
tc_a6b1eca9, TypeLD>, Enc_a75aa6, Requires<[HasV66]> {
let Inst{7-0} = 0b01000000;
let Inst{31-21} = 0b10010010000;
let mayLoad = 1;
let isSolo = 1;
let mayStore = 1;
}
def L6_return_map_to_raw : HInst<
(outs),
(ins),
"dealloc_return",
tc_675e4897, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def M2_acci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += add($Rs32,$Rt32)",
tc_f675fee8, TypeM>, Enc_2ae154, ImmRegRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_acci";
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_accii : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 += add($Rs32,#$Ii)",
tc_f675fee8, TypeM>, Enc_c90aca, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100010000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_acci";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_cmaci_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpyi($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacr_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpyr($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32):sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32):<<1:sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacsc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32*):sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmacsc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += cmpy($Rs32,$Rt32*):<<1:sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cmpyi_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpyi($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
}
def M2_cmpyr_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpyr($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
}
def M2_cmpyrs_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32):rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpyrs_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpyrsc_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32*):rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpyrsc_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = cmpy($Rs32,$Rt32*):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpys_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32):sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpys_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpysc_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32*):sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cmpysc_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = cmpy($Rs32,$Rt32*):<<1:sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_cnacs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32):sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cnacs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32):<<1:sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cnacsc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32*):sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_cnacsc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= cmpy($Rs32,$Rt32*):<<1:sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyss_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyss_nac_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyss_rnd_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32):rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_dpmpyss_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
}
def M2_dpmpyuu_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyuu_nac_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_dpmpyuu_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
}
def M2_hmmpyh_rs1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.h):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_hmmpyh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.h):<<1:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_hmmpyl_rs1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.l):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_hmmpyl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32.l):<<1:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_maci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyi($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_2ae154, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_maci";
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_macsin : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rx32 -= mpyi($Rs32,#$Ii)",
tc_05d3a09b, TypeM>, Enc_c90aca {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100001100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_macsip : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rx32 += mpyi($Rs32,#$Ii)",
tc_05d3a09b, TypeM>, Enc_c90aca, ImmRegRel {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_maci";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mmachs_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmachs_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):<<1:rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmachs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmachs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywoh($Rss32,$Rtt32):<<1:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):<<1:rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacls_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweh($Rss32,$Rtt32):<<1:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):<<1:rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmacuhs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpywouh($Rss32,$Rtt32):<<1:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_rs0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_rs1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):<<1:rnd:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmaculs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyweuh($Rss32,$Rtt32):<<1:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mmpyh_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyh_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywoh($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweh($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyuh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpywouh($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_rs0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_rs1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mmpyul_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyweuh($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mnaci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyi($Rs32,$Rt32)",
tc_bdceeac1, TypeM>, Enc_2ae154, Requires<[HasV66]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.h):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.h,$Rt32.l):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.h):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_acc_sat_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32.l,$Rt32.l):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_nac_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.h):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.h,$Rt32.l):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.h):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l):sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_nac_sat_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32.l,$Rt32.l):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpy_rnd_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1:rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1:rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1:rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_rnd_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1:rnd",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_sat_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.h):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.h,$Rt32.l):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.h):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_sat_rnd_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32.l,$Rt32.l):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpy_up : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_up_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpy_up_s1_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpy($Rs32,$Rt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_mpyd_acc_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_acc_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpy($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_hh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_hh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_hl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_hl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_lh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_lh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_ll_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100000;
let prefersSlot3 = 1;
}
def M2_mpyd_ll_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100100;
let prefersSlot3 = 1;
}
def M2_mpyd_nac_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_nac_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpy($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyd_rnd_hh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h):rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_hh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.h):<<1:rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_hl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l):rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_hl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.h,$Rt32.l):<<1:rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_lh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h):rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_lh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.h):<<1:rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_ll_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l):rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100001;
let prefersSlot3 = 1;
}
def M2_mpyd_rnd_ll_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpy($Rs32.l,$Rt32.l):<<1:rnd",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100101;
let prefersSlot3 = 1;
}
def M2_mpyi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyi($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_5ab2be, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M2_mpyi";
let InputType = "reg";
}
def M2_mpysin : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u8_0Imm:$Ii),
"$Rd32 = -mpyi($Rs32,#$Ii)",
tc_c8ce0b5c, TypeM>, Enc_b8c967 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100000100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpysip : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rd32 = +mpyi($Rs32,#$Ii)",
tc_c8ce0b5c, TypeM>, Enc_b8c967 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100000000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def M2_mpysmi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, m32_0Imm:$Ii),
"$Rd32 = mpyi($Rs32,#$Ii)",
tc_c8ce0b5c, TypeM>, ImmRegRel {
let hasNewValue = 1;
let opNewValue = 0;
let CextOpcode = "M2_mpyi";
let InputType = "imm";
let isPseudo = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 9;
let opExtentAlign = 0;
}
def M2_mpysu_up : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpysu($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_acc_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_acc_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpyu($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_hh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_hh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_hl_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_hl_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.h,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_lh_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_lh_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_ll_s0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_ll_s1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32.l,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyu_nac_hh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_hh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_hl_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_hl_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_lh_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_lh_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_ll_s0 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_nac_ll_s1 : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpyu($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_mpyu_up : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyu($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_mpyud_acc_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_acc_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += mpyu($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_hh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_hh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_hl_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_hl_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.h,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_lh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.h)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_lh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.h):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_ll_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.l)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100010;
let prefersSlot3 = 1;
}
def M2_mpyud_ll_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = mpyu($Rs32.l,$Rt32.l):<<1",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100100110;
let prefersSlot3 = 1;
}
def M2_mpyud_nac_hh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_hh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_hl_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_hl_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.h,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_lh_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.h)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_lh_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.h):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_ll_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.l)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyud_nac_ll_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 -= mpyu($Rs32.l,$Rt32.l):<<1",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100110111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_mpyui : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = mpyui($Rs32,$Rt32)",
tc_bafaade3, TypeM> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def M2_nacci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= add($Rs32,$Rt32)",
tc_f675fee8, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_naccii : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 -= add($Rs32,#$Ii)",
tc_f675fee8, TypeM>, Enc_c90aca {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100010100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def M2_subacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rt32, IntRegs:$Rs32),
"$Rx32 += sub($Rt32,$Rs32)",
tc_f675fee8, TypeM>, Enc_a568d4 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M2_vabsdiffh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffh($Rtt32,$Rss32)",
tc_002cb246, TypeM>, Enc_ea23e4 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
}
def M2_vabsdiffw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffw($Rtt32,$Rss32)",
tc_002cb246, TypeM>, Enc_ea23e4 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
}
def M2_vcmac_s0_sat_i : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vcmpyi($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vcmac_s0_sat_r : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vcmpyr($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vcmpy_s0_sat_i : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyi($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vcmpy_s0_sat_r : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyr($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vcmpy_s1_sat_i : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyi($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vcmpy_s1_sat_r : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vcmpyr($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmacs_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vdmpy($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vdmacs_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vdmpy($Rss32,$Rtt32):<<1:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vdmpyrs_s0 : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vdmpy($Rss32,$Rtt32):rnd:sat",
tc_bafaade3, TypeM>, Enc_d2216a {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmpyrs_s1 : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vdmpy($Rss32,$Rtt32):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_d2216a {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmpys_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vdmpy($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vdmpys_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vdmpy($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmac2 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyh($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2es : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyeh($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2es_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyeh($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2es_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vmpyeh($Rss32,$Rtt32):<<1:sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2s_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyh($Rs32,$Rt32):sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2s_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyh($Rs32,$Rt32):<<1:sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2su_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyhsu($Rs32,$Rt32):sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111011;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmac2su_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpyhsu($Rs32,$Rt32):<<1:sat",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vmpy2es_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyeh($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2es_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vmpyeh($Rss32,$Rtt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyh($Rs32,$Rt32):sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s0pack : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vmpyh($Rs32,$Rt32):rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyh($Rs32,$Rt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2s_s1pack : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = vmpyh($Rs32,$Rt32):<<1:rnd:sat",
tc_bafaade3, TypeM>, Enc_5ab2be {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101101101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2su_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyhsu($Rs32,$Rt32):sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101000;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vmpy2su_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpyhsu($Rs32,$Rt32):<<1:sat",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vraddh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vraddh($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_d2216a {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_vradduh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vradduh($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_d2216a {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M2_vrcmaci_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyi($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmaci_s0c : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyi($Rss32,$Rtt32*)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmacr_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyr($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmacr_s0c : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpyr($Rss32,$Rtt32*)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpyi_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyi($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
}
def M2_vrcmpyi_s0c : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyi($Rss32,$Rtt32*)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def M2_vrcmpyr_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyr($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
}
def M2_vrcmpyr_s0c : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpyr($Rss32,$Rtt32*)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000011;
let prefersSlot3 = 1;
}
def M2_vrcmpys_acc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += vrcmpys($Rss32,$Rt32):<<1:sat",
tc_d773585a, TypeM> {
let isPseudo = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpys_acc_s1_h : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpys($Rss32,$Rtt32):<<1:sat:raw:hi",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpys_acc_s1_l : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrcmpys($Rss32,$Rtt32):<<1:sat:raw:lo",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrcmpys_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vrcmpys($Rss32,$Rt32):<<1:sat",
tc_bafaade3, TypeM> {
let isPseudo = 1;
}
def M2_vrcmpys_s1_h : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpys($Rss32,$Rtt32):<<1:sat:raw:hi",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrcmpys_s1_l : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrcmpys($Rss32,$Rtt32):<<1:sat:raw:lo",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrcmpys_s1rp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = vrcmpys($Rss32,$Rt32):<<1:rnd:sat",
tc_bafaade3, TypeM> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
}
def M2_vrcmpys_s1rp_h : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vrcmpys($Rss32,$Rtt32):<<1:rnd:sat:raw:hi",
tc_bafaade3, TypeM>, Enc_d2216a {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrcmpys_s1rp_l : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = vrcmpys($Rss32,$Rtt32):<<1:rnd:sat:raw:lo",
tc_bafaade3, TypeM>, Enc_d2216a {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101001101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M2_vrmac_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpyh($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M2_vrmpy_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpyh($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000000;
let prefersSlot3 = 1;
}
def M2_xor_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= xor($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= and($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_andn : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= and($Rs32,~$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= or($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_and_xor : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= xor($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_cmpyi_wh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyiwh($Rss32,$Rt32):<<1:rnd:sat",
tc_bafaade3, TypeS_3op>, Enc_3d5b28 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_cmpyi_whc : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyiwh($Rss32,$Rt32*):<<1:rnd:sat",
tc_bafaade3, TypeS_3op>, Enc_3d5b28 {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_cmpyr_wh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyrwh($Rss32,$Rt32):<<1:rnd:sat",
tc_bafaade3, TypeS_3op>, Enc_3d5b28 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_cmpyr_whc : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = cmpyrwh($Rss32,$Rt32*):<<1:rnd:sat",
tc_bafaade3, TypeS_3op>, Enc_3d5b28 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M4_mac_up_s1_sat : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += mpy($Rs32,$Rt32):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_mpyri_addi : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii, IntRegs:$Rs32, u6_0Imm:$II),
"$Rd32 = add(#$Ii,mpyi($Rs32,#$II))",
tc_05d3a09b, TypeALU64>, Enc_322e1b, ImmRegRel {
let Inst{31-24} = 0b11011000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyri_addr";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def M4_mpyri_addr : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Ru32, IntRegs:$Rs32, u32_0Imm:$Ii),
"$Rd32 = add($Ru32,mpyi($Rs32,#$Ii))",
tc_05d3a09b, TypeALU64>, Enc_420cf3, ImmRegRel {
let Inst{31-23} = 0b110111111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyri_addr";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def M4_mpyri_addr_u2 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Ru32, u6_2Imm:$Ii, IntRegs:$Rs32),
"$Rd32 = add($Ru32,mpyi(#$Ii,$Rs32))",
tc_1a2fd869, TypeALU64>, Enc_277737 {
let Inst{31-23} = 0b110111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def M4_mpyrr_addi : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add(#$Ii,mpyi($Rs32,$Rt32))",
tc_d773585a, TypeALU64>, Enc_a7b8e8, ImmRegRel {
let Inst{31-23} = 0b110101110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyrr_addr";
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def M4_mpyrr_addr : HInst<
(outs IntRegs:$Ry32),
(ins IntRegs:$Ru32, IntRegs:$Ry32in, IntRegs:$Rs32),
"$Ry32 = add($Ru32,mpyi($Ry32in,$Rs32))",
tc_d773585a, TypeM>, Enc_7f1a05, ImmRegRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100011000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let CextOpcode = "M4_mpyrr_addr";
let InputType = "reg";
let Constraints = "$Ry32 = $Ry32in";
}
def M4_nac_up_s1_sat : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= mpy($Rs32,$Rt32):<<1:sat",
tc_d773585a, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= and($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_andn : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= and($Rs32,~$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= or($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_or_xor : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= xor($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_pmpyw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = pmpyw($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
}
def M4_pmpyw_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 ^= pmpyw($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vpmpyh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vpmpyh($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101110;
let prefersSlot3 = 1;
}
def M4_vpmpyh_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 ^= vpmpyh($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyeh_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpyweh($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyeh_acc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpyweh($Rss32,$Rtt32):<<1",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyeh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpyweh($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000010;
let prefersSlot3 = 1;
}
def M4_vrmpyeh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpyweh($Rss32,$Rtt32):<<1",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
}
def M4_vrmpyoh_acc_s0 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpywoh($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyoh_acc_s1 : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpywoh($Rss32,$Rtt32):<<1",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010111;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M4_vrmpyoh_s0 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpywoh($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000001;
let prefersSlot3 = 1;
}
def M4_vrmpyoh_s1 : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpywoh($Rss32,$Rtt32):<<1",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
}
def M4_xor_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= and($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_xor_andn : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= and($Rs32,~$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_xor_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 ^= or($Rs32,$Rt32)",
tc_f429765c, TypeM>, Enc_2ae154 {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101111110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "reg";
let Constraints = "$Rx32 = $Rx32in";
}
def M4_xor_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 ^= xor($Rss32,$Rtt32)",
tc_f429765c, TypeS_3op>, Enc_88c16c {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vdmacbsu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vdmpybsu($Rss32,$Rtt32):sat",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010001;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vdmpybsu : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vdmpybsu($Rss32,$Rtt32):sat",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def M5_vmacbsu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpybsu($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vmacbuu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rxx32 += vmpybu($Rs32,$Rt32)",
tc_d773585a, TypeM>, Enc_61f0b0 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100111100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vmpybsu : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpybsu($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101010;
let prefersSlot3 = 1;
}
def M5_vmpybuu : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = vmpybu($Rs32,$Rt32)",
tc_bafaade3, TypeM>, Enc_be32a5 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11100101100;
let prefersSlot3 = 1;
}
def M5_vrmacbsu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpybsu($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vrmacbuu : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 += vrmpybu($Rss32,$Rtt32)",
tc_d773585a, TypeM>, Enc_88c16c {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def M5_vrmpybsu : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpybsu($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000110;
let prefersSlot3 = 1;
}
def M5_vrmpybuu : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vrmpybu($Rss32,$Rtt32)",
tc_bafaade3, TypeM>, Enc_a56825 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000100;
let prefersSlot3 = 1;
}
def M6_vabsdiffb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffb($Rtt32,$Rss32)",
tc_9461ff31, TypeM>, Enc_ea23e4, Requires<[HasV62]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000111;
let prefersSlot3 = 1;
}
def M6_vabsdiffub : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = vabsdiffub($Rtt32,$Rss32)",
tc_9461ff31, TypeM>, Enc_ea23e4, Requires<[HasV62]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11101000101;
let prefersSlot3 = 1;
}
def PS_loadrbabs : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memb(#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_25bef0, AddrModeRel {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrb";
let BaseOpcode = "L4_loadrb_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def PS_loadrdabs : HInst<
(outs DoubleRegs:$Rdd32),
(ins u29_3Imm:$Ii),
"$Rdd32 = memd(#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_509701, AddrModeRel {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrd";
let BaseOpcode = "L4_loadrd_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def PS_loadrhabs : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memh(#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_8df4be, AddrModeRel {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrh";
let BaseOpcode = "L4_loadrh_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_loadriabs : HInst<
(outs IntRegs:$Rd32),
(ins u30_2Imm:$Ii),
"$Rd32 = memw(#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_4f4ed7, AddrModeRel {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = WordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadri";
let BaseOpcode = "L4_loadri_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def PS_loadrubabs : HInst<
(outs IntRegs:$Rd32),
(ins u32_0Imm:$Ii),
"$Rd32 = memub(#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_25bef0, AddrModeRel {
let Inst{24-21} = 0b1001;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = ByteAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadrub";
let BaseOpcode = "L4_loadrub_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def PS_loadruhabs : HInst<
(outs IntRegs:$Rd32),
(ins u31_1Imm:$Ii),
"$Rd32 = memuh(#$Ii)",
tc_c4db48cb, TypeV2LDST>, Enc_8df4be, AddrModeRel {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b01001;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let mayLoad = 1;
let isExtended = 1;
let CextOpcode = "L2_loadruh";
let BaseOpcode = "L4_loadruh_abs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_storerbabs : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Rt32),
"memb(#$Ii) = $Rt32",
tc_0371abea, TypeV2LDST>, Enc_1b64fb, AddrModeRel {
let Inst{24-21} = 0b0000;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def PS_storerbnewabs : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Nt8),
"memb(#$Ii) = $Nt8.new",
tc_5bf126a6, TypeV2LDST>, Enc_ad1831, AddrModeRel {
let Inst{12-11} = 0b00;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
let opNewValue = 1;
}
def PS_storerdabs : HInst<
(outs),
(ins u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd(#$Ii) = $Rtt32",
tc_0371abea, TypeV2LDST>, Enc_5c124a, AddrModeRel {
let Inst{24-21} = 0b0110;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def PS_storerfabs : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(#$Ii) = $Rt32.h",
tc_0371abea, TypeV2LDST>, Enc_fda92c, AddrModeRel {
let Inst{24-21} = 0b0011;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_storerhabs : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(#$Ii) = $Rt32",
tc_0371abea, TypeV2LDST>, Enc_fda92c, AddrModeRel {
let Inst{24-21} = 0b0010;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def PS_storerhnewabs : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Nt8),
"memh(#$Ii) = $Nt8.new",
tc_5bf126a6, TypeV2LDST>, Enc_bc03e5, AddrModeRel {
let Inst{12-11} = 0b01;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
let opNewValue = 1;
}
def PS_storeriabs : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Rt32),
"memw(#$Ii) = $Rt32",
tc_0371abea, TypeV2LDST>, Enc_541f26, AddrModeRel {
let Inst{24-21} = 0b0100;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def PS_storerinewabs : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Nt8),
"memw(#$Ii) = $Nt8.new",
tc_5bf126a6, TypeV2LDST>, Enc_78cbf0, AddrModeRel {
let Inst{12-11} = 0b10;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let DecoderNamespace = "MustExtend";
let isExtended = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
let opNewValue = 1;
}
def S2_addasl_rrri : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32, u3_0Imm:$Ii),
"$Rd32 = addasl($Rt32,$Rs32,#$Ii)",
tc_f675fee8, TypeS_3op>, Enc_47ef61 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_allocframe : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, u11_3Imm:$Ii),
"allocframe($Rx32,#$Ii):raw",
tc_b44ecf75, TypeST>, Enc_22c845 {
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10100000100;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [FRAMEKEY, FRAMELIMIT, R30, R31];
let Defs = [R30];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asl($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_5eac98 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000000000;
}
def S2_asl_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += asl($Rss32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= asl($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= asl($Rss32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= asl($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_p_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 ^= asl($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10000010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asl($Rs32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asl_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += asl($Rs32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= asl($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= asl($Rs32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= asl($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_r_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asl($Rs32,#$Ii):sat",
tc_779080bf, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_asl_i_r_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 ^= asl($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_i_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vaslh($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_12b6e9 {
let Inst{7-5} = 0b010;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000100;
}
def S2_asl_i_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rdd32 = vaslw($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_7e5a82 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000000010;
}
def S2_asl_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = asl($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_asl_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += asl($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= asl($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= asl($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= asl($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= asl($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asl_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asl($Rs32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asl_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += asl($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= asl($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= asl($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= asl($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asl_r_r_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asl($Rs32,$Rt32):sat",
tc_779080bf, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_asl_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vaslh($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_asl_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vaslw($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_asr_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asr($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_5eac98 {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10000000000;
}
def S2_asr_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += asr($Rss32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= asr($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= asr($Rss32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= asr($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_i_p_rnd : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asr($Rss32,#$Ii):rnd",
tc_002cb246, TypeS_2op>, Enc_5eac98 {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b10000000110;
let prefersSlot3 = 1;
}
def S2_asr_i_p_rnd_goodsyntax : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = asrrnd($Rss32,#$Ii)",
tc_002cb246, TypeS_2op> {
let isPseudo = 1;
}
def S2_asr_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asr($Rs32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asr_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += asr($Rs32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= asr($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= asr($Rs32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= asr($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_i_r_rnd : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asr($Rs32,#$Ii):rnd",
tc_002cb246, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_asr_i_r_rnd_goodsyntax : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = asrrnd($Rs32,#$Ii)",
tc_002cb246, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
}
def S2_asr_i_svw_trun : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rd32 = vasrw($Rss32,#$Ii)",
tc_4414d8b1, TypeS_2op>, Enc_8dec2e {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001000110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_asr_i_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vasrh($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_12b6e9 {
let Inst{7-5} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000100;
}
def S2_asr_i_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rdd32 = vasrw($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_7e5a82 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000000010;
}
def S2_asr_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = asr($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_asr_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += asr($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= asr($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= asr($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= asr($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= asr($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_asr_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asr($Rs32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_asr_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += asr($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= asr($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= asr($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= asr($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_asr_r_r_sat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = asr($Rs32,$Rt32):sat",
tc_779080bf, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_asr_r_svw_trun : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rd32 = vasrw($Rss32,$Rt32)",
tc_4414d8b1, TypeS_3op>, Enc_3d5b28 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_asr_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vasrh($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_asr_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vasrw($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_brev : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = brev($Rs32)",
tc_14b5c689, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_brevp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = brev($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000110;
let prefersSlot3 = 1;
}
def S2_cabacdecbin : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = decbin($Rss32,$Rtt32)",
tc_76851da1, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let isPredicateLate = 1;
let prefersSlot3 = 1;
let Defs = [P0];
}
def S2_cl0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = cl0($Rs32)",
tc_14b5c689, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_cl0p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = cl0($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_cl1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = cl1($Rs32)",
tc_14b5c689, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_cl1p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = cl1($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_clb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = clb($Rs32)",
tc_14b5c689, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_clbnorm : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = normamt($Rs32)",
tc_14b5c689, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_clbp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = clb($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_clrbit_i : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = clrbit($Rs32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_clrbit_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = clrbit($Rs32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_ct0 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = ct0($Rs32)",
tc_14b5c689, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_ct0p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = ct0($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_ct1 : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = ct1($Rs32)",
tc_14b5c689, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_ct1p : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = ct1($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_deinterleave : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = deinterleave($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000110;
let prefersSlot3 = 1;
}
def S2_extractu : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii, u5_0Imm:$II),
"$Rd32 = extractu($Rs32,#$Ii,#$II)",
tc_f675fee8, TypeS_2op>, Enc_b388cf {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b100011010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_extractu_rp : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rd32 = extractu($Rs32,$Rtt32)",
tc_002cb246, TypeS_3op>, Enc_e07374 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_extractup : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii, u6_0Imm:$II),
"$Rdd32 = extractu($Rss32,#$Ii,#$II)",
tc_f675fee8, TypeS_2op>, Enc_b84c4c {
let Inst{31-24} = 0b10000001;
let prefersSlot3 = 1;
}
def S2_extractup_rp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = extractu($Rss32,$Rtt32)",
tc_002cb246, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
let prefersSlot3 = 1;
}
def S2_insert : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = insert($Rs32,#$Ii,#$II)",
tc_bfec0f01, TypeS_2op>, Enc_a1e29d {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b100011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_insert_rp : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rx32 = insert($Rs32,$Rtt32)",
tc_f429765c, TypeS_3op>, Enc_179b35 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001000000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_insertp : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii, u6_0Imm:$II),
"$Rxx32 = insert($Rss32,#$Ii,#$II)",
tc_bfec0f01, TypeS_2op>, Enc_143a3c {
let Inst{31-24} = 0b10000011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_insertp_rp : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rxx32 = insert($Rss32,$Rtt32)",
tc_f429765c, TypeS_3op>, Enc_88c16c {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_interleave : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = interleave($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000110;
let prefersSlot3 = 1;
}
def S2_lfsp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = lfs($Rss32,$Rtt32)",
tc_002cb246, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
let prefersSlot3 = 1;
}
def S2_lsl_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = lsl($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_lsl_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += lsl($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= lsl($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= lsl($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= lsl($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= lsl($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsl_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = lsl($Rs32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_lsl_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += lsl($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= lsl($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= lsl($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= lsl($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsl_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlslh($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_lsl_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlslw($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_lsr_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = lsr($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_5eac98 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000000000;
}
def S2_lsr_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += lsr($Rss32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= lsr($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= lsr($Rss32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= lsr($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_p_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 ^= lsr($Rss32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_70fb07 {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b10000010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = lsr($Rs32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_lsr_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += lsr($Rs32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= lsr($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= lsr($Rs32,#$Ii)",
tc_f675fee8, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= lsr($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_r_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 ^= lsr($Rs32,#$Ii)",
tc_f429765c, TypeS_2op>, Enc_28a2dc {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_i_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vlsrh($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_12b6e9 {
let Inst{7-5} = 0b001;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000100;
}
def S2_lsr_i_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u5_0Imm:$Ii),
"$Rdd32 = vlsrw($Rss32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_7e5a82 {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000000010;
}
def S2_lsr_r_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = lsr($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011100;
}
def S2_lsr_r_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += lsr($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011110;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 &= lsr($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 -= lsr($Rss32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 |= lsr($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_p_xor : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 ^= lsr($Rss32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001011011;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_lsr_r_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = lsr($Rs32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110010;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_lsr_r_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 += lsr($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 &= lsr($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 -= lsr($Rs32,$Rt32)",
tc_f675fee8, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, IntRegs:$Rt32),
"$Rx32 |= lsr($Rs32,$Rt32)",
tc_f429765c, TypeS_3op>, Enc_2ae154 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001100000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_lsr_r_vh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlsrh($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011010;
}
def S2_lsr_r_vw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vlsrw($Rss32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011000;
}
def S2_mask : HInst<
(outs IntRegs:$Rd32),
(ins u5_0Imm:$Ii, u5_0Imm:$II),
"$Rd32 = mask(#$Ii,#$II)",
tc_9461ff31, TypeS_2op>, Enc_c85e2a, Requires<[HasV66]> {
let Inst{13-13} = 0b1;
let Inst{20-16} = 0b00000;
let Inst{31-23} = 0b100011010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_packhl : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = packhl($Rs32,$Rt32)",
tc_5a2711e5, TypeALU32_3op>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11110101100;
let InputType = "reg";
}
def S2_parityp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rd32 = parity($Rss32,$Rtt32)",
tc_002cb246, TypeALU64>, Enc_d2216a {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010000000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_pstorerbf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb($Rs32+#$Ii) = $Rt32",
tc_f8e23f0b, TypeV2LDST>, Enc_da8d43, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S2_pstorerbf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb($Rx32++#$Ii) = $Rt32",
tc_24b66c99, TypeST>, Enc_cc449f, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memb($Rs32) = $Rt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerbfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rx32++#$Ii) = $Rt32",
tc_53559e35, TypeST>, Enc_cc449f, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb($Rs32+#$Ii) = $Nt8.new",
tc_8fb7ab1b, TypeV2LDST>, Enc_585242, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S2_pstorerbnewf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb($Rx32++#$Ii) = $Nt8.new",
tc_838b34ea, TypeST>, Enc_52a5dd, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4) memb($Rs32) = $Nt8.new",
tc_8fb7ab1b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerbnewfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rx32++#$Ii) = $Nt8.new",
tc_d65dbf51, TypeST>, Enc_52a5dd, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb($Rs32+#$Ii) = $Nt8.new",
tc_8fb7ab1b, TypeV2LDST>, Enc_585242, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S2_pstorerbnewt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb($Rx32++#$Ii) = $Nt8.new",
tc_838b34ea, TypeST>, Enc_52a5dd, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbnewt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4) memb($Rs32) = $Nt8.new",
tc_8fb7ab1b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerbnewtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rx32++#$Ii) = $Nt8.new",
tc_d65dbf51, TypeST>, Enc_52a5dd, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb($Rs32+#$Ii) = $Rt32",
tc_f8e23f0b, TypeV2LDST>, Enc_da8d43, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S2_pstorerbt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb($Rx32++#$Ii) = $Rt32",
tc_24b66c99, TypeST>, Enc_cc449f, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerbt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memb($Rs32) = $Rt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerbtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rx32++#$Ii) = $Rt32",
tc_53559e35, TypeST>, Enc_cc449f, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011000;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rs32+#$Ii) = $Rtt32",
tc_f8e23f0b, TypeV2LDST>, Enc_57a33e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S2_pstorerdf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rx32++#$Ii) = $Rtt32",
tc_24b66c99, TypeST>, Enc_9a33d5, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rs32) = $Rtt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerdfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rx32++#$Ii) = $Rtt32",
tc_53559e35, TypeST>, Enc_9a33d5, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rs32+#$Ii) = $Rtt32",
tc_f8e23f0b, TypeV2LDST>, Enc_57a33e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S2_pstorerdt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rx32++#$Ii) = $Rtt32",
tc_24b66c99, TypeST>, Enc_9a33d5, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerdt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rs32) = $Rtt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerdtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rx32++#$Ii) = $Rtt32",
tc_53559e35, TypeST>, Enc_9a33d5, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011110;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerff_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+#$Ii) = $Rt32.h",
tc_f8e23f0b, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerff_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rx32++#$Ii) = $Rt32.h",
tc_24b66c99, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerff_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32) = $Rt32.h",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerffnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rx32++#$Ii) = $Rt32.h",
tc_53559e35, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerft_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+#$Ii) = $Rt32.h",
tc_f8e23f0b, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000011;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerft_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rx32++#$Ii) = $Rt32.h",
tc_24b66c99, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerft_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32) = $Rt32.h",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerftnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rx32++#$Ii) = $Rt32.h",
tc_53559e35, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011011;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+#$Ii) = $Rt32",
tc_f8e23f0b, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerhf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rx32++#$Ii) = $Rt32",
tc_24b66c99, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32) = $Rt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerhfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rx32++#$Ii) = $Rt32",
tc_53559e35, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh($Rs32+#$Ii) = $Nt8.new",
tc_8fb7ab1b, TypeV2LDST>, Enc_f44229, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S2_pstorerhnewf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh($Rx32++#$Ii) = $Nt8.new",
tc_838b34ea, TypeST>, Enc_31aa6a, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4) memh($Rs32) = $Nt8.new",
tc_8fb7ab1b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerhnewfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rx32++#$Ii) = $Nt8.new",
tc_d65dbf51, TypeST>, Enc_31aa6a, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh($Rs32+#$Ii) = $Nt8.new",
tc_8fb7ab1b, TypeV2LDST>, Enc_f44229, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S2_pstorerhnewt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh($Rx32++#$Ii) = $Nt8.new",
tc_838b34ea, TypeST>, Enc_31aa6a, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerhnewt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4) memh($Rs32) = $Nt8.new",
tc_8fb7ab1b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerhnewtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rx32++#$Ii) = $Nt8.new",
tc_d65dbf51, TypeST>, Enc_31aa6a, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerht_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+#$Ii) = $Rt32",
tc_f8e23f0b, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S2_pstorerht_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rx32++#$Ii) = $Rt32",
tc_24b66c99, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerht_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32) = $Rt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerhtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rx32++#$Ii) = $Rt32",
tc_53559e35, TypeST>, Enc_b886fd, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011010;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerif_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw($Rs32+#$Ii) = $Rt32",
tc_f8e23f0b, TypeV2LDST>, Enc_397f23, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000100100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S2_pstorerif_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw($Rx32++#$Ii) = $Rt32",
tc_24b66c99, TypeST>, Enc_7eaeb6, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerif_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4) memw($Rs32) = $Rt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstorerifnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rx32++#$Ii) = $Rt32",
tc_53559e35, TypeST>, Enc_7eaeb6, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw($Rs32+#$Ii) = $Nt8.new",
tc_8fb7ab1b, TypeV2LDST>, Enc_8dbdfe, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S2_pstorerinewf_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw($Rx32++#$Ii) = $Nt8.new",
tc_838b34ea, TypeST>, Enc_65f095, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4) memw($Rs32) = $Nt8.new",
tc_8fb7ab1b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerinewfnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rx32++#$Ii) = $Nt8.new",
tc_d65dbf51, TypeST>, Enc_65f095, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw($Rs32+#$Ii) = $Nt8.new",
tc_8fb7ab1b, TypeV2LDST>, Enc_8dbdfe, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S2_pstorerinewt_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw($Rx32++#$Ii) = $Nt8.new",
tc_838b34ea, TypeST>, Enc_65f095, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerinewt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4) memw($Rs32) = $Nt8.new",
tc_8fb7ab1b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S2_pstorerinewtnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rx32++#$Ii) = $Nt8.new",
tc_d65dbf51, TypeST>, Enc_65f095, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-21} = 0b10101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerit_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw($Rs32+#$Ii) = $Rt32",
tc_f8e23f0b, TypeV2LDST>, Enc_397f23, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000000100;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S2_pstorerit_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw($Rx32++#$Ii) = $Rt32",
tc_24b66c99, TypeST>, Enc_7eaeb6, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_pstorerit_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4) memw($Rs32) = $Rt32",
tc_f8e23f0b, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_pstoreritnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rx32++#$Ii) = $Rt32",
tc_53559e35, TypeST>, Enc_7eaeb6, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b10101011100;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_setbit_i : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = setbit($Rs32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_setbit_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = setbit($Rs32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_shuffeb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = shuffeb($Rss32,$Rtt32)",
tc_946df596, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
}
def S2_shuffeh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = shuffeh($Rss32,$Rtt32)",
tc_946df596, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
}
def S2_shuffob : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = shuffob($Rtt32,$Rss32)",
tc_946df596, TypeS_3op>, Enc_ea23e4 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001000;
}
def S2_shuffoh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32),
"$Rdd32 = shuffoh($Rtt32,$Rss32)",
tc_946df596, TypeS_3op>, Enc_ea23e4 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S2_storerb_io : HInst<
(outs),
(ins IntRegs:$Rs32, s32_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+#$Ii) = $Rt32",
tc_30b9bb4a, TypeST>, Enc_448f7f, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1000;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isPredicable = 1;
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
}
def S2_storerb_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++$Mu2:brev) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pbr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++#$Ii:circ($Mu2)) = $Rt32",
tc_e86aa961, TypeST>, Enc_b15941, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerb_pci";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++I:circ($Mu2)) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f, AddrModeRel {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerb_pcr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rx32++#$Ii) = $Rt32",
tc_da97ee82, TypeST>, Enc_10bc21, AddrModeRel, PostInc_BaseImm {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerb_pi";
let isPredicable = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memb($Rx32++$Mu2) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101000;
let addrMode = PostInc;
let accessSize = ByteAccess;
let mayStore = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memb($Rs32) = $Rt32",
tc_30b9bb4a, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerbgp : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Rt32),
"memb(gp+#$Ii) = $Rt32",
tc_0371abea, TypeV2LDST>, Enc_1b64fb, AddrModeRel {
let Inst{24-21} = 0b0000;
let Inst{31-27} = 0b01001;
let accessSize = ByteAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let isNVStorable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
}
def S2_storerbnew_io : HInst<
(outs),
(ins IntRegs:$Rs32, s32_0Imm:$Ii, IntRegs:$Nt8),
"memb($Rs32+#$Ii) = $Nt8.new",
tc_be9602ff, TypeST>, Enc_4df4e9, AddrModeRel {
let Inst{12-11} = 0b00;
let Inst{24-21} = 0b1101;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 11;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S2_storerbnew_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++$Mu2:brev) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101111101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pbr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++#$Ii:circ($Mu2)) = $Nt8.new",
tc_d5c0729a, TypeST>, Enc_96ce4f, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerb_pci";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++I:circ($Mu2)) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85, AddrModeRel {
let Inst{7-0} = 0b00000010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerb_pcr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_0Imm:$Ii, IntRegs:$Nt8),
"memb($Rx32++#$Ii) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_c7cd90, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10101011101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_pi";
let isPredicable = 1;
let isNVStorable = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memb($Rx32++$Mu2) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85 {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101101101;
let addrMode = PostInc;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerbnew_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Nt8),
"memb($Rs32) = $Nt8.new",
tc_be9602ff, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def S2_storerbnewgp : HInst<
(outs),
(ins u32_0Imm:$Ii, IntRegs:$Nt8),
"memb(gp+#$Ii) = $Nt8.new",
tc_5bf126a6, TypeV2LDST>, Enc_ad1831, AddrModeRel {
let Inst{12-11} = 0b00;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerbabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 16;
let opExtentAlign = 0;
let opNewValue = 1;
}
def S2_storerd_io : HInst<
(outs),
(ins IntRegs:$Rs32, s29_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd($Rs32+#$Ii) = $Rtt32",
tc_30b9bb4a, TypeST>, Enc_ce6828, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1110;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 14;
let opExtentAlign = 3;
}
def S2_storerd_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++$Mu2:brev) = $Rtt32",
tc_da97ee82, TypeST>, Enc_928ca1 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++#$Ii:circ($Mu2)) = $Rtt32",
tc_e86aa961, TypeST>, Enc_395cc4 {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++I:circ($Mu2)) = $Rtt32",
tc_da97ee82, TypeST>, Enc_928ca1 {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd($Rx32++#$Ii) = $Rtt32",
tc_da97ee82, TypeST>, Enc_85bf58, AddrModeRel, PostInc_BaseImm {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerd_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, DoubleRegs:$Rtt32),
"memd($Rx32++$Mu2) = $Rtt32",
tc_da97ee82, TypeST>, Enc_928ca1 {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101110;
let addrMode = PostInc;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerd_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"memd($Rs32) = $Rtt32",
tc_30b9bb4a, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerdgp : HInst<
(outs),
(ins u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"memd(gp+#$Ii) = $Rtt32",
tc_0371abea, TypeV2LDST>, Enc_5c124a, AddrModeRel {
let Inst{24-21} = 0b0110;
let Inst{31-27} = 0b01001;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerdabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 19;
let opExtentAlign = 3;
}
def S2_storerf_io : HInst<
(outs),
(ins IntRegs:$Rs32, s31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) = $Rt32.h",
tc_30b9bb4a, TypeST>, Enc_e957fb, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1011;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def S2_storerf_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2:brev) = $Rt32.h",
tc_da97ee82, TypeST>, Enc_d5c73f {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++#$Ii:circ($Mu2)) = $Rt32.h",
tc_e86aa961, TypeST>, Enc_935d9b {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++I:circ($Mu2)) = $Rt32.h",
tc_da97ee82, TypeST>, Enc_d5c73f {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rx32++#$Ii) = $Rt32.h",
tc_da97ee82, TypeST>, Enc_052c7d, AddrModeRel, PostInc_BaseImm {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerf_pi";
let isPredicable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2) = $Rt32.h",
tc_da97ee82, TypeST>, Enc_d5c73f {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101011;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerf_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) = $Rt32.h",
tc_30b9bb4a, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerfgp : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(gp+#$Ii) = $Rt32.h",
tc_0371abea, TypeV2LDST>, Enc_fda92c, AddrModeRel {
let Inst{24-21} = 0b0011;
let Inst{31-27} = 0b01001;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerfabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def S2_storerh_io : HInst<
(outs),
(ins IntRegs:$Rs32, s31_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+#$Ii) = $Rt32",
tc_30b9bb4a, TypeST>, Enc_e957fb, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1010;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isPredicable = 1;
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
}
def S2_storerh_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2:brev) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pbr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++#$Ii:circ($Mu2)) = $Rt32",
tc_e86aa961, TypeST>, Enc_935d9b, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerh_pci";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++I:circ($Mu2)) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f, AddrModeRel {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerh_pcr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Rt32),
"memh($Rx32++#$Ii) = $Rt32",
tc_da97ee82, TypeST>, Enc_052c7d, AddrModeRel, PostInc_BaseImm {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_pi";
let isPredicable = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memh($Rx32++$Mu2) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101010;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let mayStore = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerh_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memh($Rs32) = $Rt32",
tc_30b9bb4a, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerhgp : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Rt32),
"memh(gp+#$Ii) = $Rt32",
tc_0371abea, TypeV2LDST>, Enc_fda92c, AddrModeRel {
let Inst{24-21} = 0b0010;
let Inst{31-27} = 0b01001;
let accessSize = HalfWordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let isNVStorable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
}
def S2_storerhnew_io : HInst<
(outs),
(ins IntRegs:$Rs32, s31_1Imm:$Ii, IntRegs:$Nt8),
"memh($Rs32+#$Ii) = $Nt8.new",
tc_be9602ff, TypeST>, Enc_0d8870, AddrModeRel {
let Inst{12-11} = 0b01;
let Inst{24-21} = 0b1101;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 12;
let opExtentAlign = 1;
let opNewValue = 2;
}
def S2_storerhnew_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++$Mu2:brev) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101111101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pbr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++#$Ii:circ($Mu2)) = $Nt8.new",
tc_d5c0729a, TypeST>, Enc_91b9fe, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerh_pci";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++I:circ($Mu2)) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85, AddrModeRel {
let Inst{7-0} = 0b00000010;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storerh_pcr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_1Imm:$Ii, IntRegs:$Nt8),
"memh($Rx32++#$Ii) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_e26546, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b001;
let Inst{31-21} = 0b10101011101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_pi";
let isNVStorable = 1;
let isPredicable = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memh($Rx32++$Mu2) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85 {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101101101;
let addrMode = PostInc;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerhnew_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Nt8),
"memh($Rs32) = $Nt8.new",
tc_be9602ff, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def S2_storerhnewgp : HInst<
(outs),
(ins u31_1Imm:$Ii, IntRegs:$Nt8),
"memh(gp+#$Ii) = $Nt8.new",
tc_5bf126a6, TypeV2LDST>, Enc_bc03e5, AddrModeRel {
let Inst{12-11} = 0b01;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storerhabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 17;
let opExtentAlign = 1;
let opNewValue = 1;
}
def S2_storeri_io : HInst<
(outs),
(ins IntRegs:$Rs32, s30_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+#$Ii) = $Rt32",
tc_30b9bb4a, TypeST>, Enc_143445, AddrModeRel, PostInc_BaseImm {
let Inst{24-21} = 0b1100;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isPredicable = 1;
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
}
def S2_storeri_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++$Mu2:brev) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101111100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pbr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++#$Ii:circ($Mu2)) = $Rt32",
tc_e86aa961, TypeST>, Enc_79b8c8, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b10101001100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storeri_pci";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++I:circ($Mu2)) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f, AddrModeRel {
let Inst{7-0} = 0b00000010;
let Inst{31-21} = 0b10101001100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storeri_pcr";
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Rt32),
"memw($Rx32++#$Ii) = $Rt32",
tc_da97ee82, TypeST>, Enc_db40cd, AddrModeRel, PostInc_BaseImm {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_pi";
let isPredicable = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Rt32),
"memw($Rx32++$Mu2) = $Rt32",
tc_da97ee82, TypeST>, Enc_d5c73f {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b10101101100;
let addrMode = PostInc;
let accessSize = WordAccess;
let mayStore = 1;
let isNVStorable = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storeri_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw($Rs32) = $Rt32",
tc_30b9bb4a, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S2_storerigp : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Rt32),
"memw(gp+#$Ii) = $Rt32",
tc_0371abea, TypeV2LDST>, Enc_541f26, AddrModeRel {
let Inst{24-21} = 0b0100;
let Inst{31-27} = 0b01001;
let accessSize = WordAccess;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let isNVStorable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
}
def S2_storerinew_io : HInst<
(outs),
(ins IntRegs:$Rs32, s30_2Imm:$Ii, IntRegs:$Nt8),
"memw($Rs32+#$Ii) = $Nt8.new",
tc_be9602ff, TypeST>, Enc_690862, AddrModeRel {
let Inst{12-11} = 0b10;
let Inst{24-21} = 0b1101;
let Inst{31-27} = 0b10100;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 1;
let opExtentBits = 13;
let opExtentAlign = 2;
let opNewValue = 2;
}
def S2_storerinew_pbr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++$Mu2:brev) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85, AddrModeRel {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101111101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pbr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pci : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++#$Ii:circ($Mu2)) = $Nt8.new",
tc_d5c0729a, TypeST>, Enc_3f97c8, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storeri_pci";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pcr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++I:circ($Mu2)) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85, AddrModeRel {
let Inst{7-0} = 0b00000010;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101001101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [CS];
let BaseOpcode = "S2_storeri_pcr";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s4_2Imm:$Ii, IntRegs:$Nt8),
"memw($Rx32++#$Ii) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_223005, AddrModeRel {
let Inst{2-0} = 0b000;
let Inst{7-7} = 0b0;
let Inst{13-11} = 0b010;
let Inst{31-21} = 0b10101011101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storeri_pi";
let isPredicable = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_pr : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, IntRegs:$Nt8),
"memw($Rx32++$Mu2) = $Nt8.new",
tc_c79a189f, TypeST>, Enc_8dbe85 {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101101101;
let addrMode = PostInc;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_storerinew_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Nt8),
"memw($Rs32) = $Nt8.new",
tc_be9602ff, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 1;
}
def S2_storerinewgp : HInst<
(outs),
(ins u30_2Imm:$Ii, IntRegs:$Nt8),
"memw(gp+#$Ii) = $Nt8.new",
tc_5bf126a6, TypeV2LDST>, Enc_78cbf0, AddrModeRel {
let Inst{12-11} = 0b10;
let Inst{24-21} = 0b0101;
let Inst{31-27} = 0b01001;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let Uses = [GP];
let BaseOpcode = "S2_storeriabs";
let isPredicable = 1;
let opExtendable = 0;
let isExtentSigned = 0;
let opExtentBits = 18;
let opExtentAlign = 2;
let opNewValue = 1;
}
def S2_storew_locked : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"memw_locked($Rs32,$Pd4) = $Rt32",
tc_5abb5e3f, TypeST>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100000101;
let accessSize = WordAccess;
let isPredicateLate = 1;
let isSoloAX = 1;
let mayStore = 1;
}
def S2_svsathb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = vsathb($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_svsathub : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = vsathub($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001100100;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_tableidxb : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxb($Rs32,#$Ii,#$II):raw",
tc_bfec0f01, TypeS_2op>, Enc_cd82bc {
let Inst{31-22} = 0b1000011100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxb_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxb($Rs32,#$Ii,#$II)",
tc_bfec0f01, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxd : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxd($Rs32,#$Ii,#$II):raw",
tc_bfec0f01, TypeS_2op>, Enc_cd82bc {
let Inst{31-22} = 0b1000011111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxd_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxd($Rs32,#$Ii,#$II)",
tc_bfec0f01, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxh : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxh($Rs32,#$Ii,#$II):raw",
tc_bfec0f01, TypeS_2op>, Enc_cd82bc {
let Inst{31-22} = 0b1000011101;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxh_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxh($Rs32,#$Ii,#$II)",
tc_bfec0f01, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxw : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, s6_0Imm:$II),
"$Rx32 = tableidxw($Rs32,#$Ii,#$II):raw",
tc_bfec0f01, TypeS_2op>, Enc_cd82bc {
let Inst{31-22} = 0b1000011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_tableidxw_goodsyntax : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u4_0Imm:$Ii, u5_0Imm:$II),
"$Rx32 = tableidxw($Rs32,#$Ii,#$II)",
tc_bfec0f01, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S2_togglebit_i : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = togglebit($Rs32,#$Ii)",
tc_946df596, TypeS_2op>, Enc_a05677 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100110;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_togglebit_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = togglebit($Rs32,$Rt32)",
tc_946df596, TypeS_3op>, Enc_5ab2be {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_tstbit_i : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Pd4 = tstbit($Rs32,#$Ii)",
tc_643b4717, TypeS_2op>, Enc_83ee64 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000101000;
}
def S2_tstbit_r : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = tstbit($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111000;
}
def S2_valignib : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32, u3_0Imm:$Ii),
"$Rdd32 = valignb($Rtt32,$Rss32,#$Ii)",
tc_b4b5c03a, TypeS_3op>, Enc_729ff7 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000000000;
}
def S2_valignrb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rtt32, DoubleRegs:$Rss32, PredRegs:$Pu4),
"$Rdd32 = valignb($Rtt32,$Rss32,$Pu4)",
tc_b4b5c03a, TypeS_3op>, Enc_8c6530 {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010000;
}
def S2_vcnegh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vcnegh($Rss32,$Rt32)",
tc_779080bf, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_vcrotate : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rdd32 = vcrotate($Rss32,$Rt32)",
tc_002cb246, TypeS_3op>, Enc_927852 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000011110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_vrcnegh : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32),
"$Rxx32 += vrcnegh($Rss32,$Rt32)",
tc_d773585a, TypeS_3op>, Enc_1aa186 {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b11001011001;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S2_vrndpackwh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vrndwh($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S2_vrndpackwhs : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vrndwh($Rss32):sat",
tc_cf8126ae, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S2_vsathb : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsathb($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsathb_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsathb($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsathub : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsathub($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsathub_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsathub($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsatwh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsatwh($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsatwh_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsatwh($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsatwuh : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vsatwuh($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10001000000;
let hasNewValue = 1;
let opNewValue = 0;
let Defs = [USR_OVF];
}
def S2_vsatwuh_nopack : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32),
"$Rdd32 = vsatwuh($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_b9c5fb {
let Inst{13-5} = 0b000000101;
let Inst{31-21} = 0b10000000000;
let Defs = [USR_OVF];
}
def S2_vsplatrb : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32),
"$Rd32 = vsplatb($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_5e2823 {
let Inst{13-5} = 0b000000111;
let Inst{31-21} = 0b10001100010;
let hasNewValue = 1;
let opNewValue = 0;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vsplatrh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsplath($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000100010;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vspliceib : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, u3_0Imm:$Ii),
"$Rdd32 = vspliceb($Rss32,$Rtt32,#$Ii)",
tc_b4b5c03a, TypeS_3op>, Enc_d50cd3 {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000000100;
}
def S2_vsplicerb : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32, PredRegs:$Pu4),
"$Rdd32 = vspliceb($Rss32,$Rtt32,$Pu4)",
tc_b4b5c03a, TypeS_3op>, Enc_dbd70c {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000010100;
}
def S2_vsxtbh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsxtbh($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vsxthw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsxthw($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vtrunehb : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vtrunehb($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_vtrunewh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunewh($Rss32,$Rtt32)",
tc_946df596, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S2_vtrunohb : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = vtrunohb($Rss32)",
tc_0ae0825c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S2_vtrunowh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunowh($Rss32,$Rtt32)",
tc_946df596, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S2_vzxtbh : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vzxtbh($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S2_vzxthw : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vzxthw($Rs32)",
tc_0ae0825c, TypeS_2op>, Enc_3a3d62 {
let Inst{13-5} = 0b000000110;
let Inst{31-21} = 0b10000100000;
let isReMaterializable = 1;
let isAsCheapAsAMove = 1;
}
def S4_addaddi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Ru32, s32_0Imm:$Ii),
"$Rd32 = add($Rs32,add($Ru32,#$Ii))",
tc_f675fee8, TypeALU64>, Enc_8b8d61 {
let Inst{31-23} = 0b110110110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_addi_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = add(#$Ii,asl($Rx32in,#$II))",
tc_f675fee8, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b100;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_addi_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = add(#$Ii,lsr($Rx32in,#$II))",
tc_f675fee8, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b100;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_andi_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = and(#$Ii,asl($Rx32in,#$II))",
tc_f429765c, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b000;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_andi_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = and(#$Ii,lsr($Rx32in,#$II))",
tc_f429765c, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b000;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_clbaddi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s6_0Imm:$Ii),
"$Rd32 = add(clb($Rs32),#$Ii)",
tc_002cb246, TypeS_2op>, Enc_9fae8a {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b10001100001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_clbpaddi : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, s6_0Imm:$Ii),
"$Rd32 = add(clb($Rss32),#$Ii)",
tc_002cb246, TypeS_2op>, Enc_a1640c {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_clbpnorm : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = normamt($Rss32)",
tc_14b5c689, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000000;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_extract : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii, u5_0Imm:$II),
"$Rd32 = extract($Rs32,#$Ii,#$II)",
tc_f675fee8, TypeS_2op>, Enc_b388cf {
let Inst{13-13} = 0b0;
let Inst{31-23} = 0b100011011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_extract_rp : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"$Rd32 = extract($Rs32,$Rtt32)",
tc_002cb246, TypeS_3op>, Enc_e07374 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11001001000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_extractp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii, u6_0Imm:$II),
"$Rdd32 = extract($Rss32,#$Ii,#$II)",
tc_f675fee8, TypeS_2op>, Enc_b84c4c {
let Inst{31-24} = 0b10001010;
let prefersSlot3 = 1;
}
def S4_extractp_rp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = extract($Rss32,$Rtt32)",
tc_002cb246, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let prefersSlot3 = 1;
}
def S4_lsli : HInst<
(outs IntRegs:$Rd32),
(ins s6_0Imm:$Ii, IntRegs:$Rt32),
"$Rd32 = lsl(#$Ii,$Rt32)",
tc_946df596, TypeS_3op>, Enc_fef969 {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000110100;
let hasNewValue = 1;
let opNewValue = 0;
}
def S4_ntstbit_i : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Pd4 = !tstbit($Rs32,#$Ii)",
tc_643b4717, TypeS_2op>, Enc_83ee64 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10000101001;
}
def S4_ntstbit_r : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Pd4 = !tstbit($Rs32,$Rt32)",
tc_85d5d03f, TypeS_3op>, Enc_c2b48e {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000111001;
}
def S4_or_andi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 |= and($Rs32,#$Ii)",
tc_f429765c, TypeALU64>, Enc_b0e9d8 {
let Inst{31-22} = 0b1101101000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_or_andix : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Ru32, IntRegs:$Rx32in, s32_0Imm:$Ii),
"$Rx32 = or($Ru32,and($Rx32in,#$Ii))",
tc_f429765c, TypeALU64>, Enc_b4e6cf {
let Inst{31-22} = 0b1101101001;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_or_ori : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, s32_0Imm:$Ii),
"$Rx32 |= or($Rs32,#$Ii)",
tc_f429765c, TypeALU64>, Enc_b0e9d8 {
let Inst{31-22} = 0b1101101010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let InputType = "imm";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 10;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_ori_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = or(#$Ii,asl($Rx32in,#$II))",
tc_f429765c, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b010;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_ori_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = or(#$Ii,lsr($Rx32in,#$II))",
tc_f429765c, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b010;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_parity : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = parity($Rs32,$Rt32)",
tc_002cb246, TypeALU64>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S4_pstorerbf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb(#$Ii) = $Rt32",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb(#$Ii) = $Rt32",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rs32+#$Ii) = $Rt32",
tc_da97ee82, TypeV2LDST>, Enc_da8d43, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110111000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memb($Rs32) = $Rt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerbnewf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb(#$Ii) = $Nt8.new",
tc_4b68bce4, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b000;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_e95795ec, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110101101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb(#$Ii) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rs32+#$Ii) = $Nt8.new",
tc_c79a189f, TypeV2LDST>, Enc_585242, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000110101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_pstorerbnewfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_b90a29b1, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4.new) memb($Rs32) = $Nt8.new",
tc_c79a189f, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerbnewt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb(#$Ii) = $Nt8.new",
tc_4b68bce4, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b000;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_e95795ec, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110100101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb(#$Ii) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b100;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerbnewtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rs32+#$Ii) = $Nt8.new",
tc_c79a189f, TypeV2LDST>, Enc_585242, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b01000010101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_pstorerbnewtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_b90a29b1, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b00;
let Inst{31-21} = 0b00110110101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let opNewValue = 4;
}
def S4_pstorerbnewtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4.new) memb($Rs32) = $Nt8.new",
tc_c79a189f, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerbt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb(#$Ii) = $Rt32",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110100000;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb(#$Ii) = $Rt32",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111000000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S2_storerbabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rs32+#$Ii) = $Rt32",
tc_da97ee82, TypeV2LDST>, Enc_da8d43, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S2_storerb_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerbtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110110000;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
}
def S4_pstorerbtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memb($Rs32) = $Rt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerdf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd(#$Ii) = $Rtt32",
tc_362c6592, TypeST>, Enc_50b5ac, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
tc_3962fa26, TypeST>, Enc_1a9974, AddrModeRel {
let Inst{31-21} = 0b00110101110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd(#$Ii) = $Rtt32",
tc_da4a37ed, TypeST>, Enc_50b5ac, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rs32+#$Ii) = $Rtt32",
tc_da97ee82, TypeV2LDST>, Enc_57a33e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S4_pstorerdfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
tc_40116ca8, TypeST>, Enc_1a9974, AddrModeRel {
let Inst{31-21} = 0b00110111110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if (!$Pv4.new) memd($Rs32) = $Rtt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerdt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd(#$Ii) = $Rtt32",
tc_362c6592, TypeST>, Enc_50b5ac, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
tc_3962fa26, TypeST>, Enc_1a9974, AddrModeRel {
let Inst{31-21} = 0b00110100110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd(#$Ii) = $Rtt32",
tc_da4a37ed, TypeST>, Enc_50b5ac, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111110000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let BaseOpcode = "S2_storerdabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerdtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u29_3Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rs32+#$Ii) = $Rtt32",
tc_da97ee82, TypeV2LDST>, Enc_57a33e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010110;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 9;
let opExtentAlign = 3;
}
def S4_pstorerdtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
tc_40116ca8, TypeST>, Enc_1a9974, AddrModeRel {
let Inst{31-21} = 0b00110110110;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
}
def S4_pstorerdtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, DoubleRegs:$Rtt32),
"if ($Pv4.new) memd($Rs32) = $Rtt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerff_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh(#$Ii) = $Rt32.h",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerff_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110101011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerffnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh(#$Ii) = $Rt32.h",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerffnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+#$Ii) = $Rt32.h",
tc_da97ee82, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerffnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110111011;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerffnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32) = $Rt32.h",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerft_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh(#$Ii) = $Rt32.h",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerft_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110100011;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerftnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh(#$Ii) = $Rt32.h",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111011000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let BaseOpcode = "S2_storerfabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerftnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+#$Ii) = $Rt32.h",
tc_da97ee82, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010011;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S2_storerf_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerftnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110110011;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
}
def S4_pstorerftnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32) = $Rt32.h",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerhf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh(#$Ii) = $Rt32",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerhf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110101010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh(#$Ii) = $Rt32",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerhfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+#$Ii) = $Rt32",
tc_da97ee82, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerhfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110111010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memh($Rs32) = $Rt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerhnewf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh(#$Ii) = $Nt8.new",
tc_4b68bce4, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b001;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_e95795ec, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110101101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh(#$Ii) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rs32+#$Ii) = $Nt8.new",
tc_c79a189f, TypeV2LDST>, Enc_f44229, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000110101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S4_pstorerhnewfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_b90a29b1, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4.new) memh($Rs32) = $Nt8.new",
tc_c79a189f, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerhnewt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh(#$Ii) = $Nt8.new",
tc_4b68bce4, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b001;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_e95795ec, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110100101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh(#$Ii) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b101;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerhnewtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rs32+#$Ii) = $Nt8.new",
tc_c79a189f, TypeV2LDST>, Enc_f44229, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b01000010101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
let opNewValue = 3;
}
def S4_pstorerhnewtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_b90a29b1, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b01;
let Inst{31-21} = 0b00110110101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let opNewValue = 4;
}
def S4_pstorerhnewtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4.new) memh($Rs32) = $Nt8.new",
tc_c79a189f, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerht_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh(#$Ii) = $Rt32",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerht_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110100010;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh(#$Ii) = $Rt32",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111010000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerhabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerhtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u31_1Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+#$Ii) = $Rt32",
tc_da97ee82, TypeV2LDST>, Enc_e8c45e, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 7;
let opExtentAlign = 1;
}
def S4_pstorerhtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110110010;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
}
def S4_pstorerhtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memh($Rs32) = $Rt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerif_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw(#$Ii) = $Rt32",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerif_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110101100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstorerifnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw(#$Ii) = $Rt32",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerifnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rs32+#$Ii) = $Rt32",
tc_da97ee82, TypeV2LDST>, Enc_397f23, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000110100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S4_pstorerifnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110111100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstorerifnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if (!$Pv4.new) memw($Rs32) = $Rt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_pstorerinewf_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw(#$Ii) = $Nt8.new",
tc_4b68bce4, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b010;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewf_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_e95795ec, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110101101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewfnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw(#$Ii) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b1;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rs32+#$Ii) = $Nt8.new",
tc_c79a189f, TypeV2LDST>, Enc_8dbdfe, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000110101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S4_pstorerinewfnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_b90a29b1, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110111101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if (!$Pv4.new) memw($Rs32) = $Nt8.new",
tc_c79a189f, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerinewt_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw(#$Ii) = $Nt8.new",
tc_4b68bce4, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b010;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewt_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_e95795ec, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110100101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewtnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw(#$Ii) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_44215c, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-11} = 0b110;
let Inst{31-18} = 0b10101111101000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_pstorerinewtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rs32+#$Ii) = $Nt8.new",
tc_c79a189f, TypeV2LDST>, Enc_8dbdfe, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b01000010101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
let opNewValue = 3;
}
def S4_pstorerinewtnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_b90a29b1, TypeST>, Enc_47ee5e, AddrModeRel {
let Inst{4-3} = 0b10;
let Inst{31-21} = 0b00110110101;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isPredicatedNew = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let opNewValue = 4;
}
def S4_pstorerinewtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Nt8),
"if ($Pv4.new) memw($Rs32) = $Nt8.new",
tc_c79a189f, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let opNewValue = 2;
}
def S4_pstorerit_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw(#$Ii) = $Rt32",
tc_362c6592, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b0;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstorerit_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_3962fa26, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110100100;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstoreritnew_abs : HInst<
(outs),
(ins PredRegs:$Pv4, u32_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw(#$Ii) = $Rt32",
tc_da4a37ed, TypeST>, Enc_1cf4ca, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-18} = 0b10101111100000;
let isPredicated = 1;
let addrMode = Absolute;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeriabs";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_pstoreritnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u30_2Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rs32+#$Ii) = $Rt32",
tc_da97ee82, TypeV2LDST>, Enc_397f23, AddrModeRel {
let Inst{2-2} = 0b0;
let Inst{31-21} = 0b01000010100;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_io";
let isNVStorable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 2;
}
def S4_pstoreritnew_rr : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_40116ca8, TypeST>, Enc_6339d5, AddrModeRel {
let Inst{31-21} = 0b00110110100;
let isPredicated = 1;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
}
def S4_pstoreritnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, IntRegs:$Rt32),
"if ($Pv4.new) memw($Rs32) = $Rt32",
tc_da97ee82, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_stored_locked : HInst<
(outs PredRegs:$Pd4),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"memd_locked($Rs32,$Pd4) = $Rtt32",
tc_5abb5e3f, TypeST>, Enc_d7dc10 {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100000111;
let accessSize = DoubleWordAccess;
let isPredicateLate = 1;
let isSoloAX = 1;
let mayStore = 1;
}
def S4_storeirb_io : HInst<
(outs),
(ins IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"memb($Rs32+#$Ii) = #$II",
tc_b83e6d73, TypeST>, Enc_8203bb, PredNewRel {
let Inst{31-21} = 0b00111100000;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def S4_storeirb_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, s8_0Imm:$II),
"memb($Rs32) = #$II",
tc_b83e6d73, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4) memb($Rs32+#$Ii) = #$II",
tc_0b2be201, TypeST>, Enc_d7a65e, PredNewRel {
let Inst{31-21} = 0b00111000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4) memb($Rs32) = #$II",
tc_0b2be201, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4.new) memb($Rs32+#$Ii) = #$II",
tc_c4f596e3, TypeST>, Enc_d7a65e, PredNewRel {
let Inst{31-21} = 0b00111001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4.new) memb($Rs32) = #$II",
tc_c4f596e3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbt_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if ($Pv4) memb($Rs32+#$Ii) = #$II",
tc_0b2be201, TypeST>, Enc_d7a65e, PredNewRel {
let Inst{31-21} = 0b00111000000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbt_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4) memb($Rs32) = #$II",
tc_0b2be201, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirbtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_0Imm:$Ii, s32_0Imm:$II),
"if ($Pv4.new) memb($Rs32+#$Ii) = #$II",
tc_c4f596e3, TypeST>, Enc_d7a65e, PredNewRel {
let Inst{31-21} = 0b00111001000;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storeirb_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirbtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4.new) memb($Rs32) = #$II",
tc_c4f596e3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirh_io : HInst<
(outs),
(ins IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"memh($Rs32+#$Ii) = #$II",
tc_b83e6d73, TypeST>, Enc_a803e0, PredNewRel {
let Inst{31-21} = 0b00111100001;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def S4_storeirh_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, s8_0Imm:$II),
"memh($Rs32) = #$II",
tc_b83e6d73, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirhf_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4) memh($Rs32+#$Ii) = #$II",
tc_0b2be201, TypeST>, Enc_f20719, PredNewRel {
let Inst{31-21} = 0b00111000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirhf_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4) memh($Rs32) = #$II",
tc_0b2be201, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirhfnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4.new) memh($Rs32+#$Ii) = #$II",
tc_c4f596e3, TypeST>, Enc_f20719, PredNewRel {
let Inst{31-21} = 0b00111001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirhfnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4.new) memh($Rs32) = #$II",
tc_c4f596e3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirht_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if ($Pv4) memh($Rs32+#$Ii) = #$II",
tc_0b2be201, TypeST>, Enc_f20719, PredNewRel {
let Inst{31-21} = 0b00111000001;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirht_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4) memh($Rs32) = #$II",
tc_0b2be201, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirhtnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_1Imm:$Ii, s32_0Imm:$II),
"if ($Pv4.new) memh($Rs32+#$Ii) = #$II",
tc_c4f596e3, TypeST>, Enc_f20719, PredNewRel {
let Inst{31-21} = 0b00111001001;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S4_storeirh_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirhtnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4.new) memh($Rs32) = #$II",
tc_c4f596e3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeiri_io : HInst<
(outs),
(ins IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"memw($Rs32+#$Ii) = #$II",
tc_b83e6d73, TypeST>, Enc_f37377, PredNewRel {
let Inst{31-21} = 0b00111100010;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isPredicable = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 8;
let opExtentAlign = 0;
}
def S4_storeiri_zomap : HInst<
(outs),
(ins IntRegs:$Rs32, s8_0Imm:$II),
"memw($Rs32) = #$II",
tc_b83e6d73, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirif_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4) memw($Rs32+#$Ii) = #$II",
tc_0b2be201, TypeST>, Enc_5ccba9, PredNewRel {
let Inst{31-21} = 0b00111000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirif_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4) memw($Rs32) = #$II",
tc_0b2be201, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirifnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if (!$Pv4.new) memw($Rs32+#$Ii) = #$II",
tc_c4f596e3, TypeST>, Enc_5ccba9, PredNewRel {
let Inst{31-21} = 0b00111001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirifnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if (!$Pv4.new) memw($Rs32) = #$II",
tc_c4f596e3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeirit_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if ($Pv4) memw($Rs32+#$Ii) = #$II",
tc_0b2be201, TypeST>, Enc_5ccba9, PredNewRel {
let Inst{31-21} = 0b00111000010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeirit_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4) memw($Rs32) = #$II",
tc_0b2be201, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storeiritnew_io : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, u6_2Imm:$Ii, s32_0Imm:$II),
"if ($Pv4.new) memw($Rs32+#$Ii) = #$II",
tc_c4f596e3, TypeST>, Enc_5ccba9, PredNewRel {
let Inst{31-21} = 0b00111001010;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let isPredicatedNew = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S4_storeiri_io";
let isExtendable = 1;
let opExtendable = 3;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeiritnew_zomap : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rs32, s6_0Imm:$II),
"if ($Pv4.new) memw($Rs32) = #$II",
tc_c4f596e3, TypeMAPPING> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S4_storerb_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memb($Re32=#$II) = $Rt32",
tc_da4a37ed, TypeST>, Enc_8bcba4, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011000;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_ap";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerb_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memb($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_5aee39f7, TypeST>, Enc_eca7c8, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011000;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isNVStorable = 1;
let isPredicable = 1;
}
def S4_storerb_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memb($Ru32<<#$Ii+#$II) = $Rt32",
tc_14b272fa, TypeST>, Enc_9ea4cf, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101000;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "imm";
let BaseOpcode = "S4_storerb_ur";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerbnew_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Nt8),
"memb($Re32=#$II) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_724154, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10101011101;
let addrMode = AbsoluteSet;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerb_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_storerbnew_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"memb($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_67435e81, TypeST>, Enc_c6220b, AddrModeRel {
let Inst{6-3} = 0b0000;
let Inst{31-21} = 0b00111011101;
let addrMode = BaseRegOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let InputType = "reg";
let BaseOpcode = "S4_storerb_rr";
let isPredicable = 1;
let opNewValue = 3;
}
def S4_storerbnew_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Nt8),
"memb($Ru32<<#$Ii+#$II) = $Nt8.new",
tc_fcc3ddf9, TypeST>, Enc_7eb485, AddrModeRel {
let Inst{7-7} = 0b1;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b10101101101;
let addrMode = BaseLongOffset;
let accessSize = ByteAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerb";
let BaseOpcode = "S4_storerb_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_storerd_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, DoubleRegs:$Rtt32),
"memd($Re32=#$II) = $Rtt32",
tc_da4a37ed, TypeST>, Enc_c7a204 {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011110;
let addrMode = AbsoluteSet;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S4_storerd_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerd_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, DoubleRegs:$Rtt32),
"memd($Rs32+$Ru32<<#$Ii) = $Rtt32",
tc_5aee39f7, TypeST>, Enc_55355c, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011110;
let addrMode = BaseRegOffset;
let accessSize = DoubleWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "reg";
let BaseOpcode = "S2_storerd_rr";
let isPredicable = 1;
}
def S4_storerd_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, DoubleRegs:$Rtt32),
"memd($Ru32<<#$Ii+#$II) = $Rtt32",
tc_14b272fa, TypeST>, Enc_f79415, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101110;
let addrMode = BaseLongOffset;
let accessSize = DoubleWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerd";
let InputType = "imm";
let BaseOpcode = "S2_storerd_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerf_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memh($Re32=#$II) = $Rt32.h",
tc_da4a37ed, TypeST>, Enc_8bcba4 {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011011;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S4_storerf_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerf_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+$Ru32<<#$Ii) = $Rt32.h",
tc_5aee39f7, TypeST>, Enc_eca7c8, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011011;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "reg";
let BaseOpcode = "S4_storerf_rr";
let isPredicable = 1;
}
def S4_storerf_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memh($Ru32<<#$Ii+#$II) = $Rt32.h",
tc_14b272fa, TypeST>, Enc_9ea4cf, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101011;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerf";
let InputType = "imm";
let BaseOpcode = "S4_storerf_rr";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerh_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memh($Re32=#$II) = $Rt32",
tc_da4a37ed, TypeST>, Enc_8bcba4, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011010;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_ap";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerh_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memh($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_5aee39f7, TypeST>, Enc_eca7c8, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011010;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isNVStorable = 1;
let isPredicable = 1;
}
def S4_storerh_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memh($Ru32<<#$Ii+#$II) = $Rt32",
tc_14b272fa, TypeST>, Enc_9ea4cf, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101010;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "imm";
let BaseOpcode = "S2_storerh_ur";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerhnew_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Nt8),
"memh($Re32=#$II) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_724154, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-11} = 0b001;
let Inst{31-21} = 0b10101011101;
let addrMode = AbsoluteSet;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storerh_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_storerhnew_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"memh($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_67435e81, TypeST>, Enc_c6220b, AddrModeRel {
let Inst{6-3} = 0b0001;
let Inst{31-21} = 0b00111011101;
let addrMode = BaseRegOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let InputType = "reg";
let BaseOpcode = "S2_storerh_rr";
let isPredicable = 1;
let opNewValue = 3;
}
def S4_storerhnew_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Nt8),
"memh($Ru32<<#$Ii+#$II) = $Nt8.new",
tc_fcc3ddf9, TypeST>, Enc_7eb485, AddrModeRel {
let Inst{7-7} = 0b1;
let Inst{12-11} = 0b01;
let Inst{31-21} = 0b10101101101;
let addrMode = BaseLongOffset;
let accessSize = HalfWordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storerh";
let BaseOpcode = "S2_storerh_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_storeri_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Rt32),
"memw($Re32=#$II) = $Rt32",
tc_da4a37ed, TypeST>, Enc_8bcba4, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10101011100;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let BaseOpcode = "S2_storeri_ap";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storeri_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Rt32),
"memw($Rs32+$Ru32<<#$Ii) = $Rt32",
tc_5aee39f7, TypeST>, Enc_eca7c8, AddrModeRel, ImmRegShl {
let Inst{6-5} = 0b00;
let Inst{31-21} = 0b00111011100;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isNVStorable = 1;
let isPredicable = 1;
}
def S4_storeri_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Rt32),
"memw($Ru32<<#$Ii+#$II) = $Rt32",
tc_14b272fa, TypeST>, Enc_9ea4cf, AddrModeRel, ImmRegShl {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b10101101100;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let isExtended = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "imm";
let BaseOpcode = "S2_storeri_ur";
let isNVStorable = 1;
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_storerinew_ap : HInst<
(outs IntRegs:$Re32),
(ins u32_0Imm:$II, IntRegs:$Nt8),
"memw($Re32=#$II) = $Nt8.new",
tc_d2e63d61, TypeST>, Enc_724154, AddrModeRel {
let Inst{7-6} = 0b10;
let Inst{13-11} = 0b010;
let Inst{31-21} = 0b10101011101;
let addrMode = AbsoluteSet;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let BaseOpcode = "S2_storeri_ap";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 2;
}
def S4_storerinew_rr : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Ru32, u2_0Imm:$Ii, IntRegs:$Nt8),
"memw($Rs32+$Ru32<<#$Ii) = $Nt8.new",
tc_67435e81, TypeST>, Enc_c6220b, AddrModeRel {
let Inst{6-3} = 0b0010;
let Inst{31-21} = 0b00111011101;
let addrMode = BaseRegOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let InputType = "reg";
let BaseOpcode = "S2_storeri_rr";
let isPredicable = 1;
let opNewValue = 3;
}
def S4_storerinew_ur : HInst<
(outs),
(ins IntRegs:$Ru32, u2_0Imm:$Ii, u32_0Imm:$II, IntRegs:$Nt8),
"memw($Ru32<<#$Ii+#$II) = $Nt8.new",
tc_fcc3ddf9, TypeST>, Enc_7eb485, AddrModeRel {
let Inst{7-7} = 0b1;
let Inst{12-11} = 0b10;
let Inst{31-21} = 0b10101101101;
let addrMode = BaseLongOffset;
let accessSize = WordAccess;
let isNVStore = 1;
let isNewValue = 1;
let isExtended = 1;
let isRestrictNoSlot1Store = 1;
let mayStore = 1;
let CextOpcode = "S2_storeri";
let BaseOpcode = "S2_storeri_ur";
let DecoderNamespace = "MustExtend";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
let opNewValue = 3;
}
def S4_subaddi : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, s32_0Imm:$Ii, IntRegs:$Ru32),
"$Rd32 = add($Rs32,sub(#$Ii,$Ru32))",
tc_f675fee8, TypeALU64>, Enc_8b8d61 {
let Inst{31-23} = 0b110110111;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def S4_subi_asl_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = sub(#$Ii,asl($Rx32in,#$II))",
tc_f675fee8, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b110;
let Inst{4-4} = 0b0;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_subi_lsr_ri : HInst<
(outs IntRegs:$Rx32),
(ins u32_0Imm:$Ii, IntRegs:$Rx32in, u5_0Imm:$II),
"$Rx32 = sub(#$Ii,lsr($Rx32in,#$II))",
tc_f675fee8, TypeALU64>, Enc_c31910 {
let Inst{2-0} = 0b110;
let Inst{4-4} = 0b1;
let Inst{31-24} = 0b11011110;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 8;
let opExtentAlign = 0;
let Constraints = "$Rx32 = $Rx32in";
}
def S4_vrcrotate : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rdd32 = vrcrotate($Rss32,$Rt32,#$Ii)",
tc_13bfbcf9, TypeS_3op>, Enc_645d54 {
let Inst{7-6} = 0b11;
let Inst{31-21} = 0b11000011110;
let prefersSlot3 = 1;
}
def S4_vrcrotate_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, IntRegs:$Rt32, u2_0Imm:$Ii),
"$Rxx32 += vrcrotate($Rss32,$Rt32,#$Ii)",
tc_9debc299, TypeS_3op>, Enc_b72622 {
let Inst{7-6} = 0b00;
let Inst{31-21} = 0b11001011101;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S4_vxaddsubh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxaddsubh($Rss32,$Rtt32):sat",
tc_779080bf, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S4_vxaddsubhr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxaddsubh($Rss32,$Rtt32):rnd:>>1:sat",
tc_002cb246, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S4_vxaddsubw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxaddsubw($Rss32,$Rtt32):sat",
tc_779080bf, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S4_vxsubaddh : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxsubaddh($Rss32,$Rtt32):sat",
tc_779080bf, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S4_vxsubaddhr : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxsubaddh($Rss32,$Rtt32):rnd:>>1:sat",
tc_002cb246, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001110;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S4_vxsubaddw : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vxsubaddw($Rss32,$Rtt32):sat",
tc_779080bf, TypeS_3op>, Enc_a56825 {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001010;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S5_asrhub_rnd_sat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rd32 = vasrhub($Rss32,#$Ii):raw",
tc_002cb246, TypeS_2op>, Enc_11a146 {
let Inst{7-5} = 0b100;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S5_asrhub_rnd_sat_goodsyntax : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rd32 = vasrhub($Rss32,#$Ii):rnd:sat",
tc_002cb246, TypeS_2op> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
}
def S5_asrhub_sat : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rd32 = vasrhub($Rss32,#$Ii):sat",
tc_002cb246, TypeS_2op>, Enc_11a146 {
let Inst{7-5} = 0b101;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def S5_popcountp : HInst<
(outs IntRegs:$Rd32),
(ins DoubleRegs:$Rss32),
"$Rd32 = popcount($Rss32)",
tc_703e822c, TypeS_2op>, Enc_90cd8b {
let Inst{13-5} = 0b000000011;
let Inst{31-21} = 0b10001000011;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
}
def S5_vasrhrnd : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vasrh($Rss32,#$Ii):raw",
tc_002cb246, TypeS_2op>, Enc_12b6e9 {
let Inst{7-5} = 0b000;
let Inst{13-12} = 0b00;
let Inst{31-21} = 0b10000000001;
let prefersSlot3 = 1;
}
def S5_vasrhrnd_goodsyntax : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u4_0Imm:$Ii),
"$Rdd32 = vasrh($Rss32,#$Ii):rnd",
tc_002cb246, TypeS_2op> {
let isPseudo = 1;
}
def S6_allocframe_to_raw : HInst<
(outs),
(ins u11_3Imm:$Ii),
"allocframe(#$Ii)",
tc_b44ecf75, TypeMAPPING>, Requires<[HasV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def S6_rol_i_p : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rdd32 = rol($Rss32,#$Ii)",
tc_1fc97744, TypeS_2op>, Enc_5eac98, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000000000;
}
def S6_rol_i_p_acc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 += rol($Rss32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_70fb07, Requires<[HasV60]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_and : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 &= rol($Rss32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_70fb07, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_nac : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 -= rol($Rss32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_70fb07, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000010000;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_or : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 |= rol($Rss32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_70fb07, Requires<[HasV60]> {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b10000010010;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_p_xacc : HInst<
(outs DoubleRegs:$Rxx32),
(ins DoubleRegs:$Rxx32in, DoubleRegs:$Rss32, u6_0Imm:$Ii),
"$Rxx32 ^= rol($Rss32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_70fb07, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b10000010100;
let prefersSlot3 = 1;
let Constraints = "$Rxx32 = $Rxx32in";
}
def S6_rol_i_r : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rd32 = rol($Rs32,#$Ii)",
tc_1fc97744, TypeS_2op>, Enc_a05677, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001100000;
let hasNewValue = 1;
let opNewValue = 0;
}
def S6_rol_i_r_acc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 += rol($Rs32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_28a2dc, Requires<[HasV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_and : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 &= rol($Rs32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_28a2dc, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_nac : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 -= rol($Rs32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_28a2dc, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110000;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_or : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 |= rol($Rs32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_28a2dc, Requires<[HasV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110010;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_rol_i_r_xacc : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, IntRegs:$Rs32, u5_0Imm:$Ii),
"$Rx32 ^= rol($Rs32,#$Ii)",
tc_784490da, TypeS_2op>, Enc_28a2dc, Requires<[HasV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10001110100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Constraints = "$Rx32 = $Rx32in";
}
def S6_vsplatrbp : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32),
"$Rdd32 = vsplatb($Rs32)",
tc_a1c00888, TypeS_2op>, Enc_3a3d62, Requires<[HasV62]> {
let Inst{13-5} = 0b000000100;
let Inst{31-21} = 0b10000100010;
}
def S6_vtrunehb_ppp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunehb($Rss32,$Rtt32)",
tc_1fc97744, TypeS_3op>, Enc_a56825, Requires<[HasV62]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def S6_vtrunohb_ppp : HInst<
(outs DoubleRegs:$Rdd32),
(ins DoubleRegs:$Rss32, DoubleRegs:$Rtt32),
"$Rdd32 = vtrunohb($Rss32,$Rtt32)",
tc_1fc97744, TypeS_3op>, Enc_a56825, Requires<[HasV62]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11000001100;
}
def SA1_addi : HInst<
(outs GeneralSubRegs:$Rx16),
(ins IntRegs:$Rx16in, s32_0Imm:$Ii),
"$Rx16 = add($Rx16in,#$Ii)",
tc_0a705168, TypeSUBINSN>, Enc_93af4c {
let Inst{12-11} = 0b00;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
let isExtendable = 1;
let opExtendable = 2;
let isExtentSigned = 1;
let opExtentBits = 7;
let opExtentAlign = 0;
let Constraints = "$Rx16 = $Rx16in";
}
def SA1_addrx : HInst<
(outs GeneralSubRegs:$Rx16),
(ins IntRegs:$Rx16in, GeneralSubRegs:$Rs16),
"$Rx16 = add($Rx16in,$Rs16)",
tc_0a705168, TypeSUBINSN>, Enc_0527db {
let Inst{12-8} = 0b11000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
let Constraints = "$Rx16 = $Rx16in";
}
def SA1_addsp : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u6_2Imm:$Ii),
"$Rd16 = add(r29,#$Ii)",
tc_9fc3dae0, TypeSUBINSN>, Enc_2df31d {
let Inst{12-10} = 0b011;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let Uses = [R29];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_and1 : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = and($Rs16,#1)",
tc_9fc3dae0, TypeSUBINSN>, Enc_97d666 {
let Inst{12-8} = 0b10010;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrf : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (!p0) $Rd16 = #0",
tc_a1123dda, TypeSUBINSN>, Enc_1f5ba6 {
let Inst{12-4} = 0b110100111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrfnew : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (!p0.new) $Rd16 = #0",
tc_8b3e402a, TypeSUBINSN>, Enc_1f5ba6 {
let Inst{12-4} = 0b110100101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrt : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (p0) $Rd16 = #0",
tc_a1123dda, TypeSUBINSN>, Enc_1f5ba6 {
let Inst{12-4} = 0b110100110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_clrtnew : HInst<
(outs GeneralSubRegs:$Rd16),
(ins),
"if (p0.new) $Rd16 = #0",
tc_8b3e402a, TypeSUBINSN>, Enc_1f5ba6 {
let Inst{12-4} = 0b110100100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let Uses = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_cmpeqi : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u2_0Imm:$Ii),
"p0 = cmp.eq($Rs16,#$Ii)",
tc_5b7c0967, TypeSUBINSN>, Enc_63eaeb {
let Inst{3-2} = 0b00;
let Inst{12-8} = 0b11001;
let AsmVariantName = "NonParsable";
let Defs = [P0];
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine0i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#0,#$Ii)",
tc_9fc3dae0, TypeSUBINSN>, Enc_ed48be {
let Inst{4-3} = 0b00;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine1i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#1,#$Ii)",
tc_9fc3dae0, TypeSUBINSN>, Enc_ed48be {
let Inst{4-3} = 0b01;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine2i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#2,#$Ii)",
tc_9fc3dae0, TypeSUBINSN>, Enc_ed48be {
let Inst{4-3} = 0b10;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combine3i : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u2_0Imm:$Ii),
"$Rdd8 = combine(#3,#$Ii)",
tc_9fc3dae0, TypeSUBINSN>, Enc_ed48be {
let Inst{4-3} = 0b11;
let Inst{12-7} = 0b111000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combinerz : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins GeneralSubRegs:$Rs16),
"$Rdd8 = combine($Rs16,#0)",
tc_9fc3dae0, TypeSUBINSN>, Enc_399e12 {
let Inst{3-3} = 0b1;
let Inst{12-8} = 0b11101;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_combinezr : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins GeneralSubRegs:$Rs16),
"$Rdd8 = combine(#0,$Rs16)",
tc_9fc3dae0, TypeSUBINSN>, Enc_399e12 {
let Inst{3-3} = 0b0;
let Inst{12-8} = 0b11101;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_dec : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, n1Const:$n1),
"$Rd16 = add($Rs16,#$n1)",
tc_0a705168, TypeSUBINSN>, Enc_ee5ed0 {
let Inst{12-8} = 0b10011;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_inc : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = add($Rs16,#1)",
tc_9fc3dae0, TypeSUBINSN>, Enc_97d666 {
let Inst{12-8} = 0b10001;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_seti : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u32_0Imm:$Ii),
"$Rd16 = #$Ii",
tc_9fc3dae0, TypeSUBINSN>, Enc_e39bb2 {
let Inst{12-10} = 0b010;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
let isExtendable = 1;
let opExtendable = 1;
let isExtentSigned = 0;
let opExtentBits = 6;
let opExtentAlign = 0;
}
def SA1_setin1 : HInst<
(outs GeneralSubRegs:$Rd16),
(ins n1Const:$n1),
"$Rd16 = #$n1",
tc_9fc3dae0, TypeSUBINSN>, Enc_7a0ea6 {
let Inst{12-4} = 0b110100000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_sxtb : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = sxtb($Rs16)",
tc_9fc3dae0, TypeSUBINSN>, Enc_97d666 {
let Inst{12-8} = 0b10101;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_sxth : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = sxth($Rs16)",
tc_9fc3dae0, TypeSUBINSN>, Enc_97d666 {
let Inst{12-8} = 0b10100;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_tfr : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = $Rs16",
tc_9fc3dae0, TypeSUBINSN>, Enc_97d666 {
let Inst{12-8} = 0b10000;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_zxtb : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = and($Rs16,#255)",
tc_9fc3dae0, TypeSUBINSN>, Enc_97d666 {
let Inst{12-8} = 0b10111;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SA1_zxth : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16),
"$Rd16 = zxth($Rs16)",
tc_9fc3dae0, TypeSUBINSN>, Enc_97d666 {
let Inst{12-8} = 0b10110;
let hasNewValue = 1;
let opNewValue = 0;
let AsmVariantName = "NonParsable";
let DecoderNamespace = "SUBINSN_A";
}
def SL1_loadri_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii),
"$Rd16 = memw($Rs16+#$Ii)",
tc_17e0d2cd, TypeSUBINSN>, Enc_53dca9 {
let Inst{12-12} = 0b0;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L1";
}
def SL1_loadrub_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii),
"$Rd16 = memub($Rs16+#$Ii)",
tc_17e0d2cd, TypeSUBINSN>, Enc_c175d0 {
let Inst{12-12} = 0b1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L1";
}
def SL2_deallocframe : HInst<
(outs),
(ins),
"deallocframe",
tc_39dfefe8, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111100000000;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let Uses = [FRAMEKEY, R30];
let Defs = [R30, R29, R31];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31 : HInst<
(outs),
(ins),
"jumpr r31",
tc_b4407292, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111111000000;
let isTerminator = 1;
let isIndirectBranch = 1;
let AsmVariantName = "NonParsable";
let cofMax1 = 1;
let isReturn = 1;
let Uses = [R31];
let Defs = [PC];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_f : HInst<
(outs),
(ins),
"if (!p0) jumpr r31",
tc_b4407292, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111111000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let AsmVariantName = "NonParsable";
let cofMax1 = 1;
let isReturn = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_fnew : HInst<
(outs),
(ins),
"if (!p0.new) jumpr:nt r31",
tc_b4407292, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111111000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let cofMax1 = 1;
let isReturn = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_t : HInst<
(outs),
(ins),
"if (p0) jumpr r31",
tc_b4407292, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111111000100;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let AsmVariantName = "NonParsable";
let cofMax1 = 1;
let isReturn = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_jumpr31_tnew : HInst<
(outs),
(ins),
"if (p0.new) jumpr:nt r31",
tc_b4407292, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111111000110;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let cofMax1 = 1;
let isReturn = 1;
let Uses = [P0, R31];
let Defs = [PC];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadrb_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u3_0Imm:$Ii),
"$Rd16 = memb($Rs16+#$Ii)",
tc_17e0d2cd, TypeSUBINSN>, Enc_2fbf3c {
let Inst{12-11} = 0b10;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadrd_sp : HInst<
(outs GeneralDoubleLow8Regs:$Rdd8),
(ins u5_3Imm:$Ii),
"$Rdd8 = memd(r29+#$Ii)",
tc_c4db48cb, TypeSUBINSN>, Enc_86a14b {
let Inst{12-8} = 0b11110;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadrh_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u3_1Imm:$Ii),
"$Rd16 = memh($Rs16+#$Ii)",
tc_17e0d2cd, TypeSUBINSN>, Enc_2bae10 {
let Inst{12-11} = 0b00;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadri_sp : HInst<
(outs GeneralSubRegs:$Rd16),
(ins u5_2Imm:$Ii),
"$Rd16 = memw(r29+#$Ii)",
tc_c4db48cb, TypeSUBINSN>, Enc_51635c {
let Inst{12-9} = 0b1110;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_loadruh_io : HInst<
(outs GeneralSubRegs:$Rd16),
(ins GeneralSubRegs:$Rs16, u3_1Imm:$Ii),
"$Rd16 = memuh($Rs16+#$Ii)",
tc_17e0d2cd, TypeSUBINSN>, Enc_2bae10 {
let Inst{12-11} = 0b01;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return : HInst<
(outs),
(ins),
"dealloc_return",
tc_36153880, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111101000000;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY, R30];
let Defs = [PC, R30, R29, R31];
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_f : HInst<
(outs),
(ins),
"if (!p0) dealloc_return",
tc_36153880, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY, P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_fnew : HInst<
(outs),
(ins),
"if (!p0.new) dealloc_return:nt",
tc_36153880, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY, P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_t : HInst<
(outs),
(ins),
"if (p0) dealloc_return",
tc_36153880, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111101000100;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY, P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SL2_return_tnew : HInst<
(outs),
(ins),
"if (p0.new) dealloc_return:nt",
tc_36153880, TypeSUBINSN>, Enc_e3b0c4 {
let Inst{12-0} = 0b1111101000110;
let isPredicated = 1;
let isTerminator = 1;
let isIndirectBranch = 1;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let isPredicatedNew = 1;
let mayLoad = 1;
let cofMax1 = 1;
let isRestrictNoSlot1Store = 1;
let isReturn = 1;
let Uses = [FRAMEKEY, P0, R30];
let Defs = [PC, R30, R29, R31];
let isTaken = Inst{4};
let DecoderNamespace = "SUBINSN_L2";
}
def SS1_storeb_io : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii, GeneralSubRegs:$Rt16),
"memb($Rs16+#$Ii) = $Rt16",
tc_30b9bb4a, TypeSUBINSN>, Enc_b38ffc {
let Inst{12-12} = 0b1;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S1";
}
def SS1_storew_io : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii, GeneralSubRegs:$Rt16),
"memw($Rs16+#$Ii) = $Rt16",
tc_30b9bb4a, TypeSUBINSN>, Enc_f55a0c {
let Inst{12-12} = 0b0;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S1";
}
def SS2_allocframe : HInst<
(outs),
(ins u5_3Imm:$Ii),
"allocframe(#$Ii)",
tc_49a8207d, TypeSUBINSN>, Enc_6f70ca {
let Inst{3-0} = 0b0000;
let Inst{12-9} = 0b1110;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let Uses = [FRAMEKEY, FRAMELIMIT, R30, R29, R31];
let Defs = [R30, R29];
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storebi0 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii),
"memb($Rs16+#$Ii) = #0",
tc_89e94ad3, TypeSUBINSN>, Enc_84d359 {
let Inst{12-8} = 0b10010;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storebi1 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_0Imm:$Ii),
"memb($Rs16+#$Ii) = #1",
tc_89e94ad3, TypeSUBINSN>, Enc_84d359 {
let Inst{12-8} = 0b10011;
let addrMode = BaseImmOffset;
let accessSize = ByteAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_stored_sp : HInst<
(outs),
(ins s6_3Imm:$Ii, GeneralDoubleLow8Regs:$Rtt8),
"memd(r29+#$Ii) = $Rtt8",
tc_0371abea, TypeSUBINSN>, Enc_b8309d {
let Inst{12-9} = 0b0101;
let addrMode = BaseImmOffset;
let accessSize = DoubleWordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storeh_io : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u3_1Imm:$Ii, GeneralSubRegs:$Rt16),
"memh($Rs16+#$Ii) = $Rt16",
tc_30b9bb4a, TypeSUBINSN>, Enc_625deb {
let Inst{12-11} = 0b00;
let addrMode = BaseImmOffset;
let accessSize = HalfWordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storew_sp : HInst<
(outs),
(ins u5_2Imm:$Ii, GeneralSubRegs:$Rt16),
"memw(r29+#$Ii) = $Rt16",
tc_0371abea, TypeSUBINSN>, Enc_87c142 {
let Inst{12-9} = 0b0100;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let Uses = [R29];
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storewi0 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii),
"memw($Rs16+#$Ii) = #0",
tc_89e94ad3, TypeSUBINSN>, Enc_a6ce9c {
let Inst{12-8} = 0b10000;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def SS2_storewi1 : HInst<
(outs),
(ins GeneralSubRegs:$Rs16, u4_2Imm:$Ii),
"memw($Rs16+#$Ii) = #1",
tc_89e94ad3, TypeSUBINSN>, Enc_a6ce9c {
let Inst{12-8} = 0b10001;
let addrMode = BaseImmOffset;
let accessSize = WordAccess;
let AsmVariantName = "NonParsable";
let mayStore = 1;
let DecoderNamespace = "SUBINSN_S2";
}
def V6_MAP_equb : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_MAP_equb_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equb_ior : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equb_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.ub,$Vv32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_MAP_equh_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh_ior : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equh_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.uh,$Vv32.uh)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_MAP_equw_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw_ior : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_MAP_equw_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.uw,$Vv32.uw)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_extractw : HInst<
(outs IntRegs:$Rd32),
(ins HvxVR:$Vu32, IntRegs:$Rs32),
"$Rd32 = vextract($Vu32,$Rs32)",
tc_540c3da3, TypeLD>, Enc_50e578, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10010010000;
let hasNewValue = 1;
let opNewValue = 0;
let isSolo = 1;
let mayLoad = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_extractw_alt : HInst<
(outs IntRegs:$Rd32),
(ins HvxVR:$Vu32, IntRegs:$Rs32),
"$Rd32.w = vextract($Vu32,$Rs32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_hi : HInst<
(outs HvxVR:$Vd32),
(ins HvxWR:$Vss32),
"$Vd32 = hi($Vss32)",
CVI_VA, TypeCVI_VA>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ld0 : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmem($Rt32)",
PSEUDO, TypeCVI_VM_LD>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldcnp0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if (!$Pv4) $Vd32.cur = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldcnpnt0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if (!$Pv4) $Vd32.cur = vmem($Rt32):nt",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldcp0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if ($Pv4) $Vd32.cur = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldcpnt0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if ($Pv4) $Vd32.cur = vmem($Rt32):nt",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldnp0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if (!$Pv4) $Vd32 = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldnpnt0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if (!$Pv4) $Vd32 = vmem($Rt32):nt",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldnt0 : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmem($Rt32):nt",
PSEUDO, TypeCVI_VM_LD>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldntnt0 : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmem($Rt32):nt",
PSEUDO, TypeMAPPING>, Requires<[HasV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldp0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if ($Pv4) $Vd32 = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldpnt0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if ($Pv4) $Vd32 = vmem($Rt32):nt",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldtnp0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldtnpnt0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32):nt",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldtp0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if ($Pv4) $Vd32.tmp = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldtpnt0 : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if ($Pv4) $Vd32.tmp = vmem($Rt32):nt",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_ldu0 : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vmemu($Rt32)",
PSEUDO, TypeCVI_VM_LD>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lo : HInst<
(outs HvxVR:$Vd32),
(ins HvxWR:$Vss32),
"$Vd32 = lo($Vss32)",
CVI_VA, TypeCVI_VA>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lvsplatb : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32.b = vsplat($Rt32)",
tc_c4edf264, TypeCVI_VX>, Enc_a5ed8a, Requires<[UseHVXV62]> {
let Inst{13-5} = 0b000000010;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lvsplath : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32.h = vsplat($Rt32)",
tc_c4edf264, TypeCVI_VX>, Enc_a5ed8a, Requires<[UseHVXV62]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_lvsplatw : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = vsplat($Rt32)",
tc_c4edf264, TypeCVI_VX_LATE>, Enc_a5ed8a, Requires<[UseHVXV60]> {
let Inst{13-5} = 0b000000001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_and : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4, HvxQR:$Qt4),
"$Qd4 = and($Qs4,$Qt4)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_134437, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000000;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_and_n : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4, HvxQR:$Qt4),
"$Qd4 = and($Qs4,!$Qt4)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_134437, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000101;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_not : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4),
"$Qd4 = not($Qs4)",
tc_0ec46cf9, TypeCVI_VA>, Enc_bfbf03, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000010;
let Inst{13-10} = 0b0000;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_or : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4, HvxQR:$Qt4),
"$Qd4 = or($Qs4,$Qt4)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_134437, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000001;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_or_n : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4, HvxQR:$Qt4),
"$Qd4 = or($Qs4,!$Qt4)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_134437, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000100;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_scalar2 : HInst<
(outs HvxQR:$Qd4),
(ins IntRegs:$Rt32),
"$Qd4 = vsetq($Rt32)",
tc_5bf8afbb, TypeCVI_VP>, Enc_7222b7, Requires<[UseHVXV60]> {
let Inst{13-2} = 0b000000010001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_scalar2v2 : HInst<
(outs HvxQR:$Qd4),
(ins IntRegs:$Rt32),
"$Qd4 = vsetq2($Rt32)",
tc_5bf8afbb, TypeCVI_VP>, Enc_7222b7, Requires<[UseHVXV62]> {
let Inst{13-2} = 0b000000010011;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_pred_xor : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4, HvxQR:$Qt4),
"$Qd4 = xor($Qs4,$Qt4)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_134437, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000011;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_shuffeqh : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4, HvxQR:$Qt4),
"$Qd4.b = vshuffe($Qs4.h,$Qt4.h)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_134437, Requires<[UseHVXV62]> {
let Inst{7-2} = 0b000110;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_shuffeqw : HInst<
(outs HvxQR:$Qd4),
(ins HvxQR:$Qs4, HvxQR:$Qt4),
"$Qd4.h = vshuffe($Qs4.w,$Qt4.w)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_134437, Requires<[UseHVXV62]> {
let Inst{7-2} = 0b000111;
let Inst{13-10} = 0b0000;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_st0 : HInst<
(outs),
(ins IntRegs:$Rt32, HvxVR:$Vs32),
"vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stn0 : HInst<
(outs),
(ins IntRegs:$Rt32, HvxVR:$Os8),
"vmem($Rt32) = $Os8.new",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 1;
}
def V6_stnnt0 : HInst<
(outs),
(ins IntRegs:$Rt32, HvxVR:$Os8),
"vmem($Rt32):nt = $Os8.new",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 1;
}
def V6_stnp0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnpnt0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnq0 : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnqnt0 : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stnt0 : HInst<
(outs),
(ins IntRegs:$Rt32, HvxVR:$Vs32),
"vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stp0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if ($Pv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stpnt0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if ($Pv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stq0 : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if ($Qv4) vmem($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stqnt0 : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if ($Qv4) vmem($Rt32):nt = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stu0 : HInst<
(outs),
(ins IntRegs:$Rt32, HvxVR:$Vs32),
"vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stunp0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if (!$Pv4) vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_stup0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, HvxVR:$Vs32),
"if ($Pv4) vmemu($Rt32) = $Vs32",
PSEUDO, TypeCVI_VM_ST>, Requires<[UseHVXV60]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32Ub_ai : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"$Vd32 = vmemu($Rt32+#$Ii)",
tc_a7e6707d, TypeCVI_VM_VP_LDU>, Enc_f3f408, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32Ub_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"$Vd32 = vmemu($Rx32++#$Ii)",
tc_3c56e5ce, TypeCVI_VM_VP_LDU>, Enc_a255dc, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32Ub_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmemu($Rx32++$Mu2)",
tc_3c56e5ce, TypeCVI_VM_VP_LDU>, Enc_2ebe3b, Requires<[UseHVXV60]> {
let Inst{12-5} = 0b00000111;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_ai : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"$Vd32 = vmem($Rt32+#$Ii)",
tc_c0749f3c, TypeCVI_VM_LD>, Enc_f3f408, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_ai";
let isCVLoadable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_cur_ai : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"$Vd32.cur = vmem($Rt32+#$Ii)",
tc_c0749f3c, TypeCVI_VM_LD>, Enc_f3f408, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b001;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_cur_npred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rt32+#$Ii)",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_cur_npred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++#$Ii)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_npred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++$Mu2)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000101;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"$Vd32.cur = vmem($Rx32++#$Ii)",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_a255dc, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b001;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.cur = vmem($Rx32++$Mu2)",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_2ebe3b, Requires<[UseHVXV60]>, PredRel {
let Inst{12-5} = 0b00000001;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rt32+#$Ii)",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_cur_pred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rx32++#$Ii)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_cur_pred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.cur = vmem($Rx32++$Mu2)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000100;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_cur_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_npred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rt32+#$Ii)",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_npred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rx32++#$Ii)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_npred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32 = vmem($Rx32++$Mu2)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000011;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_ai : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"$Vd32 = vmem($Rt32+#$Ii):nt",
tc_c0749f3c, TypeCVI_VM_LD>, Enc_f3f408, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_ai";
let isCVLoadable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_cur_ai : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"$Vd32.cur = vmem($Rt32+#$Ii):nt",
tc_c0749f3c, TypeCVI_VM_LD>, Enc_f3f408, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b001;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_cur_npred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rt32+#$Ii):nt",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_cur_npred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++#$Ii):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_npred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.cur = vmem($Rx32++$Mu2):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000101;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"$Vd32.cur = vmem($Rx32++#$Ii):nt",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_a255dc, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b001;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.cur = vmem($Rx32++$Mu2):nt",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_2ebe3b, Requires<[UseHVXV60]>, PredRel {
let Inst{12-5} = 0b00000001;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rt32+#$Ii):nt",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_cur_pred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if ($Pv4) $Vd32.cur = vmem($Rx32++#$Ii):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_cur_pred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.cur = vmem($Rx32++$Mu2):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000100;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let CVINew = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_cur_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_npred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rt32+#$Ii):nt",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b011;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_npred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if (!$Pv4) $Vd32 = vmem($Rx32++#$Ii):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_npred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32 = vmem($Rx32++$Mu2):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000011;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"$Vd32 = vmem($Rx32++#$Ii):nt",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_a255dc, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_pi";
let isCVLoadable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmem($Rx32++$Mu2):nt",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_2ebe3b, Requires<[UseHVXV60]>, PredRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_ppu";
let isCVLoadable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rt32+#$Ii):nt",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_pred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rx32++#$Ii):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_pred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32 = vmem($Rx32++$Mu2):nt",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000010;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_ai : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"$Vd32.tmp = vmem($Rt32+#$Ii):nt",
tc_52447ecc, TypeCVI_VM_TMP_LD>, Enc_f3f408, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_tmp_npred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32+#$Ii):nt",
tc_3904b926, TypeCVI_VM_TMP_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_tmp_npred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++#$Ii):nt",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_npred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++$Mu2):nt",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"$Vd32.tmp = vmem($Rx32++#$Ii):nt",
tc_663c80a7, TypeCVI_VM_TMP_LD>, Enc_a255dc, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.tmp = vmem($Rx32++$Mu2):nt",
tc_663c80a7, TypeCVI_VM_TMP_LD>, Enc_2ebe3b, Requires<[UseHVXV60]>, PredRel {
let Inst{12-5} = 0b00000010;
let Inst{31-21} = 0b00101011010;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rt32+#$Ii):nt",
tc_3904b926, TypeCVI_VM_TMP_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_nt_tmp_pred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++#$Ii):nt",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_nt_tmp_pred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++$Mu2):nt",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011110;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isNonTemporal = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_nt_tmp_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"$Vd32 = vmem($Rx32++#$Ii)",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_a255dc, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_pi";
let isCVLoadable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32 = vmem($Rx32++$Mu2)",
tc_1ba8a0cd, TypeCVI_VM_LD>, Enc_2ebe3b, Requires<[UseHVXV60]>, PredRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_ppu";
let isCVLoadable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rt32+#$Ii)",
tc_abe8c3b2, TypeCVI_VM_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_pred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if ($Pv4) $Vd32 = vmem($Rx32++#$Ii)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_pred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32 = vmem($Rx32++$Mu2)",
tc_453fe68d, TypeCVI_VM_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000010;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_ai : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"$Vd32.tmp = vmem($Rt32+#$Ii)",
tc_52447ecc, TypeCVI_VM_TMP_LD>, Enc_f3f408, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_tmp_npred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rt32+#$Ii)",
tc_3904b926, TypeCVI_VM_TMP_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_tmp_npred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++#$Ii)",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_npred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if (!$Pv4) $Vd32.tmp = vmem($Rx32++$Mu2)",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"$Vd32.tmp = vmem($Rx32++#$Ii)",
tc_663c80a7, TypeCVI_VM_TMP_LD>, Enc_a255dc, Requires<[UseHVXV60]>, PredRel {
let Inst{7-5} = 0b010;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"$Vd32.tmp = vmem($Rx32++$Mu2)",
tc_663c80a7, TypeCVI_VM_TMP_LD>, Enc_2ebe3b, Requires<[UseHVXV60]>, PredRel {
let Inst{12-5} = 0b00000010;
let Inst{31-21} = 0b00101011000;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pred_ai : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rt32+#$Ii)",
tc_3904b926, TypeCVI_VM_TMP_LD>, Enc_8d8a30, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vL32b_tmp_pred_pi : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++#$Ii)",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_58a8bf, Requires<[UseHVXV62]>, PredRel {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vL32b_tmp_pred_ppu : HInst<
(outs HvxVR:$Vd32, IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) $Vd32.tmp = vmem($Rx32++$Mu2)",
tc_b9db8205, TypeCVI_VM_TMP_LD>, Enc_f8c1c4, Requires<[UseHVXV62]>, PredRel {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011100;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isCVLoad = 1;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let BaseOpcode = "V6_vL32b_tmp_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"vmemu($Rt32+#$Ii) = $Vs32",
tc_f21e8abb, TypeCVI_VM_STU>, Enc_c9e3bc, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32Ub_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Pv4) vmemu($Rt32+#$Ii) = $Vs32",
tc_131f1c81, TypeCVI_VM_STU>, Enc_27b757, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32Ub_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Pv4) vmemu($Rx32++#$Ii) = $Vs32",
tc_c7039829, TypeCVI_VM_STU>, Enc_865390, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if (!$Pv4) vmemu($Rx32++$Mu2) = $Vs32",
tc_c7039829, TypeCVI_VM_STU>, Enc_1ef990, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-5} = 0b000111;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"vmemu($Rx32++#$Ii) = $Vs32",
tc_e2d2e9e5, TypeCVI_VM_STU>, Enc_b62ef7, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b111;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"vmemu($Rx32++$Mu2) = $Vs32",
tc_e2d2e9e5, TypeCVI_VM_STU>, Enc_d15d19, Requires<[UseHVXV60]>, NewValueRel {
let Inst{12-5} = 0b00000111;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if ($Pv4) vmemu($Rt32+#$Ii) = $Vs32",
tc_131f1c81, TypeCVI_VM_STU>, Enc_27b757, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ai";
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32Ub_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if ($Pv4) vmemu($Rx32++#$Ii) = $Vs32",
tc_c7039829, TypeCVI_VM_STU>, Enc_865390, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_pi";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32Ub_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if ($Pv4) vmemu($Rx32++$Mu2) = $Vs32",
tc_c7039829, TypeCVI_VM_STU>, Enc_1ef990, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-5} = 0b000110;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32Ub_ppu";
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"vmem($Rt32+#$Ii) = $Vs32",
tc_c5dba46e, TypeCVI_VM_ST>, Enc_c9e3bc, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_new_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Os8),
"vmem($Rt32+#$Ii) = $Os8.new",
tc_ab23f776, TypeCVI_VM_NEW_ST>, Enc_f77fbc, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 2;
}
def V6_vS32b_new_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Os8),
"if (!$Pv4) vmem($Rt32+#$Ii) = $Os8.new",
tc_7177e272, TypeCVI_VM_NEW_ST>, Enc_f7430e, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01101;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_new_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Os8),
"if (!$Pv4) vmem($Rx32++#$Ii) = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_784502, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Os8),
"if (!$Pv4) vmem($Rx32++$Mu2) = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_372c9d, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-3} = 0b00001101;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Os8),
"vmem($Rx32++#$Ii) = $Os8.new",
tc_6942b6e0, TypeCVI_VM_NEW_ST>, Enc_1aaec1, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Os8),
"vmem($Rx32++$Mu2) = $Os8.new",
tc_6942b6e0, TypeCVI_VM_NEW_ST>, Enc_cf1927, Requires<[UseHVXV60]>, NewValueRel {
let Inst{12-3} = 0b0000000100;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Os8),
"if ($Pv4) vmem($Rt32+#$Ii) = $Os8.new",
tc_7177e272, TypeCVI_VM_NEW_ST>, Enc_f7430e, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01000;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_new_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Os8),
"if ($Pv4) vmem($Rx32++#$Ii) = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_784502, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_new_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Os8),
"if ($Pv4) vmem($Rx32++$Mu2) = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_372c9d, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-3} = 0b00001000;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rt32+#$Ii) = $Vs32",
tc_a02a10a8, TypeCVI_VM_ST>, Enc_27b757, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rx32++#$Ii) = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_865390, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rx32++$Mu2) = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_1ef990, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nqpred_ai : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rt32+#$Ii) = $Vs32",
tc_447d9895, TypeCVI_VM_ST>, Enc_2ea740, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000100;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nqpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rx32++#$Ii) = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_0b51ce, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nqpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rx32++$Mu2) = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_4dff07, Requires<[UseHVXV60]> {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011100;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"vmem($Rt32+#$Ii):nt = $Vs32",
tc_c5dba46e, TypeCVI_VM_ST>, Enc_c9e3bc, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000011;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_new_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Os8),
"vmem($Rt32+#$Ii):nt = $Os8.new",
tc_ab23f776, TypeCVI_VM_NEW_ST>, Enc_f77fbc, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000011;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 2;
}
def V6_vS32b_nt_new_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Os8),
"if (!$Pv4) vmem($Rt32+#$Ii):nt = $Os8.new",
tc_7177e272, TypeCVI_VM_NEW_ST>, Enc_f7430e, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01111;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_nt_new_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Os8),
"if (!$Pv4) vmem($Rx32++#$Ii):nt = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_784502, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Os8),
"if (!$Pv4) vmem($Rx32++$Mu2):nt = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_372c9d, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-3} = 0b00001111;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Os8),
"vmem($Rx32++#$Ii):nt = $Os8.new",
tc_6942b6e0, TypeCVI_VM_NEW_ST>, Enc_1aaec1, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b00100;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001011;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Os8),
"vmem($Rx32++$Mu2):nt = $Os8.new",
tc_6942b6e0, TypeCVI_VM_NEW_ST>, Enc_cf1927, Requires<[UseHVXV60]>, NewValueRel {
let Inst{12-3} = 0b0000000100;
let Inst{31-21} = 0b00101011011;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Os8),
"if ($Pv4) vmem($Rt32+#$Ii):nt = $Os8.new",
tc_7177e272, TypeCVI_VM_NEW_ST>, Enc_f7430e, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01010;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 3;
}
def V6_vS32b_nt_new_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Os8),
"if ($Pv4) vmem($Rx32++#$Ii):nt = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_784502, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-3} = 0b01010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_new_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Os8),
"if ($Pv4) vmem($Rx32++$Mu2):nt = $Os8.new",
tc_e99d4c2e, TypeCVI_VM_NEW_ST>, Enc_372c9d, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-3} = 0b00001010;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNVStore = 1;
let CVINew = 1;
let isNewValue = 1;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let DecoderNamespace = "EXT_mmvec";
let opNewValue = 4;
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_npred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rt32+#$Ii):nt = $Vs32",
tc_a02a10a8, TypeCVI_VM_ST>, Enc_27b757, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_npred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rx32++#$Ii):nt = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_865390, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_npred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if (!$Pv4) vmem($Rx32++$Mu2):nt = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_1ef990, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let isPredicatedFalse = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_nqpred_ai : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rt32+#$Ii):nt = $Vs32",
tc_447d9895, TypeCVI_VM_ST>, Enc_2ea740, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101000110;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_nqpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rx32++#$Ii):nt = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_0b51ce, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_nqpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if (!$Qv4) vmem($Rx32++$Mu2):nt = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_4dff07, Requires<[UseHVXV60]> {
let Inst{10-5} = 0b000001;
let Inst{31-21} = 0b00101011110;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"vmem($Rx32++#$Ii):nt = $Vs32",
tc_3e2aaafc, TypeCVI_VM_ST>, Enc_b62ef7, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001011;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"vmem($Rx32++$Mu2):nt = $Vs32",
tc_3e2aaafc, TypeCVI_VM_ST>, Enc_d15d19, Requires<[UseHVXV60]>, NewValueRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011011;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if ($Pv4) vmem($Rt32+#$Ii):nt = $Vs32",
tc_a02a10a8, TypeCVI_VM_ST>, Enc_27b757, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000111;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if ($Pv4) vmem($Rx32++#$Ii):nt = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_865390, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if ($Pv4) vmem($Rx32++$Mu2):nt = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_1ef990, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011111;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_qpred_ai : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if ($Qv4) vmem($Rt32+#$Ii):nt = $Vs32",
tc_447d9895, TypeCVI_VM_ST>, Enc_2ea740, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000110;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_nt_qpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if ($Qv4) vmem($Rx32++#$Ii):nt = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_0b51ce, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001110;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_nt_qpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if ($Qv4) vmem($Rx32++$Mu2):nt = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_4dff07, Requires<[UseHVXV60]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011110;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let isNonTemporal = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"vmem($Rx32++#$Ii) = $Vs32",
tc_3e2aaafc, TypeCVI_VM_ST>, Enc_b62ef7, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"vmem($Rx32++$Mu2) = $Vs32",
tc_3e2aaafc, TypeCVI_VM_ST>, Enc_d15d19, Requires<[UseHVXV60]>, NewValueRel {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let isNVStorable = 1;
let isPredicable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if ($Pv4) vmem($Rt32+#$Ii) = $Vs32",
tc_a02a10a8, TypeCVI_VM_ST>, Enc_27b757, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000101;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ai";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if ($Pv4) vmem($Rx32++#$Ii) = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_865390, Requires<[UseHVXV60]>, NewValueRel {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_pi";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if ($Pv4) vmem($Rx32++$Mu2) = $Vs32",
tc_54a0dc47, TypeCVI_VM_ST>, Enc_1ef990, Requires<[UseHVXV60]>, NewValueRel {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011101;
let isPredicated = 1;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let BaseOpcode = "V6_vS32b_ppu";
let isNVStorable = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_qpred_ai : HInst<
(outs),
(ins HvxQR:$Qv4, IntRegs:$Rt32, s4_0Imm:$Ii, HvxVR:$Vs32),
"if ($Qv4) vmem($Rt32+#$Ii) = $Vs32",
tc_447d9895, TypeCVI_VM_ST>, Enc_2ea740, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101000100;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_qpred_pi : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, s3_0Imm:$Ii, HvxVR:$Vs32),
"if ($Qv4) vmem($Rx32++#$Ii) = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_0b51ce, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101001100;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_qpred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins HvxQR:$Qv4, IntRegs:$Rx32in, ModRegs:$Mu2, HvxVR:$Vs32),
"if ($Qv4) vmem($Rx32++$Mu2) = $Vs32",
tc_191381c1, TypeCVI_VM_ST>, Enc_4dff07, Requires<[UseHVXV60]> {
let Inst{10-5} = 0b000000;
let Inst{31-21} = 0b00101011100;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_srls_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"vmem($Rt32+#$Ii):scatter_release",
tc_3ce09744, TypeCVI_SCATTER_NEW_RST>, Enc_ff3442, Requires<[UseHVXV65]> {
let Inst{7-0} = 0b00101000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101000001;
let addrMode = BaseImmOffset;
let accessSize = HVXVectorAccess;
let CVINew = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vS32b_srls_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"vmem($Rx32++#$Ii):scatter_release",
tc_20a4bbec, TypeCVI_SCATTER_NEW_RST>, Enc_6c9ee0, Requires<[UseHVXV65]> {
let Inst{7-0} = 0b00101000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101001001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let CVINew = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vS32b_srls_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"vmem($Rx32++$Mu2):scatter_release",
tc_20a4bbec, TypeCVI_SCATTER_NEW_RST>, Enc_44661f, Requires<[UseHVXV65]> {
let Inst{12-0} = 0b0000000101000;
let Inst{31-21} = 0b00101011001;
let addrMode = PostInc;
let accessSize = HVXVectorAccess;
let CVINew = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_vabsb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.b = vabs($Vu32.b)",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vabsb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsb_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.b = vabs($Vu32.b):sat",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsb_sat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vabsb($Vu32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vabsdiff($Vu32.h,$Vv32.h)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vabsdiffh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vabsdiff($Vu32.ub,$Vv32.ub)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vabsdiffub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vabsdiff($Vu32.uh,$Vv32.uh)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vabsdiffuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uw = vabsdiff($Vu32.w,$Vv32.w)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsdiffw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vabsdiffw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.h = vabs($Vu32.h)",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vabsh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.h = vabs($Vu32.h):sat",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsh_sat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vabsh($Vu32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.ub = vabs($Vu32.b)",
tc_0ec46cf9, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.uh = vabs($Vu32.h)",
tc_0ec46cf9, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsuw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.uw = vabs($Vu32.w)",
tc_0ec46cf9, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.w = vabs($Vu32.w)",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vabsw($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.w = vabs($Vu32.w):sat",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vabsw_sat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vabsw($Vu32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vadd($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaddb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.b = vadd($Vuu32.b,$Vvv32.b)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddb_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vaddb($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbnq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4) $Vx32.b += $Vu32.b",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbnq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4.b) $Vx32.b += $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4) $Vx32.b += $Vu32.b",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4.b) $Vx32.b += $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddbsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vadd($Vu32.b,$Vv32.b):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaddb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.b = vadd($Vuu32.b,$Vvv32.b):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddbsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vaddb($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddcarry : HInst<
(outs HvxVR:$Vd32, HvxQR:$Qx4),
(ins HvxVR:$Vu32, HvxVR:$Vv32, HvxQR:$Qx4in),
"$Vd32.w = vadd($Vu32.w,$Vv32.w,$Qx4):carry",
tc_7e6a3e89, TypeCVI_VA>, Enc_b43b67, Requires<[UseHVXV62]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vaddcarryo : HInst<
(outs HvxVR:$Vd32, HvxQR:$Qe4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w,$Qe4 = vadd($Vu32.w,$Vv32.w):carry",
tc_e35c1e93, TypeCOPROC_VX>, Enc_c1d806, Requires<[UseHVXV66]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011101101;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddcarrysat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, HvxQR:$Qs4),
"$Vd32.w = vadd($Vu32.w,$Vv32.w,$Qs4):carry:sat",
tc_257f6f7c, TypeCVI_VA>, Enc_e0820b, Requires<[UseHVXV66]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011101100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddclbh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vadd(vclb($Vu32.h),$Vv32.h)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddclbw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vadd(vclb($Vu32.w),$Vv32.w)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vadd($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.h = vadd($Vuu32.h,$Vvv32.h)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddh_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vaddh($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhnq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4) $Vx32.h += $Vu32.h",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhnq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4.h) $Vx32.h += $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4) $Vx32.h += $Vu32.h",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4.h) $Vx32.h += $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vadd($Vu32.h,$Vv32.h):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaddh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.h = vadd($Vuu32.h,$Vvv32.h):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vaddh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhw : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.w = vadd($Vu32.h,$Vv32.h)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddhw_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.w += vadd($Vu32.h,$Vv32.h)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddhw_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddhw_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vaddh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.h = vadd($Vu32.ub,$Vv32.ub)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubh_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.h += vadd($Vu32.ub,$Vv32.ub)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddubh_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vaddub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vaddubh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vaddub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vadd($Vu32.ub,$Vv32.ub):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaddub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.ub = vadd($Vuu32.ub,$Vvv32.ub):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddubsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vaddub($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddububb_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vadd($Vu32.ub,$Vv32.b):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vadd($Vu32.uh,$Vv32.uh):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vadduh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.uh = vadd($Vuu32.uh,$Vvv32.uh):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vadduh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhw : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.w = vadd($Vu32.uh,$Vv32.uh)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduhw_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.w += vadd($Vu32.uh,$Vv32.uh)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vadduhw_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vadduh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vadduhw_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vadduh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uw = vadd($Vu32.uw,$Vv32.uw):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vadduw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.uw = vadd($Vuu32.uw,$Vvv32.uw):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vadduwsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vadduw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vadd($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaddw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.w = vadd($Vuu32.w,$Vvv32.w)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddw_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vaddw($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwnq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4) $Vx32.w += $Vu32.w",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwnq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4.w) $Vx32.w += $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4) $Vx32.w += $Vu32.w",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4.w) $Vx32.w += $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaddwsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vadd($Vu32.w,$Vv32.w):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaddw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.w = vadd($Vuu32.w,$Vvv32.w):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaddwsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vaddw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_valignb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = valign($Vu32,$Vv32,$Rt8)",
tc_56e64202, TypeCVI_VP>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_valignbi : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, u3_0Imm:$Ii),
"$Vd32 = valign($Vu32,$Vv32,#$Ii)",
tc_56e64202, TypeCVI_VP>, Enc_0b2e5b, Requires<[UseHVXV60]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vand : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vand($Vu32,$Vv32)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandnqrt : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qu4, IntRegs:$Rt32),
"$Vd32 = vand(!$Qu4,$Rt32)",
tc_ac4046bc, TypeCVI_VX>, Enc_7b7ba8, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b101;
let Inst{13-10} = 0b0001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandnqrt_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxQR:$Qu4, IntRegs:$Rt32),
"$Vx32 |= vand(!$Qu4,$Rt32)",
tc_2e8f5f6e, TypeCVI_VX>, Enc_895bd9, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b011;
let Inst{13-10} = 0b1001;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandnqrt_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxQR:$Qu4, IntRegs:$Rt32),
"$Vx32.ub |= vand(!$Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandnqrt_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qu4, IntRegs:$Rt32),
"$Vd32.ub = vand(!$Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandqrt : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qu4, IntRegs:$Rt32),
"$Vd32 = vand($Qu4,$Rt32)",
tc_ac4046bc, TypeCVI_VX_LATE>, Enc_7b7ba8, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-10} = 0b0000;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandqrt_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxQR:$Qu4, IntRegs:$Rt32),
"$Vx32 |= vand($Qu4,$Rt32)",
tc_2e8f5f6e, TypeCVI_VX_LATE>, Enc_895bd9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-10} = 0b1000;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandqrt_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxQR:$Qu4, IntRegs:$Rt32),
"$Vx32.ub |= vand($Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vandqrt_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qu4, IntRegs:$Rt32),
"$Vd32.ub = vand($Qu4.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvnqv : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qv4, HvxVR:$Vu32),
"$Vd32 = vand(!$Qv4,$Vu32)",
tc_56c4f9fe, TypeCVI_VA>, Enc_c4dc92, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvqv : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qv4, HvxVR:$Vu32),
"$Vd32 = vand($Qv4,$Vu32)",
tc_56c4f9fe, TypeCVI_VA>, Enc_c4dc92, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvrt : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Qd4 = vand($Vu32,$Rt32)",
tc_ac4046bc, TypeCVI_VX_LATE>, Enc_0f8bab, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b010010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vandvrt_acc : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Qx4 |= vand($Vu32,$Rt32)",
tc_2e8f5f6e, TypeCVI_VX_LATE>, Enc_adf111, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vandvrt_acc_alt : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Qx4.ub |= vand($Vu32.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vandvrt_alt : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Qd4.ub = vand($Vu32.ub,$Rt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vasl($Vu32.h,$Rt32)",
tc_7417e785, TypeCVI_VS>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslh_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vasl($Vu32.h,$Rt32)",
tc_309dbb4f, TypeCVI_VS>, Enc_5138b3, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslh_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vaslh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vaslh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslhv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vasl($Vu32.h,$Vv32.h)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslhv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaslh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vasl($Vu32.w,$Rt32)",
tc_7417e785, TypeCVI_VS>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslw_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vasl($Vu32.w,$Rt32)",
tc_309dbb4f, TypeCVI_VS>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslw_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vaslw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vaslw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vaslw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslwv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vasl($Vu32.w,$Vv32.w)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vaslwv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vaslw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasr_into : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.w = vasrinto($Vu32.w,$Vv32.w)",
tc_df80eeb0, TypeCVI_VP_VS>, Enc_3fc427, Requires<[UseHVXV66]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011010101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vasr_into_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 = vasrinto($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV66]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vasrh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vasr($Vu32.h,$Rt32)",
tc_7417e785, TypeCVI_VS>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrh_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vasr($Vu32.h,$Rt32)",
tc_309dbb4f, TypeCVI_VS>, Enc_5138b3, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrh_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vasrh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vasrh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhbrndsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vasr($Vu32.h,$Vv32.h,$Rt8):rnd:sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhbrndsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrhb($Vu32,$Vv32,$Rt8):rnd:sat",
tc_16ff9ef8, TypeMAPPING>, Requires<[HasV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrhbsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vasr($Vu32.h,$Vv32.h,$Rt8):sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhubrndsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.h,$Vv32.h,$Rt8):rnd:sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhubrndsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrhub($Vu32,$Vv32,$Rt8):rnd:sat",
tc_16ff9ef8, TypeMAPPING>, Requires<[HasV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrhubsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.h,$Vv32.h,$Rt8):sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhubsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrhub($Vu32,$Vv32,$Rt8):sat",
tc_16ff9ef8, TypeMAPPING>, Requires<[HasV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrhv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vasr($Vu32.h,$Vv32.h)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrhv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vasrh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasruhubrndsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.uh,$Vv32.uh,$Rt8):rnd:sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasruhubsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.ub = vasr($Vu32.uh,$Vv32.uh,$Rt8):sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasruwuhrndsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.uw,$Vv32.uw,$Rt8):rnd:sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasruwuhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.uw,$Vv32.uw,$Rt8):sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vasr($Vu32.w,$Rt32)",
tc_7417e785, TypeCVI_VS>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrw_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vasr($Vu32.w,$Rt32)",
tc_309dbb4f, TypeCVI_VS>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrw_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vasrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vasrw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vasrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8)",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwh($Vu32,$Vv32,$Rt8)",
tc_16ff9ef8, TypeMAPPING>, Requires<[HasV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwhrndsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8):rnd:sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwhrndsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwh($Vu32,$Vv32,$Rt8):rnd:sat",
tc_16ff9ef8, TypeMAPPING>, Requires<[HasV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.h = vasr($Vu32.w,$Vv32.w,$Rt8):sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwhsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwh($Vu32,$Vv32,$Rt8):sat",
tc_16ff9ef8, TypeMAPPING>, Requires<[HasV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwuhrndsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.w,$Vv32.w,$Rt8):rnd:sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwuhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.uh = vasr($Vu32.w,$Vv32.w,$Rt8):sat",
tc_16ff9ef8, TypeCVI_VS>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwuhsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vasrwuh($Vu32,$Vv32,$Rt8):sat",
tc_16ff9ef8, TypeMAPPING>, Requires<[HasV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def V6_vasrwv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vasr($Vu32.w,$Vv32.w)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vasrwv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vasrw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vassign : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = $Vu32",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vassignp : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32),
"$Vdd32 = $Vuu32",
CVI_VA, TypeCVI_VA_DV>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vavg($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgbrnd : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vavg($Vu32.b,$Vv32.b):rnd",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgbrnd_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgb($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vavg($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavghrnd : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vavg($Vu32.h,$Vv32.h):rnd",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavghrnd_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgh($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vavg($Vu32.ub,$Vv32.ub)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgubrnd : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vavg($Vu32.ub,$Vv32.ub):rnd",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgubrnd_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgub($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vavg($Vu32.uh,$Vv32.uh)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavguh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguhrnd : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vavg($Vu32.uh,$Vv32.uh):rnd",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguhrnd_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavguh($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uw = vavg($Vu32.uw,$Vv32.uw)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavguw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguwrnd : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uw = vavg($Vu32.uw,$Vv32.uw):rnd",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavguwrnd_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavguw($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vavg($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgwrnd : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vavg($Vu32.w,$Vv32.w):rnd",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vavgwrnd_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vavgw($Vu32,$Vv32):rnd",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vccombine : HInst<
(outs HvxWR:$Vdd32),
(ins PredRegs:$Ps4, HvxVR:$Vu32, HvxVR:$Vv32),
"if ($Ps4) $Vdd32 = vcombine($Vu32,$Vv32)",
tc_af25efd9, TypeCVI_VA_DV>, Enc_8c2412, Requires<[UseHVXV60]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011010011;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0h : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.uh = vcl0($Vu32.uh)",
tc_51d0ecc3, TypeCVI_VS>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0h_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vcl0h($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0w : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.uw = vcl0($Vu32.uw)",
tc_51d0ecc3, TypeCVI_VS>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcl0w_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vcl0w($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcmov : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Ps4, HvxVR:$Vu32),
"if ($Ps4) $Vd32 = $Vu32",
tc_3aacf4a8, TypeCVI_VA>, Enc_770858, Requires<[UseHVXV60]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001101000000000;
let isPredicated = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vcombine : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vcombine($Vu32,$Vv32)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let isRegSequence = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vd0 : HInst<
(outs HvxVR:$Vd32),
(ins),
"$Vd32 = #0",
CVI_VA, TypeCVI_VA>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdd0 : HInst<
(outs HvxWR:$Vdd32),
(ins),
"$Vdd32 = #0",
tc_718b5c53, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdeal : HInst<
(outs HvxVR:$Vy32, HvxVR:$Vx32),
(ins HvxVR:$Vy32in, HvxVR:$Vx32in, IntRegs:$Rt32),
"vdeal($Vy32,$Vx32,$Rt32)",
tc_561aaa58, TypeCVI_VP_VS>, Enc_989021, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001111;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vdealb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.b = vdeal($Vu32.b)",
tc_946013d8, TypeCVI_VP>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealb4w : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vdeale($Vu32.b,$Vv32.b)",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealb4w_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vdealb4w($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vdealb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.h = vdeal($Vu32.h)",
tc_946013d8, TypeCVI_VP>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vdealh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdealvdd : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32 = vdeal($Vu32,$Vv32,$Rt8)",
tc_87adc037, TypeCVI_VP_VS>, Enc_24a7dc, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdelta : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vdelta($Vu32,$Vv32)",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vdmpy($Vu32.ub,$Rt32.b)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vdmpy($Vu32.ub,$Rt32.b)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpybus_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpybus_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vdmpy($Vuu32.ub,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpybus_dv_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vdmpy($Vuu32.ub,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpybus_dv_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpybus_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.b)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.b)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhb_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vdmpy($Vuu32.h,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhb_dv_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vdmpy($Vuu32.h,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpyhb_dv_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdmpyhb_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhisat : HInst<
(outs HvxVR:$Vd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vuu32.h,$Rt32.h):sat",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_0e41fa, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhisat_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vuu32.h,$Rt32.h):sat",
tc_660769f1, TypeCVI_VX_DV>, Enc_cc857d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhisat_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vx32 += vdmpyh($Vuu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhisat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vd32 = vdmpyh($Vuu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.h):sat",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsat_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.h):sat",
tc_660769f1, TypeCVI_VX_DV>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsat_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsuisat : HInst<
(outs HvxVR:$Vd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vuu32.h,$Rt32.uh,#1):sat",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_0e41fa, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsuisat_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vuu32.h,$Rt32.uh,#1):sat",
tc_660769f1, TypeCVI_VX_DV>, Enc_cc857d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsuisat_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhsu($Vuu32,$Rt32,#1):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsuisat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhsu($Vuu32,$Rt32,#1):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsusat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vdmpy($Vu32.h,$Rt32.uh):sat",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhsusat_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vdmpy($Vu32.h,$Rt32.uh):sat",
tc_660769f1, TypeCVI_VX_DV>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsusat_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vdmpyhsu($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhsusat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vdmpyhsu($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhvsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vdmpy($Vu32.h,$Vv32.h):sat",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdmpyhvsat_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.w += vdmpy($Vu32.h,$Vv32.h):sat",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhvsat_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vdmpyh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vdmpyhvsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vdmpyh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdsaduh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.uw = vdsad($Vuu32.uh,$Rt32.uh)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vdsaduh_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.uw += vdsad($Vuu32.uh,$Rt32.uh)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdsaduh_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vdsaduh($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vdsaduh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vdsaduh($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_veqb : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.eq($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_veqb_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.b,$Vv32.b)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqb_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.b,$Vv32.b)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b010000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqb_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.b,$Vv32.b)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b100000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.eq($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_veqh_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.h,$Vv32.h)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.h,$Vv32.h)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b010001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqh_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.h,$Vv32.h)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b100001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.eq($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_veqw_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.eq($Vu32.w,$Vv32.w)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.eq($Vu32.w,$Vv32.w)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b010010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_veqw_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.eq($Vu32.w,$Vv32.w)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b100010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgathermh : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32),
"vtmp.h = vgather($Rt32,$Mu2,$Vv32.h).h",
tc_e8797b98, TypeCVI_GATHER>, Enc_8b8927, Requires<[UseHVXV65]> {
let Inst{12-5} = 0b00001000;
let Inst{31-21} = 0b00101111000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let isCVLoad = 1;
let hasTmpDst = 1;
let mayLoad = 1;
let Defs = [VTMP];
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgathermhq : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32),
"if ($Qs4) vtmp.h = vgather($Rt32,$Mu2,$Vv32.h).h",
tc_05ac6f98, TypeCVI_GATHER>, Enc_158beb, Requires<[UseHVXV65]> {
let Inst{12-7} = 0b001010;
let Inst{31-21} = 0b00101111000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let isCVLoad = 1;
let hasTmpDst = 1;
let mayLoad = 1;
let Defs = [VTMP];
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgathermhw : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32),
"vtmp.h = vgather($Rt32,$Mu2,$Vvv32.w).h",
tc_05058f6f, TypeCVI_GATHER>, Enc_28dcbb, Requires<[UseHVXV65]> {
let Inst{12-5} = 0b00010000;
let Inst{31-21} = 0b00101111000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let isCVLoad = 1;
let hasTmpDst = 1;
let mayLoad = 1;
let Defs = [VTMP];
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgathermhwq : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32),
"if ($Qs4) vtmp.h = vgather($Rt32,$Mu2,$Vvv32.w).h",
tc_fd7610da, TypeCVI_GATHER>, Enc_4e4a80, Requires<[UseHVXV65]> {
let Inst{12-7} = 0b001100;
let Inst{31-21} = 0b00101111000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = HalfWordAccess;
let isCVLoad = 1;
let hasTmpDst = 1;
let mayLoad = 1;
let Defs = [VTMP];
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgathermw : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32),
"vtmp.w = vgather($Rt32,$Mu2,$Vv32.w).w",
tc_e8797b98, TypeCVI_GATHER>, Enc_8b8927, Requires<[UseHVXV65]> {
let Inst{12-5} = 0b00000000;
let Inst{31-21} = 0b00101111000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = WordAccess;
let isCVLoad = 1;
let hasTmpDst = 1;
let mayLoad = 1;
let Defs = [VTMP];
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgathermwq : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32),
"if ($Qs4) vtmp.w = vgather($Rt32,$Mu2,$Vv32.w).w",
tc_05ac6f98, TypeCVI_GATHER>, Enc_158beb, Requires<[UseHVXV65]> {
let Inst{12-7} = 0b001000;
let Inst{31-21} = 0b00101111000;
let hasNewValue = 1;
let opNewValue = 0;
let accessSize = WordAccess;
let isCVLoad = 1;
let hasTmpDst = 1;
let mayLoad = 1;
let Defs = [VTMP];
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtb : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.gt($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtb_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.b,$Vv32.b)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.b,$Vv32.b)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b010100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtb_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.b,$Vv32.b)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b100100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.gt($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgth_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.h,$Vv32.h)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.h,$Vv32.h)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b010101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgth_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.h,$Vv32.h)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b100101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.gt($Vu32.ub,$Vv32.ub)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtub_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.ub,$Vv32.ub)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b001000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.ub,$Vv32.ub)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b011000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtub_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.ub,$Vv32.ub)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b101000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.gt($Vu32.uh,$Vv32.uh)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b001001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtuh_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.uh,$Vv32.uh)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b001001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.uh,$Vv32.uh)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b011001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuh_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.uh,$Vv32.uh)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b101001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.gt($Vu32.uw,$Vv32.uw)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b001010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtuw_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.uw,$Vv32.uw)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b001010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.uw,$Vv32.uw)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b011010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtuw_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.uw,$Vv32.uw)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b101010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw : HInst<
(outs HvxQR:$Qd4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Qd4 = vcmp.gt($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_95441f, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vgtw_and : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 &= vcmp.gt($Vu32.w,$Vv32.w)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b000110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw_or : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 |= vcmp.gt($Vu32.w,$Vv32.w)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b010110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vgtw_xor : HInst<
(outs HvxQR:$Qx4),
(ins HvxQR:$Qx4in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Qx4 ^= vcmp.gt($Vu32.w,$Vv32.w)",
tc_257f6f7c, TypeCVI_VA>, Enc_eaa9f8, Requires<[UseHVXV60]> {
let Inst{7-2} = 0b100110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100100;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vhist : HInst<
(outs),
(ins),
"vhist",
tc_1381a97c, TypeCVI_HIST>, Enc_e3b0c4, Requires<[UseHVXV60]> {
let Inst{13-0} = 0b10000010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vhistq : HInst<
(outs),
(ins HvxQR:$Qv4),
"vhist($Qv4)",
tc_e3f68a46, TypeCVI_HIST>, Enc_217147, Requires<[UseHVXV60]> {
let Inst{13-0} = 0b10000010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vinsertwr : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, IntRegs:$Rt32),
"$Vx32.w = vinsert($Rt32)",
tc_ac4046bc, TypeCVI_VX_LATE>, Enc_569cfe, Requires<[UseHVXV60]> {
let Inst{13-5} = 0b100000001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlalignb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32 = vlalign($Vu32,$Vv32,$Rt8)",
tc_56e64202, TypeCVI_VP>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlalignbi : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, u3_0Imm:$Ii),
"$Vd32 = vlalign($Vu32,$Vv32,#$Ii)",
tc_56e64202, TypeCVI_VP>, Enc_0b2e5b, Requires<[UseHVXV60]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.ub = vlsr($Vu32.ub,$Rt32)",
tc_7417e785, TypeCVI_VS>, Enc_b087ac, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.uh = vlsr($Vu32.uh,$Rt32)",
tc_7417e785, TypeCVI_VS>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vlsrh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrhv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vlsr($Vu32.h,$Vv32.h)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrhv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vlsrh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.uw = vlsr($Vu32.uw,$Rt32)",
tc_7417e785, TypeCVI_VS>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vlsrw($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrwv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vlsr($Vu32.w,$Vv32.w)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlsrwv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vlsrw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlut4 : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vd32.h = vlut4($Vu32.uh,$Rtt32.h)",
tc_f1de44ef, TypeCVI_VX_DV>, Enc_263841, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvvb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,$Rt8)",
tc_56e64202, TypeCVI_VP>, Enc_a30110, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvvb_nm : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,$Rt8):nomatch",
tc_56e64202, TypeCVI_VP>, Enc_a30110, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvvb_oracc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vx32.b |= vlut32($Vu32.b,$Vv32.b,$Rt8)",
tc_9d1dc972, TypeCVI_VP_VS>, Enc_245865, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlutvvb_oracci : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32, u3_0Imm:$Ii),
"$Vx32.b |= vlut32($Vu32.b,$Vv32.b,#$Ii)",
tc_9d1dc972, TypeCVI_VP_VS>, Enc_cd4705, Requires<[UseHVXV62]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100110;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vlutvvbi : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, u3_0Imm:$Ii),
"$Vd32.b = vlut32($Vu32.b,$Vv32.b,#$Ii)",
tc_56e64202, TypeCVI_VP>, Enc_0b2e5b, Requires<[UseHVXV62]> {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvwh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,$Rt8)",
tc_87adc037, TypeCVI_VP_VS>, Enc_24a7dc, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvwh_nm : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,$Rt8):nomatch",
tc_87adc037, TypeCVI_VP_VS>, Enc_24a7dc, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-24} = 0b00011000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vlutvwh_oracc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vxx32.h |= vlut16($Vu32.b,$Vv32.h,$Rt8)",
tc_9d1dc972, TypeCVI_VP_VS>, Enc_7b523d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vlutvwh_oracci : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32, u3_0Imm:$Ii),
"$Vxx32.h |= vlut16($Vu32.b,$Vv32.h,#$Ii)",
tc_9d1dc972, TypeCVI_VP_VS>, Enc_1178da, Requires<[UseHVXV62]> {
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vlutvwhi : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, u3_0Imm:$Ii),
"$Vdd32.h = vlut16($Vu32.b,$Vv32.h,#$Ii)",
tc_87adc037, TypeCVI_VP_VS>, Enc_4b39e4, Requires<[UseHVXV62]> {
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vmax($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmaxb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vmax($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmaxh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vmax($Vu32.ub,$Vv32.ub)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmaxub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vmax($Vu32.uh,$Vv32.uh)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmaxuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmax($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmaxw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmaxw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vmin($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vminb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vmin($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vminh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vmin($Vu32.ub,$Vv32.ub)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vminub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vmin($Vu32.uh,$Vv32.uh)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vminuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmin($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vminw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vminw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabus : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vmpa($Vuu32.ub,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabus_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vmpa($Vuu32.ub,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabus_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpabus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabus_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpabus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabusv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.h = vmpa($Vuu32.ub,$Vvv32.b)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabusv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vmpabus($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabuu : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vmpa($Vuu32.ub,$Rt32.ub)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabuu_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vmpa($Vuu32.ub,$Rt32.ub)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabuu_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpabuu($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpabuu_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpabuu($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabuuv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.h = vmpa($Vuu32.ub,$Vvv32.ub)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpabuuv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vmpabuu($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpahb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vmpa($Vuu32.h,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpahb_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vmpa($Vuu32.h,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpahb_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpahb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpahb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpahb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpahhsat : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vx32.h = vmpa($Vx32in.h,$Vu32.h,$Rtt32.h):sat",
tc_90bcc1db, TypeCVI_VX_DV>, Enc_310ba1, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpauhb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vmpa($Vuu32.uh,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpauhb_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vmpa($Vuu32.uh,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpauhb_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vmpauhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpauhb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vmpauhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpauhuhsat : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vx32.h = vmpa($Vx32in.h,$Vu32.uh,$Rtt32.uh):sat",
tc_90bcc1db, TypeCVI_VX_DV>, Enc_310ba1, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpsuhuhsat : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vx32.h = vmps($Vx32in.h,$Vu32.uh,$Rtt32.uh):sat",
tc_90bcc1db, TypeCVI_VX_DV>, Enc_310ba1, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpybus : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32.h = vmpy($Vu32.ub,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_01d3d0, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybus_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32.h += vmpy($Vu32.ub,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_5e8512, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybus_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybus_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybusv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.h = vmpy($Vu32.ub,$Vv32.b)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybusv_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.h += vmpy($Vu32.ub,$Vv32.b)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybusv_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybusv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.h = vmpy($Vu32.b,$Vv32.b)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpybv_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.h += vmpy($Vu32.b,$Vv32.b)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybv_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpybv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyewuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmpye($Vu32.w,$Vv32.uh)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyewuh_64 : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vmpye($Vu32.w,$Vv32.uh)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyewuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmpyewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32.w = vmpy($Vu32.h,$Rt32.h)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_01d3d0, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyh_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32.w += vmpy($Vu32.h,$Rt32.h)",
tc_660769f1, TypeCVI_VX_DV>, Enc_5e8512, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyh_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhsat_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32.w += vmpy($Vu32.h,$Rt32.h):sat",
tc_660769f1, TypeCVI_VX_DV>, Enc_5e8512, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhsat_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyh($Vu32,$Rt32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhsrs : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpy($Vu32.h,$Rt32.h):<<1:rnd:sat",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhsrs_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyh($Vu32,$Rt32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhss : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpy($Vu32.h,$Rt32.h):<<1:sat",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhss_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyh($Vu32,$Rt32):<<1:sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhus : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.w = vmpy($Vu32.h,$Vv32.uh)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhus_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.w += vmpy($Vu32.h,$Vv32.uh)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhus_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vmpyhus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhus_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vmpyhus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.w = vmpy($Vu32.h,$Vv32.h)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhv_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.w += vmpy($Vu32.h,$Vv32.h)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhv_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vmpyh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyhv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vmpyh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhvsrs : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vmpy($Vu32.h,$Vv32.h):<<1:rnd:sat",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyhvsrs_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmpyh($Vu32,$Vv32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyieoh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmpyieo($Vu32.h,$Vv32.h)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiewh_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.w += vmpyie($Vu32.w,$Vv32.h)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewh_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vmpyiewh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmpyie($Vu32.w,$Vv32.uh)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiewuh_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.w += vmpyie($Vu32.w,$Vv32.uh)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vmpyiewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiewuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmpyiewuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyih : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vmpyi($Vu32.h,$Vv32.h)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyih_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.h += vmpyi($Vu32.h,$Vv32.h)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyih_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vmpyih($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyih_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmpyih($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyihb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.h = vmpyi($Vu32.h,$Rt32.b)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyihb_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.h += vmpyi($Vu32.h,$Rt32.b)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyihb_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyihb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyihb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyihb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiowh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmpyio($Vu32.w,$Vv32.h)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiowh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmpyiowh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.b)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwb_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.b)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwb_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwb($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.h)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwh_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.h)",
tc_660769f1, TypeCVI_VX_DV>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwh_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vmpyi($Vu32.w,$Rt32.ub)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyiwub_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vmpyi($Vu32.w,$Rt32.ub)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwub_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vmpyiwub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyiwub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vmpyiwub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmpyo($Vu32.w,$Vv32.h):<<1:sat",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_64_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vmpyo($Vu32.w,$Vv32.h)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyowh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmpyowh($Vu32,$Vv32):<<1:sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_rnd : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vmpyo($Vu32.w,$Vv32.h):<<1:rnd:sat",
tc_d8287c14, TypeCVI_VX_DV>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_rnd_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmpyowh($Vu32,$Vv32):<<1:rnd:sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyowh_rnd_sacc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.w += vmpyo($Vu32.w,$Vv32.h):<<1:rnd:sat:shift",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_rnd_sacc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vmpyowh($Vu32,$Vv32):<<1:rnd:sat:shift",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_sacc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.w += vmpyo($Vu32.w,$Vv32.h):<<1:sat:shift",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyowh_sacc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vmpyowh($Vu32,$Vv32):<<1:sat:shift",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyub : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32.uh = vmpy($Vu32.ub,$Rt32.ub)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_01d3d0, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyub_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32.uh += vmpy($Vu32.ub,$Rt32.ub)",
tc_660769f1, TypeCVI_VX_DV>, Enc_5e8512, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyub_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyub_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyubv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.uh = vmpy($Vu32.ub,$Vv32.ub)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyubv_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.uh += vmpy($Vu32.ub,$Vv32.ub)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyubv_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyubv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32.uw = vmpy($Vu32.uh,$Rt32.uh)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_01d3d0, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuh_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32.uw += vmpy($Vu32.uh,$Rt32.uh)",
tc_660769f1, TypeCVI_VX_DV>, Enc_5e8512, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuh_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vxx32 += vmpyuh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vdd32 = vmpyuh($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuhe : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.uw = vmpye($Vu32.uh,$Rt32.uh)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuhe_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.uw += vmpye($Vu32.uh,$Rt32.uh)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001100;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vmpyuhv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.uw = vmpy($Vu32.uh,$Vv32.uh)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmpyuhv_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32.uw += vmpy($Vu32.uh,$Vv32.uh)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_3fc427, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuhv_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vxx32 += vmpyuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vmpyuhv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vmpyuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vmux : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qt4, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vmux($Qt4,$Vu32,$Vv32)",
tc_257f6f7c, TypeCVI_VA>, Enc_31db33, Requires<[UseHVXV60]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vnavg($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011111000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vnavgb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vnavg($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vnavgh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vnavg($Vu32.ub,$Vv32.ub)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vnavgub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vnavg($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnavgw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vnavgw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnccombine : HInst<
(outs HvxWR:$Vdd32),
(ins PredRegs:$Ps4, HvxVR:$Vu32, HvxVR:$Vv32),
"if (!$Ps4) $Vdd32 = vcombine($Vu32,$Vv32)",
tc_af25efd9, TypeCVI_VA_DV>, Enc_8c2412, Requires<[UseHVXV60]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011010010;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vncmov : HInst<
(outs HvxVR:$Vd32),
(ins PredRegs:$Ps4, HvxVR:$Vu32),
"if (!$Ps4) $Vd32 = $Vu32",
tc_3aacf4a8, TypeCVI_VA>, Enc_770858, Requires<[UseHVXV60]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001101000100000;
let isPredicated = 1;
let isPredicatedFalse = 1;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamth : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.h = vnormamt($Vu32.h)",
tc_51d0ecc3, TypeCVI_VS>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamth_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vnormamth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamtw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.w = vnormamt($Vu32.w)",
tc_51d0ecc3, TypeCVI_VS>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnormamtw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vnormamtw($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vnot : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vnot($Vu32)",
tc_0ec46cf9, TypeCVI_VA>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vor : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vor($Vu32,$Vv32)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vpacke($Vu32.h,$Vv32.h)",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vpacke($Vu32.w,$Vv32.w)",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackeh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhb_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vpack($Vu32.h,$Vv32.h):sat",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhb_sat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackhb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhub_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vpack($Vu32.h,$Vv32.h):sat",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackhub_sat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackob : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vpacko($Vu32.h,$Vv32.h)",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackob_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackob($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackoh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vpacko($Vu32.w,$Vv32.w)",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackoh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackoh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwh_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vpack($Vu32.w,$Vv32.w):sat",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwh_sat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackwh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwuh_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vpack($Vu32.w,$Vv32.w):sat",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpackwuh_sat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vpackwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpopcounth : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.h = vpopcount($Vu32.h)",
tc_51d0ecc3, TypeCVI_VS>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vpopcounth_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vpopcounth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vprefixqb : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qv4),
"$Vd32.b = prefixsum($Qv4)",
tc_51d0ecc3, TypeCVI_VS>, Enc_6f83e7, Requires<[UseHVXV65]> {
let Inst{13-5} = 0b100000010;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vprefixqh : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qv4),
"$Vd32.h = prefixsum($Qv4)",
tc_51d0ecc3, TypeCVI_VS>, Enc_6f83e7, Requires<[UseHVXV65]> {
let Inst{13-5} = 0b100001010;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vprefixqw : HInst<
(outs HvxVR:$Vd32),
(ins HvxQR:$Qv4),
"$Vd32.w = prefixsum($Qv4)",
tc_51d0ecc3, TypeCVI_VS>, Enc_6f83e7, Requires<[UseHVXV65]> {
let Inst{13-5} = 0b100010010;
let Inst{21-16} = 0b000011;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrdelta : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vrdelta($Vu32,$Vv32)",
tc_46d6c3e0, TypeCVI_VP>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybub_rtt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vdd32.w = vrmpy($Vu32.b,$Rtt32.ub)",
tc_cd94bfe0, TypeCVI_VS_VX>, Enc_cb785b, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybub_rtt_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vxx32.w += vrmpy($Vu32.b,$Rtt32.ub)",
tc_15fdf750, TypeCVI_VS_VX>, Enc_ad9bef, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybub_rtt_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vxx32.w += vrmpy($Vu32.b,$Rtt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybub_rtt_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vdd32.w = vrmpy($Vu32.b,$Rtt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybus : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.w = vrmpy($Vu32.ub,$Rt32.b)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybus_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.w += vrmpy($Vu32.ub,$Rt32.b)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybus_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vrmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybus_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vrmpybus($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusi : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.w = vrmpy($Vuu32.ub,$Rt32.b,#$Ii)",
tc_1ad8a370, TypeCVI_VX_DV>, Enc_2f2f04, Requires<[UseHVXV60]> {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusi_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.w += vrmpy($Vuu32.ub,$Rt32.b,#$Ii)",
tc_e675c45a, TypeCVI_VX_DV>, Enc_d483b9, Requires<[UseHVXV60]> {
let Inst{7-6} = 0b10;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybusi_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrmpybus($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpybusi_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrmpybus($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vrmpy($Vu32.ub,$Vv32.b)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybusv_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.w += vrmpy($Vu32.ub,$Vv32.b)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybusv_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vrmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybusv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vrmpybus($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vrmpy($Vu32.b,$Vv32.b)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpybv_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.w += vrmpy($Vu32.b,$Vv32.b)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybv_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vrmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpybv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vrmpyb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32.uw = vrmpy($Vu32.ub,$Rt32.ub)",
tc_649072c2, TypeCVI_VX>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyub_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32.uw += vrmpy($Vu32.ub,$Rt32.ub)",
tc_b091f1c6, TypeCVI_VX>, Enc_5138b3, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyub_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, IntRegs:$Rt32),
"$Vx32 += vrmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vrmpyub($Vu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyub_rtt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vdd32.uw = vrmpy($Vu32.ub,$Rtt32.ub)",
tc_cd94bfe0, TypeCVI_VS_VX>, Enc_cb785b, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyub_rtt_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vxx32.uw += vrmpy($Vu32.ub,$Rtt32.ub)",
tc_15fdf750, TypeCVI_VS_VX>, Enc_ad9bef, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyub_rtt_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vxx32.uw += vrmpy($Vu32.ub,$Rtt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyub_rtt_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, DoubleRegs:$Rtt32),
"$Vdd32.uw = vrmpy($Vu32.ub,$Rtt32.ub)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubi : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.uw = vrmpy($Vuu32.ub,$Rt32.ub,#$Ii)",
tc_1ad8a370, TypeCVI_VX_DV>, Enc_2f2f04, Requires<[UseHVXV60]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubi_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.uw += vrmpy($Vuu32.ub,$Rt32.ub,#$Ii)",
tc_e675c45a, TypeCVI_VX_DV>, Enc_d483b9, Requires<[UseHVXV60]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyubi_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrmpyub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrmpyubi_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrmpyub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubv : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uw = vrmpy($Vu32.ub,$Vv32.ub)",
tc_c127de3a, TypeCVI_VX>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyubv_acc : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32.uw += vrmpy($Vu32.ub,$Vv32.ub)",
tc_08a4f1b6, TypeCVI_VX_DV>, Enc_a7341a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyubv_acc_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxVR:$Vx32in, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vx32 += vrmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vrmpyubv_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vrmpyub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyzbb_rt : HInst<
(outs HvxVQR:$Vdddd32),
(ins HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vdddd32.w = vrmpyz($Vu32.b,$Rt8.b)",
tc_61bf7c03, TypeCVI_4SLOT_MPY>, Enc_1bd127, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyzbb_rt_acc : HInst<
(outs HvxVQR:$Vyyyy32),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vyyyy32.w += vrmpyz($Vu32.b,$Rt8.b)",
tc_933f2b39, TypeCVI_4SLOT_MPY>, Enc_d7bc34, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in";
}
def V6_vrmpyzbb_rx : HInst<
(outs HvxVQR:$Vdddd32, IntRegsLow8:$Rx8),
(ins HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vdddd32.w = vrmpyz($Vu32.b,$Rx8.b++)",
tc_26a377fe, TypeCVI_4SLOT_MPY>, Enc_3b7631, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx8 = $Rx8in";
}
def V6_vrmpyzbb_rx_acc : HInst<
(outs HvxVQR:$Vyyyy32, IntRegsLow8:$Rx8),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vyyyy32.w += vrmpyz($Vu32.b,$Rx8.b++)",
tc_2d4051cd, TypeCVI_4SLOT_MPY>, Enc_bddee3, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in, $Rx8 = $Rx8in";
}
def V6_vrmpyzbub_rt : HInst<
(outs HvxVQR:$Vdddd32),
(ins HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vdddd32.w = vrmpyz($Vu32.b,$Rt8.ub)",
tc_61bf7c03, TypeCVI_4SLOT_MPY>, Enc_1bd127, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyzbub_rt_acc : HInst<
(outs HvxVQR:$Vyyyy32),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vyyyy32.w += vrmpyz($Vu32.b,$Rt8.ub)",
tc_933f2b39, TypeCVI_4SLOT_MPY>, Enc_d7bc34, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in";
}
def V6_vrmpyzbub_rx : HInst<
(outs HvxVQR:$Vdddd32, IntRegsLow8:$Rx8),
(ins HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vdddd32.w = vrmpyz($Vu32.b,$Rx8.ub++)",
tc_26a377fe, TypeCVI_4SLOT_MPY>, Enc_3b7631, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx8 = $Rx8in";
}
def V6_vrmpyzbub_rx_acc : HInst<
(outs HvxVQR:$Vyyyy32, IntRegsLow8:$Rx8),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vyyyy32.w += vrmpyz($Vu32.b,$Rx8.ub++)",
tc_2d4051cd, TypeCVI_4SLOT_MPY>, Enc_bddee3, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in, $Rx8 = $Rx8in";
}
def V6_vrmpyzcb_rt : HInst<
(outs HvxVQR:$Vdddd32),
(ins HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vdddd32.w = vr16mpyz($Vu32.c,$Rt8.b)",
tc_61bf7c03, TypeCVI_4SLOT_MPY>, Enc_1bd127, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyzcb_rt_acc : HInst<
(outs HvxVQR:$Vyyyy32),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vyyyy32.w += vr16mpyz($Vu32.c,$Rt8.b)",
tc_933f2b39, TypeCVI_4SLOT_MPY>, Enc_d7bc34, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in";
}
def V6_vrmpyzcb_rx : HInst<
(outs HvxVQR:$Vdddd32, IntRegsLow8:$Rx8),
(ins HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vdddd32.w = vr16mpyz($Vu32.c,$Rx8.b++)",
tc_26a377fe, TypeCVI_4SLOT_MPY>, Enc_3b7631, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx8 = $Rx8in";
}
def V6_vrmpyzcb_rx_acc : HInst<
(outs HvxVQR:$Vyyyy32, IntRegsLow8:$Rx8),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vyyyy32.w += vr16mpyz($Vu32.c,$Rx8.b++)",
tc_2d4051cd, TypeCVI_4SLOT_MPY>, Enc_bddee3, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in, $Rx8 = $Rx8in";
}
def V6_vrmpyzcbs_rt : HInst<
(outs HvxVQR:$Vdddd32),
(ins HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vdddd32.w = vr16mpyzs($Vu32.c,$Rt8.b)",
tc_61bf7c03, TypeCVI_4SLOT_MPY>, Enc_1bd127, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyzcbs_rt_acc : HInst<
(outs HvxVQR:$Vyyyy32),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vyyyy32.w += vr16mpyzs($Vu32.c,$Rt8.b)",
tc_933f2b39, TypeCVI_4SLOT_MPY>, Enc_d7bc34, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in";
}
def V6_vrmpyzcbs_rx : HInst<
(outs HvxVQR:$Vdddd32, IntRegsLow8:$Rx8),
(ins HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vdddd32.w = vr16mpyzs($Vu32.c,$Rx8.b++)",
tc_26a377fe, TypeCVI_4SLOT_MPY>, Enc_3b7631, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx8 = $Rx8in";
}
def V6_vrmpyzcbs_rx_acc : HInst<
(outs HvxVQR:$Vyyyy32, IntRegsLow8:$Rx8),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vyyyy32.w += vr16mpyzs($Vu32.c,$Rx8.b++)",
tc_2d4051cd, TypeCVI_4SLOT_MPY>, Enc_bddee3, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111001;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in, $Rx8 = $Rx8in";
}
def V6_vrmpyznb_rt : HInst<
(outs HvxVQR:$Vdddd32),
(ins HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vdddd32.w = vr8mpyz($Vu32.n,$Rt8.b)",
tc_61bf7c03, TypeCVI_4SLOT_MPY>, Enc_1bd127, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrmpyznb_rt_acc : HInst<
(outs HvxVQR:$Vyyyy32),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegsLow8:$Rt8),
"$Vyyyy32.w += vr8mpyz($Vu32.n,$Rt8.b)",
tc_933f2b39, TypeCVI_4SLOT_MPY>, Enc_d7bc34, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in";
}
def V6_vrmpyznb_rx : HInst<
(outs HvxVQR:$Vdddd32, IntRegsLow8:$Rx8),
(ins HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vdddd32.w = vr8mpyz($Vu32.n,$Rx8.b++)",
tc_26a377fe, TypeCVI_4SLOT_MPY>, Enc_3b7631, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-19} = 0b0001100111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx8 = $Rx8in";
}
def V6_vrmpyznb_rx_acc : HInst<
(outs HvxVQR:$Vyyyy32, IntRegsLow8:$Rx8),
(ins HvxVQR:$Vyyyy32in, HvxVR:$Vu32, IntRegs:$Rx8in),
"$Vyyyy32.w += vr8mpyz($Vu32.n,$Rx8.b++)",
tc_2d4051cd, TypeCVI_4SLOT_MPY>, Enc_bddee3, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-19} = 0b0001100111011;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vyyyy32 = $Vyyyy32in, $Rx8 = $Rx8in";
}
def V6_vror : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, IntRegs:$Rt32),
"$Vd32 = vror($Vu32,$Rt32)",
tc_6e7fa133, TypeCVI_VP>, Enc_b087ac, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrotr : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uw = vrotr($Vu32.uw,$Vv32.uw)",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV66]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011010100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrotr_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vrotr($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV66]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vround($Vu32.h,$Vv32.h):sat",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vroundhb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vround($Vu32.h,$Vv32.h):sat",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundhub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vroundhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduhub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vround($Vu32.uh,$Vv32.uh):sat",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduhub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vrounduhub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduwuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vround($Vu32.uw,$Vv32.uw):sat",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111111;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrounduwuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vrounduwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vround($Vu32.w,$Vv32.w):sat",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vroundwh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vround($Vu32.w,$Vv32.w):sat",
tc_05ca8cfd, TypeCVI_VS>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vroundwuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vroundwuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrsadubi : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32.uw = vrsad($Vuu32.ub,$Rt32.ub,#$Ii)",
tc_1ad8a370, TypeCVI_VX_DV>, Enc_2f2f04, Requires<[UseHVXV60]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vrsadubi_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32.uw += vrsad($Vuu32.ub,$Rt32.ub,#$Ii)",
tc_e675c45a, TypeCVI_VX_DV>, Enc_d483b9, Requires<[UseHVXV60]> {
let Inst{7-6} = 0b11;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001010;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrsadubi_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vxx32 += vrsadub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vrsadubi_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32, u1_0Imm:$Ii),
"$Vdd32 = vrsadub($Vuu32,$Rt32,#$Ii)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatdw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vsatdw($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV66]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011101100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsathub : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vsat($Vu32.h,$Vv32.h)",
tc_8772086c, TypeCVI_VINLANESAT>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsathub_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsathub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatuwuh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vsat($Vu32.uw,$Vv32.uw)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatuwuh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsatuwuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatwh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vsat($Vu32.w,$Vv32.w)",
tc_8772086c, TypeCVI_VINLANESAT>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsatwh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsatwh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.h = vsxt($Vu32.b)",
tc_b4416217, TypeCVI_VA_DV>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vsxtb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermh : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.h).h = $Vw32",
tc_9f363d21, TypeCVI_SCATTER>, Enc_16c48b, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b001;
let Inst{31-21} = 0b00101111001;
let accessSize = HalfWordAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermh_add : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.h).h += $Vw32",
tc_9f363d21, TypeCVI_SCATTER>, Enc_16c48b, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b101;
let Inst{31-21} = 0b00101111001;
let accessSize = HalfWordAccess;
let isAccumulator = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermh_add_alt : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.h) += $Vw32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermh_alt : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.h) = $Vw32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermhq : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"if ($Qs4) vscatter($Rt32,$Mu2,$Vv32.h).h = $Vw32",
tc_8e420e4d, TypeCVI_SCATTER>, Enc_9be1de, Requires<[UseHVXV65]> {
let Inst{7-7} = 0b1;
let Inst{31-21} = 0b00101111100;
let accessSize = HalfWordAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermhq_alt : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"if ($Qs4) vscatter($Rt32,$Mu2,$Vv32.h) = $Vw32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermhw : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vvv32.w).h = $Vw32",
tc_7273323b, TypeCVI_SCATTER_DV>, Enc_a641d0, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b010;
let Inst{31-21} = 0b00101111001;
let accessSize = HalfWordAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermhw_add : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vvv32.w).h += $Vw32",
tc_7273323b, TypeCVI_SCATTER_DV>, Enc_a641d0, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b110;
let Inst{31-21} = 0b00101111001;
let accessSize = HalfWordAccess;
let isAccumulator = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermhwq : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32, HvxVR:$Vw32),
"if ($Qs4) vscatter($Rt32,$Mu2,$Vvv32.w).h = $Vw32",
tc_58d21193, TypeCVI_SCATTER_DV>, Enc_3d6d37, Requires<[UseHVXV65]> {
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b00101111101;
let accessSize = HalfWordAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermw : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.w).w = $Vw32",
tc_9f363d21, TypeCVI_SCATTER>, Enc_16c48b, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b000;
let Inst{31-21} = 0b00101111001;
let accessSize = WordAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermw_add : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.w).w += $Vw32",
tc_9f363d21, TypeCVI_SCATTER>, Enc_16c48b, Requires<[UseHVXV65]> {
let Inst{7-5} = 0b100;
let Inst{31-21} = 0b00101111001;
let accessSize = WordAccess;
let isAccumulator = 1;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermw_add_alt : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.w) += $Vw32.w",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermw_alt : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vv32.w) = $Vw32.w",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermwh_add_alt : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vvv32.w) += $Vw32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermwh_alt : HInst<
(outs),
(ins IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32, HvxVR:$Vw32),
"vscatter($Rt32,$Mu2,$Vvv32.w) = $Vw32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermwhq_alt : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxWR:$Vvv32, HvxVR:$Vw32),
"if ($Qs4) vscatter($Rt32,$Mu2,$Vvv32.w) = $Vw32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermwq : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"if ($Qs4) vscatter($Rt32,$Mu2,$Vv32.w).w = $Vw32",
tc_8e420e4d, TypeCVI_SCATTER>, Enc_9be1de, Requires<[UseHVXV65]> {
let Inst{7-7} = 0b0;
let Inst{31-21} = 0b00101111100;
let accessSize = WordAccess;
let mayStore = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vscattermwq_alt : HInst<
(outs),
(ins HvxQR:$Qs4, IntRegs:$Rt32, ModRegs:$Mu2, HvxVR:$Vv32, HvxVR:$Vw32),
"if ($Qs4) vscatter($Rt32,$Mu2,$Vv32.w) = $Vw32.w",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV65]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.w = vsxt($Vu32.h)",
tc_b4416217, TypeCVI_VA_DV>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vsxth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufeh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vshuffe($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufeh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vshuffeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuff : HInst<
(outs HvxVR:$Vy32, HvxVR:$Vx32),
(ins HvxVR:$Vy32in, HvxVR:$Vx32in, IntRegs:$Rt32),
"vshuff($Vy32,$Vx32,$Rt32)",
tc_561aaa58, TypeCVI_VP_VS>, Enc_989021, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001111;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vshuffb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.b = vshuff($Vu32.b)",
tc_946013d8, TypeCVI_VP>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vshuffb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffeb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vshuffe($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffeb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vshuffeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32.h = vshuff($Vu32.h)",
tc_946013d8, TypeCVI_VP>, Enc_e7581c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32),
"$Vd32 = vshuffh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffob : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vshuffo($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffob_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vshuffob($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshuffvdd : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32, IntRegsLow8:$Rt8),
"$Vdd32 = vshuff($Vu32,$Vv32,$Rt8)",
tc_87adc037, TypeCVI_VP_VS>, Enc_24a7dc, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{31-24} = 0b00011011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.b = vshuffoe($Vu32.b,$Vv32.b)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vshuffoeb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.h = vshuffoe($Vu32.h,$Vv32.h)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoeh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vshuffoeh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vshuffo($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vshufoh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vshuffoh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vsub($Vu32.b,$Vv32.b)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubb($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.b = vsub($Vuu32.b,$Vvv32.b)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubb_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubb($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbnq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4) $Vx32.b -= $Vu32.b",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbnq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4.b) $Vx32.b -= $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4) $Vx32.b -= $Vu32.b",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4.b) $Vx32.b -= $Vu32.b",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubbsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.b = vsub($Vu32.b,$Vv32.b):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubb($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.b = vsub($Vuu32.b,$Vvv32.b):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubbsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubb($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubcarry : HInst<
(outs HvxVR:$Vd32, HvxQR:$Qx4),
(ins HvxVR:$Vu32, HvxVR:$Vv32, HvxQR:$Qx4in),
"$Vd32.w = vsub($Vu32.w,$Vv32.w,$Qx4):carry",
tc_7e6a3e89, TypeCVI_VA>, Enc_b43b67, Requires<[UseHVXV62]> {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Qx4 = $Qx4in";
}
def V6_vsubcarryo : HInst<
(outs HvxVR:$Vd32, HvxQR:$Qe4),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w,$Qe4 = vsub($Vu32.w,$Vv32.w):carry",
tc_e35c1e93, TypeCOPROC_VX>, Enc_c1d806, Requires<[UseHVXV66]> {
let Inst{7-7} = 0b1;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011101101;
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vsub($Vu32.h,$Vv32.h)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.h = vsub($Vuu32.h,$Vvv32.h)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubh_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubh($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhnq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4) $Vx32.h -= $Vu32.h",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhnq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4.h) $Vx32.h -= $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4) $Vx32.h -= $Vu32.h",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000001;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4.h) $Vx32.h -= $Vu32.h",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.h = vsub($Vu32.h,$Vv32.h):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.h = vsub($Vuu32.h,$Vvv32.h):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhw : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.w = vsub($Vu32.h,$Vv32.h)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubhw_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vsubh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.h = vsub($Vu32.ub,$Vv32.ub)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vsubub($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vsub($Vu32.ub,$Vv32.ub):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubub($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.ub = vsub($Vuu32.ub,$Vvv32.ub):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsububsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubub($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubububb_sat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.ub = vsub($Vu32.ub,$Vv32.b):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uh = vsub($Vu32.uh,$Vv32.uh):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubuh($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.uh = vsub($Vuu32.uh,$Vvv32.uh):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubuh($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhw : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32.w = vsub($Vu32.uh,$Vv32.uh)",
tc_d8287c14, TypeCVI_VX_DV>, Enc_71bb9b, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b110;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuhw_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vsubuh($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.uw = vsub($Vu32.uw,$Vv32.uw):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011111110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubuw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.uw = vsub($Vuu32.uw,$Vvv32.uw):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV62]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubuwsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubuw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV62]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vsub($Vu32.w,$Vv32.w)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubw($Vu32,$Vv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.w = vsub($Vuu32.w,$Vvv32.w)",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b101;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100100;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubw_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubw($Vuu32,$Vvv32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwnq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4) $Vx32.w -= $Vu32.w",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwnq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if (!$Qv4.w) $Vx32.w -= $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwq : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4) $Vx32.w -= $Vu32.w",
tc_257f6f7c, TypeCVI_VA>, Enc_a90628, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwq_alt : HInst<
(outs HvxVR:$Vx32),
(ins HvxQR:$Qv4, HvxVR:$Vx32in, HvxVR:$Vu32),
"if ($Qv4.w) $Vx32.w -= $Vu32.w",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vx32 = $Vx32in";
}
def V6_vsubwsat : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32.w = vsub($Vu32.w,$Vv32.w):sat",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100011;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwsat_alt : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vsubw($Vu32,$Vv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwsat_dv : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32.w = vsub($Vuu32.w,$Vvv32.w):sat",
tc_db5555f3, TypeCVI_VA_DV>, Enc_f8ecf9, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vsubwsat_dv_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, HvxWR:$Vvv32),
"$Vdd32 = vsubw($Vuu32,$Vvv32):sat",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vswap : HInst<
(outs HvxWR:$Vdd32),
(ins HvxQR:$Qt4, HvxVR:$Vu32, HvxVR:$Vv32),
"$Vdd32 = vswap($Qt4,$Vu32,$Vv32)",
tc_71646d06, TypeCVI_VA_DV>, Enc_3dac0b, Requires<[UseHVXV60]> {
let Inst{7-7} = 0b0;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011110101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vtmpy($Vuu32.b,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyb_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vtmpy($Vuu32.b,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyb_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpyb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpyb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpybus : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.h = vtmpy($Vuu32.ub,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpybus_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.h += vtmpy($Vuu32.ub,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpybus_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpybus_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpybus($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyhb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32.w = vtmpy($Vuu32.h,$Rt32.b)",
tc_0b04c6c7, TypeCVI_VX_DV>, Enc_aad80c, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtmpyhb_acc : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32.w += vtmpy($Vuu32.h,$Rt32.b)",
tc_660769f1, TypeCVI_VX_DV>, Enc_d6990d, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b1;
let Inst{31-21} = 0b00011001000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyhb_acc_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vxx32 += vtmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vtmpyhb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxWR:$Vuu32, IntRegs:$Rt32),
"$Vdd32 = vtmpyhb($Vuu32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vtran2x2_map : HInst<
(outs HvxVR:$Vy32, HvxVR:$Vx32),
(ins HvxVR:$Vy32in, HvxVR:$Vx32in, IntRegs:$Rt32),
"vtrans2x2($Vy32,$Vx32,$Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let hasNewValue2 = 1;
let opNewValue2 = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vy32 = $Vy32in, $Vx32 = $Vx32in";
}
def V6_vunpackb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.h = vunpack($Vu32.b)",
tc_04da405a, TypeCVI_VP_VS>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vunpackb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.w = vunpack($Vu32.h)",
tc_04da405a, TypeCVI_VP_VS>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b011;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vunpackh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackob : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32),
"$Vxx32.h |= vunpacko($Vu32.b)",
tc_2c745bb8, TypeCVI_VP_VS>, Enc_500cb0, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackob_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32),
"$Vxx32 |= vunpackob($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackoh : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32),
"$Vxx32.w |= vunpacko($Vu32.h)",
tc_2c745bb8, TypeCVI_VP_VS>, Enc_500cb0, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b1;
let Inst{31-16} = 0b0001111000000000;
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackoh_alt : HInst<
(outs HvxWR:$Vxx32),
(ins HvxWR:$Vxx32in, HvxVR:$Vu32),
"$Vxx32 |= vunpackoh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isAccumulator = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Vxx32 = $Vxx32in";
}
def V6_vunpackub : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.uh = vunpack($Vu32.ub)",
tc_04da405a, TypeCVI_VP_VS>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackub_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vunpackub($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackuh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.uw = vunpack($Vu32.uh)",
tc_04da405a, TypeCVI_VP_VS>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vunpackuh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vunpackuh($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128 : HInst<
(outs),
(ins),
"vwhist128",
tc_1381a97c, TypeCVI_HIST>, Enc_e3b0c4, Requires<[UseHVXV62]> {
let Inst{13-0} = 0b10010010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128m : HInst<
(outs),
(ins u1_0Imm:$Ii),
"vwhist128(#$Ii)",
tc_b28e51aa, TypeCVI_HIST>, Enc_efaed8, Requires<[UseHVXV62]> {
let Inst{7-0} = 0b10000000;
let Inst{13-9} = 0b10011;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128q : HInst<
(outs),
(ins HvxQR:$Qv4),
"vwhist128($Qv4)",
tc_e3f68a46, TypeCVI_HIST>, Enc_217147, Requires<[UseHVXV62]> {
let Inst{13-0} = 0b10010010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist128qm : HInst<
(outs),
(ins HvxQR:$Qv4, u1_0Imm:$Ii),
"vwhist128($Qv4,#$Ii)",
tc_767c4e9d, TypeCVI_HIST>, Enc_802dc0, Requires<[UseHVXV62]> {
let Inst{7-0} = 0b10000000;
let Inst{13-9} = 0b10011;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256 : HInst<
(outs),
(ins),
"vwhist256",
tc_1381a97c, TypeCVI_HIST>, Enc_e3b0c4, Requires<[UseHVXV62]> {
let Inst{13-0} = 0b10001010000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256_sat : HInst<
(outs),
(ins),
"vwhist256:sat",
tc_1381a97c, TypeCVI_HIST>, Enc_e3b0c4, Requires<[UseHVXV62]> {
let Inst{13-0} = 0b10001110000000;
let Inst{31-16} = 0b0001111000000000;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256q : HInst<
(outs),
(ins HvxQR:$Qv4),
"vwhist256($Qv4)",
tc_e3f68a46, TypeCVI_HIST>, Enc_217147, Requires<[UseHVXV62]> {
let Inst{13-0} = 0b10001010000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vwhist256q_sat : HInst<
(outs),
(ins HvxQR:$Qv4),
"vwhist256($Qv4):sat",
tc_e3f68a46, TypeCVI_HIST>, Enc_217147, Requires<[UseHVXV62]> {
let Inst{13-0} = 0b10001110000000;
let Inst{21-16} = 0b000010;
let Inst{31-24} = 0b00011110;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vxor : HInst<
(outs HvxVR:$Vd32),
(ins HvxVR:$Vu32, HvxVR:$Vv32),
"$Vd32 = vxor($Vu32,$Vv32)",
tc_56c4f9fe, TypeCVI_VA>, Enc_45364e, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b111;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00011100001;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzb : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.uh = vzxt($Vu32.ub)",
tc_b4416217, TypeCVI_VA_DV>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b001;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzb_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vzxtb($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzh : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32.uw = vzxt($Vu32.uh)",
tc_b4416217, TypeCVI_VA_DV>, Enc_dd766a, Requires<[UseHVXV60]> {
let Inst{7-5} = 0b010;
let Inst{13-13} = 0b0;
let Inst{31-16} = 0b0001111000000010;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_vzh_alt : HInst<
(outs HvxWR:$Vdd32),
(ins HvxVR:$Vu32),
"$Vdd32 = vzxth($Vu32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV60]> {
let hasNewValue = 1;
let opNewValue = 0;
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_zLd_ai : HInst<
(outs),
(ins IntRegs:$Rt32, s4_0Imm:$Ii),
"z = vmem($Rt32+#$Ii)",
tc_e699ae41, TypeCVI_ZW>, Enc_ff3442, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-0} = 0b00000000;
let Inst{12-11} = 0b00;
let Inst{31-21} = 0b00101100000;
let addrMode = BaseImmOffset;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_zLd_pi : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, s3_0Imm:$Ii),
"z = vmem($Rx32++#$Ii)",
tc_a0dbea28, TypeCVI_ZW>, Enc_6c9ee0, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-0} = 0b00000000;
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b00101101000;
let addrMode = PostInc;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_zLd_ppu : HInst<
(outs IntRegs:$Rx32),
(ins IntRegs:$Rx32in, ModRegs:$Mu2),
"z = vmem($Rx32++$Mu2)",
tc_a0dbea28, TypeCVI_ZW>, Enc_44661f, Requires<[UseHVXV66,UseZReg]> {
let Inst{12-0} = 0b0000000000001;
let Inst{31-21} = 0b00101101000;
let addrMode = PostInc;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_zLd_pred_ai : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32, s4_0Imm:$Ii),
"if ($Pv4) z = vmem($Rt32+#$Ii)",
tc_dd5b0695, TypeCVI_ZW>, Enc_ef601b, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-0} = 0b00000000;
let Inst{31-21} = 0b00101100100;
let isPredicated = 1;
let addrMode = BaseImmOffset;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_zLd_pred_pi : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, s3_0Imm:$Ii),
"if ($Pv4) z = vmem($Rx32++#$Ii)",
tc_3ad719fb, TypeCVI_ZW>, Enc_6baed4, Requires<[UseHVXV66,UseZReg]> {
let Inst{7-0} = 0b00000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b00101101100;
let isPredicated = 1;
let addrMode = PostInc;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_zLd_pred_ppu : HInst<
(outs IntRegs:$Rx32),
(ins PredRegs:$Pv4, IntRegs:$Rx32in, ModRegs:$Mu2),
"if ($Pv4) z = vmem($Rx32++$Mu2)",
tc_3ad719fb, TypeCVI_ZW>, Enc_691712, Requires<[UseHVXV66,UseZReg]> {
let Inst{10-0} = 0b00000000001;
let Inst{31-21} = 0b00101101100;
let isPredicated = 1;
let addrMode = PostInc;
let mayLoad = 1;
let isRestrictNoSlot1Store = 1;
let DecoderNamespace = "EXT_mmvec";
let Constraints = "$Rx32 = $Rx32in";
}
def V6_zextract : HInst<
(outs HvxVR:$Vd32),
(ins IntRegs:$Rt32),
"$Vd32 = zextract($Rt32)",
tc_5bf8afbb, TypeCVI_VP>, Enc_a5ed8a, Requires<[UseHVXV66,UseZReg]> {
let Inst{13-5} = 0b000001001;
let Inst{31-21} = 0b00011001101;
let hasNewValue = 1;
let opNewValue = 0;
let DecoderNamespace = "EXT_mmvec";
}
def V6_zld0 : HInst<
(outs),
(ins IntRegs:$Rt32),
"z = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV66]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def V6_zldp0 : HInst<
(outs),
(ins PredRegs:$Pv4, IntRegs:$Rt32),
"if ($Pv4) z = vmem($Rt32)",
PSEUDO, TypeMAPPING>, Requires<[UseHVXV66]> {
let isPseudo = 1;
let isCodeGenOnly = 1;
let DecoderNamespace = "EXT_mmvec";
}
def Y2_barrier : HInst<
(outs),
(ins),
"barrier",
tc_8c99de45, TypeST>, Enc_e3b0c4 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b1010100000000000;
let isSoloAX = 1;
let hasSideEffects = 1;
}
def Y2_break : HInst<
(outs),
(ins),
"brkpt",
tc_9ad9998f, TypeCR>, Enc_e3b0c4 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b0110110000100000;
let isSolo = 1;
}
def Y2_dccleana : HInst<
(outs),
(ins IntRegs:$Rs32),
"dccleana($Rs32)",
tc_b857bf4e, TypeST>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000000;
let isRestrictSlot1AOK = 1;
let hasSideEffects = 1;
}
def Y2_dccleaninva : HInst<
(outs),
(ins IntRegs:$Rs32),
"dccleaninva($Rs32)",
tc_b857bf4e, TypeST>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000010;
let isRestrictSlot1AOK = 1;
let hasSideEffects = 1;
}
def Y2_dcfetch : HInst<
(outs),
(ins IntRegs:$Rs32),
"dcfetch($Rs32)",
tc_d63f638c, TypeMAPPING> {
let hasSideEffects = 1;
let isPseudo = 1;
let isCodeGenOnly = 1;
}
def Y2_dcfetchbo : HInst<
(outs),
(ins IntRegs:$Rs32, u11_3Imm:$Ii),
"dcfetch($Rs32+#$Ii)",
tc_9ca930f7, TypeLD>, Enc_2d829e {
let Inst{13-11} = 0b000;
let Inst{31-21} = 0b10010100000;
let addrMode = BaseImmOffset;
let isRestrictNoSlot1Store = 1;
let hasSideEffects = 1;
}
def Y2_dcinva : HInst<
(outs),
(ins IntRegs:$Rs32),
"dcinva($Rs32)",
tc_b857bf4e, TypeST>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000001;
let isRestrictSlot1AOK = 1;
let hasSideEffects = 1;
}
def Y2_dczeroa : HInst<
(outs),
(ins IntRegs:$Rs32),
"dczeroa($Rs32)",
tc_b857bf4e, TypeST>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b10100000110;
let isRestrictSlot1AOK = 1;
let mayStore = 1;
let hasSideEffects = 1;
}
def Y2_icinva : HInst<
(outs),
(ins IntRegs:$Rs32),
"icinva($Rs32)",
tc_5d7f5414, TypeJ>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01010110110;
let isSolo = 1;
}
def Y2_isync : HInst<
(outs),
(ins),
"isync",
tc_8b121f4a, TypeJ>, Enc_e3b0c4 {
let Inst{13-0} = 0b00000000000010;
let Inst{31-16} = 0b0101011111000000;
let isSolo = 1;
}
def Y2_syncht : HInst<
(outs),
(ins),
"syncht",
tc_8c99de45, TypeST>, Enc_e3b0c4 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-16} = 0b1010100001000000;
let isSolo = 1;
}
def Y2_wait : HInst<
(outs),
(ins IntRegs:$Rs32),
"wait($Rs32)",
tc_174516e8, TypeCR>, Enc_ecbcc8, Requires<[HasV65]> {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01100100010;
let isSolo = 1;
}
def Y4_l2fetch : HInst<
(outs),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"l2fetch($Rs32,$Rt32)",
tc_fe211424, TypeST>, Enc_ca3887 {
let Inst{7-0} = 0b00000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100110000;
let isSoloAX = 1;
let mayStore = 1;
let hasSideEffects = 1;
}
def Y4_trace : HInst<
(outs),
(ins IntRegs:$Rs32),
"trace($Rs32)",
tc_6b25e783, TypeCR>, Enc_ecbcc8 {
let Inst{13-0} = 0b00000000000000;
let Inst{31-21} = 0b01100010010;
let isSoloAX = 1;
}
def Y5_l2fetch : HInst<
(outs),
(ins IntRegs:$Rs32, DoubleRegs:$Rtt32),
"l2fetch($Rs32,$Rtt32)",
tc_fe211424, TypeST>, Enc_e6abcf {
let Inst{7-0} = 0b00000000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b10100110100;
let isSoloAX = 1;
let mayStore = 1;
let hasSideEffects = 1;
}
def dep_A2_addsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rd32 = add($Rs32,$Rt32):sat:deprecated",
tc_779080bf, TypeALU64>, Enc_5ab2be {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def dep_A2_subsat : HInst<
(outs IntRegs:$Rd32),
(ins IntRegs:$Rt32, IntRegs:$Rs32),
"$Rd32 = sub($Rt32,$Rs32):sat:deprecated",
tc_779080bf, TypeALU64>, Enc_bd6011 {
let Inst{7-5} = 0b100;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010101100;
let hasNewValue = 1;
let opNewValue = 0;
let prefersSlot3 = 1;
let Defs = [USR_OVF];
}
def dep_S2_packhl : HInst<
(outs DoubleRegs:$Rdd32),
(ins IntRegs:$Rs32, IntRegs:$Rt32),
"$Rdd32 = packhl($Rs32,$Rt32):deprecated",
tc_946df596, TypeALU64>, Enc_be32a5 {
let Inst{7-5} = 0b000;
let Inst{13-13} = 0b0;
let Inst{31-21} = 0b11010100000;
}
