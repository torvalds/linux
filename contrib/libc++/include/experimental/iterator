// -*- C++ -*-
//===----------------------------- iterator -------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_ITERATOR
#define _LIBCPP_EXPERIMENTAL_ITERATOR

/*
namespace std {
  namespace experimental {
    inline namespace fundamentals_v2 {

    template <class DelimT, class charT = char, class traits = char_traits<charT>>
        class ostream_joiner {
        public:
         typedef charT                        char_type;
         typedef traits                       traits_type;
         typedef basic_ostream<charT, traits> ostream_type;
         typedef output_iterator_tag          iterator_category;
         typedef void                         value_type;
         typedef void                         difference_type;
         typedef void                         pointer;
         typedef void                         reference;
      
         ostream_joiner(ostream_type& s, const DelimT& delimiter);
         ostream_joiner(ostream_type& s, DelimT&& delimiter);

         template<typename T>  
         ostream_joiner& operator=(const T& value);

         ostream_joiner& operator*() noexcept;
         ostream_joiner& operator++() noexcept;
         ostream_joiner& operator++(int) noexcept;
   private:
      ostream_type* out_stream;   // exposition only 
      DelimT delim;               // exposition only 
      bool first_element;         // exposition only
   };

  template <class charT, class traits, class DelimT>
    ostream_joiner<decay_t<DelimT>, charT, traits>
    make_ostream_joiner(basic_ostream<charT, traits>& os, DelimT&& delimiter);

    } // inline namespace fundamentals_v2
  } // namespace experimental
} // namespace std

*/

#include <experimental/__config>

#if _LIBCPP_STD_VER > 11

#include <iterator>

_LIBCPP_BEGIN_NAMESPACE_LFTS

template <class _Delim, class _CharT = char, class _Traits = char_traits<_CharT>>
class ostream_joiner {
public:

    typedef _CharT                               char_type;
    typedef _Traits                              traits_type;
    typedef basic_ostream<char_type,traits_type> ostream_type;
    typedef output_iterator_tag                  iterator_category;
    typedef void                                 value_type;
    typedef void                                 difference_type;
    typedef void                                 pointer;
    typedef void                                 reference;

    ostream_joiner(ostream_type& __os, _Delim&& __d)
        : __output_iter(_VSTD::addressof(__os)), __delim(_VSTD::move(__d)), __first(true) {}
        
    ostream_joiner(ostream_type& __os, const _Delim& __d)
        : __output_iter(_VSTD::addressof(__os)), __delim(__d), __first(true) {}
    

    template<typename _Tp>
    ostream_joiner& operator=(const _Tp& __v)
    {
        if (!__first)
            *__output_iter << __delim;
        __first = false;
        *__output_iter << __v;
        return *this;
    }

    ostream_joiner& operator*()     _NOEXCEPT { return *this; }
    ostream_joiner& operator++()    _NOEXCEPT { return *this; }
    ostream_joiner& operator++(int) _NOEXCEPT { return *this; }

private:
    ostream_type*   __output_iter;
    _Delim          __delim;
    bool            __first;
};


template <class _CharT, class _Traits, class _Delim>
ostream_joiner<typename decay<_Delim>::type, _CharT, _Traits>
make_ostream_joiner(basic_ostream<_CharT, _Traits>& __os, _Delim && __d)
{ return ostream_joiner<typename decay<_Delim>::type, _CharT, _Traits>(__os, _VSTD::forward<_Delim>(__d)); }

_LIBCPP_END_NAMESPACE_LFTS

#endif /* _LIBCPP_STD_VER > 11 */

#endif // _LIBCPP_EXPERIMENTAL_ITERATOR
