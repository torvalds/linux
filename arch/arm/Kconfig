# SPDX-License-Identifier: GPL-2.0
config ARM
	bool
	default y
	select ARCH_32BIT_OFF_T
	select ARCH_CORRECT_STACKTRACE_ON_KRETPROBE if HAVE_KRETPROBES && FRAME_POINTER && !ARM_UNWIND
	select ARCH_HAS_BINFMT_FLAT
	select ARCH_HAS_CURRENT_STACK_POINTER
	select ARCH_HAS_DEBUG_VIRTUAL if MMU
	select ARCH_HAS_DMA_WRITE_COMBINE if !ARM_DMA_MEM_BUFFERABLE
	select ARCH_HAS_ELF_RANDOMIZE
	select ARCH_HAS_FORTIFY_SOURCE
	select ARCH_HAS_KEEPINITRD
	select ARCH_HAS_KCOV
	select ARCH_HAS_MEMBARRIER_SYNC_CORE
	select ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE
	select ARCH_HAS_PTE_SPECIAL if ARM_LPAE
	select ARCH_HAS_SETUP_DMA_OPS
	select ARCH_HAS_SET_MEMORY
	select ARCH_STACKWALK
	select ARCH_HAS_STRICT_KERNEL_RWX if MMU && !XIP_KERNEL
	select ARCH_HAS_STRICT_MODULE_RWX if MMU
	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
	select ARCH_HAS_SYNC_DMA_FOR_CPU
	select ARCH_HAS_TEARDOWN_DMA_OPS if MMU
	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
	select ARCH_HAVE_CUSTOM_GPIO_H
	select ARCH_HAVE_NMI_SAFE_CMPXCHG if CPU_V7 || CPU_V7M || CPU_V6K
	select ARCH_HAS_GCOV_PROFILE_ALL
	select ARCH_KEEP_MEMBLOCK
	select ARCH_HAS_UBSAN_SANITIZE_ALL
	select ARCH_MIGHT_HAVE_PC_PARPORT
	select ARCH_OPTIONAL_KERNEL_RWX if ARCH_HAS_STRICT_KERNEL_RWX
	select ARCH_OPTIONAL_KERNEL_RWX_DEFAULT if CPU_V7
	select ARCH_SUPPORTS_ATOMIC_RMW
	select ARCH_SUPPORTS_HUGETLBFS if ARM_LPAE
	select ARCH_USE_BUILTIN_BSWAP
	select ARCH_USE_CMPXCHG_LOCKREF
	select ARCH_USE_MEMTEST
	select ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT if MMU
	select ARCH_WANT_GENERAL_HUGETLB
	select ARCH_WANT_IPC_PARSE_VERSION
	select ARCH_WANT_LD_ORPHAN_WARN
	select BINFMT_FLAT_ARGVP_ENVP_ON_STACK
	select BUILDTIME_TABLE_SORT if MMU
	select COMMON_CLK if !(ARCH_RPC || ARCH_FOOTBRIDGE)
	select CLONE_BACKWARDS
	select CPU_PM if SUSPEND || CPU_IDLE
	select DCACHE_WORD_ACCESS if HAVE_EFFICIENT_UNALIGNED_ACCESS
	select DMA_DECLARE_COHERENT
	select DMA_GLOBAL_POOL if !MMU
	select DMA_OPS
	select DMA_NONCOHERENT_MMAP if MMU
	select EDAC_SUPPORT
	select EDAC_ATOMIC_SCRUB
	select GENERIC_ALLOCATOR
	select GENERIC_ARCH_TOPOLOGY if ARM_CPU_TOPOLOGY
	select GENERIC_ATOMIC64 if CPU_V7M || CPU_V6 || !CPU_32v6K || !AEABI
	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
	select GENERIC_IRQ_IPI if SMP
	select GENERIC_CPU_AUTOPROBE
	select GENERIC_EARLY_IOREMAP
	select GENERIC_IDLE_POLL_SETUP
	select GENERIC_IRQ_MULTI_HANDLER
	select GENERIC_IRQ_PROBE
	select GENERIC_IRQ_SHOW
	select GENERIC_IRQ_SHOW_LEVEL
	select GENERIC_LIB_DEVMEM_IS_ALLOWED
	select GENERIC_PCI_IOMAP
	select GENERIC_SCHED_CLOCK
	select GENERIC_SMP_IDLE_THREAD
	select HARDIRQS_SW_RESEND
	select HAVE_ARCH_AUDITSYSCALL if AEABI && !OABI_COMPAT
	select HAVE_ARCH_BITREVERSE if (CPU_32v7M || CPU_32v7) && !CPU_32v6
	select HAVE_ARCH_JUMP_LABEL if !XIP_KERNEL && !CPU_ENDIAN_BE32 && MMU
	select HAVE_ARCH_KFENCE if MMU && !XIP_KERNEL
	select HAVE_ARCH_KGDB if !CPU_ENDIAN_BE32 && MMU
	select HAVE_ARCH_KASAN if MMU && !XIP_KERNEL
	select HAVE_ARCH_KASAN_VMALLOC if HAVE_ARCH_KASAN
	select HAVE_ARCH_MMAP_RND_BITS if MMU
	select HAVE_ARCH_PFN_VALID
	select HAVE_ARCH_SECCOMP
	select HAVE_ARCH_SECCOMP_FILTER if AEABI && !OABI_COMPAT
	select HAVE_ARCH_THREAD_STRUCT_WHITELIST
	select HAVE_ARCH_TRACEHOOK
	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if ARM_LPAE
	select HAVE_ARM_SMCCC if CPU_V7
	select HAVE_EBPF_JIT if !CPU_ENDIAN_BE32
	select HAVE_CONTEXT_TRACKING_USER
	select HAVE_C_RECORDMCOUNT
	select HAVE_BUILDTIME_MCOUNT_SORT
	select HAVE_DEBUG_KMEMLEAK if !XIP_KERNEL
	select HAVE_DMA_CONTIGUOUS if MMU
	select HAVE_DYNAMIC_FTRACE if !XIP_KERNEL && !CPU_ENDIAN_BE32 && MMU
	select HAVE_DYNAMIC_FTRACE_WITH_REGS if HAVE_DYNAMIC_FTRACE
	select HAVE_EFFICIENT_UNALIGNED_ACCESS if (CPU_V6 || CPU_V6K || CPU_V7) && MMU
	select HAVE_EXIT_THREAD
	select HAVE_FAST_GUP if ARM_LPAE
	select HAVE_FTRACE_MCOUNT_RECORD if !XIP_KERNEL
	select HAVE_FUNCTION_ERROR_INJECTION
	select HAVE_FUNCTION_GRAPH_TRACER
	select HAVE_FUNCTION_TRACER if !XIP_KERNEL
	select HAVE_GCC_PLUGINS
	select HAVE_HW_BREAKPOINT if PERF_EVENTS && (CPU_V6 || CPU_V6K || CPU_V7)
	select HAVE_IRQ_TIME_ACCOUNTING
	select HAVE_KERNEL_GZIP
	select HAVE_KERNEL_LZ4
	select HAVE_KERNEL_LZMA
	select HAVE_KERNEL_LZO
	select HAVE_KERNEL_XZ
	select HAVE_KPROBES if !XIP_KERNEL && !CPU_ENDIAN_BE32 && !CPU_V7M
	select HAVE_KRETPROBES if HAVE_KPROBES
	select HAVE_MOD_ARCH_SPECIFIC
	select HAVE_NMI
	select HAVE_OPTPROBES if !THUMB2_KERNEL
	select HAVE_PCI if MMU
	select HAVE_PERF_EVENTS
	select HAVE_PERF_REGS
	select HAVE_PERF_USER_STACK_DUMP
	select MMU_GATHER_RCU_TABLE_FREE if SMP && ARM_LPAE
	select HAVE_REGS_AND_STACK_ACCESS_API
	select HAVE_RSEQ
	select HAVE_STACKPROTECTOR
	select HAVE_SYSCALL_TRACEPOINTS
	select HAVE_UID16
	select HAVE_VIRT_CPU_ACCOUNTING_GEN
	select IRQ_FORCED_THREADING
	select MODULES_USE_ELF_REL
	select NEED_DMA_MAP_STATE
	select OF_EARLY_FLATTREE if OF
	select OLD_SIGACTION
	select OLD_SIGSUSPEND3
	select PCI_DOMAINS_GENERIC if PCI
	select PCI_SYSCALL if PCI
	select PERF_USE_VMALLOC
	select RTC_LIB
	select SPARSE_IRQ if !(ARCH_FOOTBRIDGE || ARCH_RPC)
	select SYS_SUPPORTS_APM_EMULATION
	select THREAD_INFO_IN_TASK
	select TIMER_OF if OF
	select HAVE_ARCH_VMAP_STACK if MMU && ARM_HAS_GROUP_RELOCS
	select TRACE_IRQFLAGS_SUPPORT if !CPU_V7M
	select USE_OF if !(ARCH_FOOTBRIDGE || ARCH_RPC || ARCH_SA1100)
	# Above selects are sorted alphabetically; please add new ones
	# according to that.  Thanks.
	help
	  The ARM series is a line of low-power-consumption RISC chip designs
	  licensed by ARM Ltd and targeted at embedded applications and
	  handhelds such as the Compaq IPAQ.  ARM-based PCs are no longer
	  manufactured, but legacy ARM-based PC hardware remains popular in
	  Europe.  There is an ARM Linux project with a web page at
	  <http://www.arm.linux.org.uk/>.

config ARM_HAS_GROUP_RELOCS
	def_bool y
	depends on !LD_IS_LLD || LLD_VERSION >= 140000
	depends on !COMPILE_TEST
	help
	  Whether or not to use R_ARM_ALU_PC_Gn or R_ARM_LDR_PC_Gn group
	  relocations, which have been around for a long time, but were not
	  supported in LLD until version 14. The combined range is -/+ 256 MiB,
	  which is usually sufficient, but not for allyesconfig, so we disable
	  this feature when doing compile testing.

config ARM_DMA_USE_IOMMU
	bool
	select NEED_SG_DMA_LENGTH

if ARM_DMA_USE_IOMMU

config ARM_DMA_IOMMU_ALIGNMENT
	int "Maximum PAGE_SIZE order of alignment for DMA IOMMU buffers"
	range 4 9
	default 8
	help
	  DMA mapping framework by default aligns all buffers to the smallest
	  PAGE_SIZE order which is greater than or equal to the requested buffer
	  size. This works well for buffers up to a few hundreds kilobytes, but
	  for larger buffers it just a waste of address space. Drivers which has
	  relatively small addressing window (like 64Mib) might run out of
	  virtual space with just a few allocations.

	  With this parameter you can specify the maximum PAGE_SIZE order for
	  DMA IOMMU buffers. Larger buffers will be aligned only to this
	  specified order. The order is expressed as a power of two multiplied
	  by the PAGE_SIZE.

endif

config SYS_SUPPORTS_APM_EMULATION
	bool

config HAVE_TCM
	bool
	select GENERIC_ALLOCATOR

config HAVE_PROC_CPU
	bool

config NO_IOPORT_MAP
	bool

config SBUS
	bool

config STACKTRACE_SUPPORT
	bool
	default y

config LOCKDEP_SUPPORT
	bool
	default y

config ARCH_HAS_ILOG2_U32
	bool

config ARCH_HAS_ILOG2_U64
	bool

config ARCH_HAS_BANDGAP
	bool

config FIX_EARLYCON_MEM
	def_bool y if MMU

config GENERIC_HWEIGHT
	bool
	default y

config GENERIC_CALIBRATE_DELAY
	bool
	default y

config ARCH_MAY_HAVE_PC_FDC
	bool

config ARCH_SUPPORTS_UPROBES
	def_bool y

config GENERIC_ISA_DMA
	bool

config FIQ
	bool

config ARCH_MTD_XIP
	bool

config ARM_PATCH_PHYS_VIRT
	bool "Patch physical to virtual translations at runtime" if EMBEDDED
	default y
	depends on MMU
	help
	  Patch phys-to-virt and virt-to-phys translation functions at
	  boot and module load time according to the position of the
	  kernel in system memory.

	  This can only be used with non-XIP MMU kernels where the base
	  of physical memory is at a 2 MiB boundary.

	  Only disable this option if you know that you do not require
	  this feature (eg, building a kernel for a single machine) and
	  you need to shrink the kernel to the minimal size.

config NEED_MACH_IO_H
	bool
	help
	  Select this when mach/io.h is required to provide special
	  definitions for this platform.  The need for mach/io.h should
	  be avoided when possible.

config NEED_MACH_MEMORY_H
	bool
	help
	  Select this when mach/memory.h is required to provide special
	  definitions for this platform.  The need for mach/memory.h should
	  be avoided when possible.

config PHYS_OFFSET
	hex "Physical address of main memory" if MMU
	depends on !ARM_PATCH_PHYS_VIRT || !AUTO_ZRELADDR
	default DRAM_BASE if !MMU
	default 0x00000000 if ARCH_FOOTBRIDGE
	default 0x10000000 if ARCH_OMAP1 || ARCH_RPC
	default 0xa0000000 if ARCH_PXA
	default 0xc0000000 if ARCH_EP93XX || ARCH_SA1100
	default 0
	help
	  Please provide the physical address corresponding to the
	  location of main memory in your system.

config GENERIC_BUG
	def_bool y
	depends on BUG

config PGTABLE_LEVELS
	int
	default 3 if ARM_LPAE
	default 2

menu "System Type"

config MMU
	bool "MMU-based Paged Memory Management Support"
	default y
	help
	  Select if you want MMU-based virtualised addressing space
	  support by paged memory management. If unsure, say 'Y'.

config ARM_SINGLE_ARMV7M
	def_bool !MMU
	select ARM_NVIC
	select CPU_V7M
	select NO_IOPORT_MAP

config ARCH_MMAP_RND_BITS_MIN
	default 8

config ARCH_MMAP_RND_BITS_MAX
	default 14 if PAGE_OFFSET=0x40000000
	default 15 if PAGE_OFFSET=0x80000000
	default 16

config ARCH_MULTIPLATFORM
	bool "Require kernel to be portable to multiple machines" if EXPERT
	depends on MMU && !(ARCH_FOOTBRIDGE || ARCH_RPC || ARCH_SA1100)
	default y
	help
	  In general, all Arm machines can be supported in a single
	  kernel image, covering either Armv4/v5 or Armv6/v7.

	  However, some configuration options require hardcoding machine
	  specific physical addresses or enable errata workarounds that may
	  break other machines.

	  Selecting N here allows using those options, including
	  DEBUG_UNCOMPRESS, XIP_KERNEL and ZBOOT_ROM. If unsure, say Y.

menu "Platform selection"
	depends on MMU

comment "CPU Core family selection"

config ARCH_MULTI_V4
	bool "ARMv4 based platforms (FA526, StrongARM)"
	depends on !ARCH_MULTI_V6_V7
	# https://github.com/llvm/llvm-project/issues/50764
	depends on !LD_IS_LLD || LLD_VERSION >= 160000
	select ARCH_MULTI_V4_V5
	select CPU_FA526 if !(CPU_SA110 || CPU_SA1100)

config ARCH_MULTI_V4T
	bool "ARMv4T based platforms (ARM720T, ARM920T, ...)"
	depends on !ARCH_MULTI_V6_V7
	# https://github.com/llvm/llvm-project/issues/50764
	depends on !LD_IS_LLD || LLD_VERSION >= 160000
	select ARCH_MULTI_V4_V5
	select CPU_ARM920T if !(CPU_ARM7TDMI || CPU_ARM720T || \
		CPU_ARM740T || CPU_ARM9TDMI || CPU_ARM922T || \
		CPU_ARM925T || CPU_ARM940T)

config ARCH_MULTI_V5
	bool "ARMv5 based platforms (ARM926T, XSCALE, PJ1, ...)"
	depends on !ARCH_MULTI_V6_V7
	select ARCH_MULTI_V4_V5
	select CPU_ARM926T if !(CPU_ARM946E || CPU_ARM1020 || \
		CPU_ARM1020E || CPU_ARM1022 || CPU_ARM1026 || \
		CPU_XSCALE || CPU_XSC3 || CPU_MOHAWK || CPU_FEROCEON)

config ARCH_MULTI_V4_V5
	bool

config ARCH_MULTI_V6
	bool "ARMv6 based platforms (ARM11)"
	select ARCH_MULTI_V6_V7
	select CPU_V6K

config ARCH_MULTI_V7
	bool "ARMv7 based platforms (Cortex-A, PJ4, Scorpion, Krait)"
	default y
	select ARCH_MULTI_V6_V7
	select CPU_V7
	select HAVE_SMP

config ARCH_MULTI_V6_V7
	bool
	select MIGHT_HAVE_CACHE_L2X0

config ARCH_MULTI_CPU_AUTO
	def_bool !(ARCH_MULTI_V4 || ARCH_MULTI_V4T || ARCH_MULTI_V6_V7)
	select ARCH_MULTI_V5

endmenu

config ARCH_VIRT
	bool "Dummy Virtual Machine"
	depends on ARCH_MULTI_V7
	select ARM_AMBA
	select ARM_GIC
	select ARM_GIC_V2M if PCI
	select ARM_GIC_V3
	select ARM_GIC_V3_ITS if PCI
	select ARM_PSCI
	select HAVE_ARM_ARCH_TIMER

config ARCH_AIROHA
	bool "Airoha SoC Support"
	depends on ARCH_MULTI_V7
	select ARM_AMBA
	select ARM_GIC
	select ARM_GIC_V3
	select ARM_PSCI
	select HAVE_ARM_ARCH_TIMER
	help
	  Support for Airoha EN7523 SoCs

#
# This is sorted alphabetically by mach-* pathname.  However, plat-*
# Kconfigs may be included either alphabetically (according to the
# plat- suffix) or along side the corresponding mach-* source.
#
source "arch/arm/mach-actions/Kconfig"

source "arch/arm/mach-alpine/Kconfig"

source "arch/arm/mach-artpec/Kconfig"

source "arch/arm/mach-asm9260/Kconfig"

source "arch/arm/mach-aspeed/Kconfig"

source "arch/arm/mach-at91/Kconfig"

source "arch/arm/mach-axxia/Kconfig"

source "arch/arm/mach-bcm/Kconfig"

source "arch/arm/mach-berlin/Kconfig"

source "arch/arm/mach-clps711x/Kconfig"

source "arch/arm/mach-davinci/Kconfig"

source "arch/arm/mach-digicolor/Kconfig"

source "arch/arm/mach-dove/Kconfig"

source "arch/arm/mach-ep93xx/Kconfig"

source "arch/arm/mach-exynos/Kconfig"

source "arch/arm/mach-footbridge/Kconfig"

source "arch/arm/mach-gemini/Kconfig"

source "arch/arm/mach-highbank/Kconfig"

source "arch/arm/mach-hisi/Kconfig"

source "arch/arm/mach-hpe/Kconfig"

source "arch/arm/mach-imx/Kconfig"

source "arch/arm/mach-ixp4xx/Kconfig"

source "arch/arm/mach-keystone/Kconfig"

source "arch/arm/mach-lpc32xx/Kconfig"

source "arch/arm/mach-mediatek/Kconfig"

source "arch/arm/mach-meson/Kconfig"

source "arch/arm/mach-milbeaut/Kconfig"

source "arch/arm/mach-mmp/Kconfig"

source "arch/arm/mach-moxart/Kconfig"

source "arch/arm/mach-mstar/Kconfig"

source "arch/arm/mach-mv78xx0/Kconfig"

source "arch/arm/mach-mvebu/Kconfig"

source "arch/arm/mach-mxs/Kconfig"

source "arch/arm/mach-nomadik/Kconfig"

source "arch/arm/mach-npcm/Kconfig"

source "arch/arm/mach-nspire/Kconfig"

source "arch/arm/mach-omap1/Kconfig"

source "arch/arm/mach-omap2/Kconfig"

source "arch/arm/mach-orion5x/Kconfig"

source "arch/arm/mach-oxnas/Kconfig"

source "arch/arm/mach-pxa/Kconfig"

source "arch/arm/mach-qcom/Kconfig"

source "arch/arm/mach-rda/Kconfig"

source "arch/arm/mach-realtek/Kconfig"

source "arch/arm/mach-rpc/Kconfig"

source "arch/arm/mach-rockchip/Kconfig"

source "arch/arm/mach-s3c/Kconfig"

source "arch/arm/mach-s5pv210/Kconfig"

source "arch/arm/mach-sa1100/Kconfig"

source "arch/arm/mach-shmobile/Kconfig"

source "arch/arm/mach-socfpga/Kconfig"

source "arch/arm/mach-spear/Kconfig"

source "arch/arm/mach-sti/Kconfig"

source "arch/arm/mach-stm32/Kconfig"

source "arch/arm/mach-sunplus/Kconfig"

source "arch/arm/mach-sunxi/Kconfig"

source "arch/arm/mach-tegra/Kconfig"

source "arch/arm/mach-uniphier/Kconfig"

source "arch/arm/mach-ux500/Kconfig"

source "arch/arm/mach-versatile/Kconfig"

source "arch/arm/mach-vt8500/Kconfig"

source "arch/arm/mach-zynq/Kconfig"

# ARMv7-M architecture
config ARCH_LPC18XX
	bool "NXP LPC18xx/LPC43xx"
	depends on ARM_SINGLE_ARMV7M
	select ARCH_HAS_RESET_CONTROLLER
	select ARM_AMBA
	select CLKSRC_LPC32XX
	select PINCTRL
	help
	  Support for NXP's LPC18xx Cortex-M3 and LPC43xx Cortex-M4
	  high performance microcontrollers.

config ARCH_MPS2
	bool "ARM MPS2 platform"
	depends on ARM_SINGLE_ARMV7M
	select ARM_AMBA
	select CLKSRC_MPS2
	help
	  Support for Cortex-M Prototyping System (or V2M-MPS2) which comes
	  with a range of available cores like Cortex-M3/M4/M7.

	  Please, note that depends which Application Note is used memory map
	  for the platform may vary, so adjustment of RAM base might be needed.

# Definitions to make life easier
config ARCH_ACORN
	bool

config PLAT_ORION
	bool
	select CLKSRC_MMIO
	select GENERIC_IRQ_CHIP
	select IRQ_DOMAIN

config PLAT_ORION_LEGACY
	bool
	select PLAT_ORION

config PLAT_VERSATILE
	bool

source "arch/arm/mm/Kconfig"

config IWMMXT
	bool "Enable iWMMXt support"
	depends on CPU_XSCALE || CPU_XSC3 || CPU_MOHAWK || CPU_PJ4 || CPU_PJ4B
	default y if PXA27x || PXA3xx || ARCH_MMP || CPU_PJ4 || CPU_PJ4B
	help
	  Enable support for iWMMXt context switching at run time if
	  running on a CPU that supports it.

if !MMU
source "arch/arm/Kconfig-nommu"
endif

config PJ4B_ERRATA_4742
	bool "PJ4B Errata 4742: IDLE Wake Up Commands can Cause the CPU Core to Cease Operation"
	depends on CPU_PJ4B && MACH_ARMADA_370
	default y
	help
	  When coming out of either a Wait for Interrupt (WFI) or a Wait for
	  Event (WFE) IDLE states, a specific timing sensitivity exists between
	  the retiring WFI/WFE instructions and the newly issued subsequent
	  instructions.  This sensitivity can result in a CPU hang scenario.
	  Workaround:
	  The software must insert either a Data Synchronization Barrier (DSB)
	  or Data Memory Barrier (DMB) command immediately after the WFI/WFE
	  instruction

config ARM_ERRATA_326103
	bool "ARM errata: FSR write bit incorrect on a SWP to read-only memory"
	depends on CPU_V6
	help
	  Executing a SWP instruction to read-only memory does not set bit 11
	  of the FSR on the ARM 1136 prior to r1p0. This causes the kernel to
	  treat the access as a read, preventing a COW from occurring and
	  causing the faulting task to livelock.

config ARM_ERRATA_411920
	bool "ARM errata: Invalidation of the Instruction Cache operation can fail"
	depends on CPU_V6 || CPU_V6K
	help
	  Invalidation of the Instruction Cache operation can
	  fail. This erratum is present in 1136 (before r1p4), 1156 and 1176.
	  It does not affect the MPCore. This option enables the ARM Ltd.
	  recommended workaround.

config ARM_ERRATA_430973
	bool "ARM errata: Stale prediction on replaced interworking branch"
	depends on CPU_V7
	help
	  This option enables the workaround for the 430973 Cortex-A8
	  r1p* erratum. If a code sequence containing an ARM/Thumb
	  interworking branch is replaced with another code sequence at the
	  same virtual address, whether due to self-modifying code or virtual
	  to physical address re-mapping, Cortex-A8 does not recover from the
	  stale interworking branch prediction. This results in Cortex-A8
	  executing the new code sequence in the incorrect ARM or Thumb state.
	  The workaround enables the BTB/BTAC operations by setting ACTLR.IBE
	  and also flushes the branch target cache at every context switch.
	  Note that setting specific bits in the ACTLR register may not be
	  available in non-secure mode.

config ARM_ERRATA_458693
	bool "ARM errata: Processor deadlock when a false hazard is created"
	depends on CPU_V7
	depends on !ARCH_MULTIPLATFORM
	help
	  This option enables the workaround for the 458693 Cortex-A8 (r2p0)
	  erratum. For very specific sequences of memory operations, it is
	  possible for a hazard condition intended for a cache line to instead
	  be incorrectly associated with a different cache line. This false
	  hazard might then cause a processor deadlock. The workaround enables
	  the L1 caching of the NEON accesses and disables the PLD instruction
	  in the ACTLR register. Note that setting specific bits in the ACTLR
	  register may not be available in non-secure mode and thus is not
	  available on a multiplatform kernel. This should be applied by the
	  bootloader instead.

config ARM_ERRATA_460075
	bool "ARM errata: Data written to the L2 cache can be overwritten with stale data"
	depends on CPU_V7
	depends on !ARCH_MULTIPLATFORM
	help
	  This option enables the workaround for the 460075 Cortex-A8 (r2p0)
	  erratum. Any asynchronous access to the L2 cache may encounter a
	  situation in which recent store transactions to the L2 cache are lost
	  and overwritten with stale memory contents from external memory. The
	  workaround disables the write-allocate mode for the L2 cache via the
	  ACTLR register. Note that setting specific bits in the ACTLR register
	  may not be available in non-secure mode and thus is not available on
	  a multiplatform kernel. This should be applied by the bootloader
	  instead.

config ARM_ERRATA_742230
	bool "ARM errata: DMB operation may be faulty"
	depends on CPU_V7 && SMP
	depends on !ARCH_MULTIPLATFORM
	help
	  This option enables the workaround for the 742230 Cortex-A9
	  (r1p0..r2p2) erratum. Under rare circumstances, a DMB instruction
	  between two write operations may not ensure the correct visibility
	  ordering of the two writes. This workaround sets a specific bit in
	  the diagnostic register of the Cortex-A9 which causes the DMB
	  instruction to behave as a DSB, ensuring the correct behaviour of
	  the two writes. Note that setting specific bits in the diagnostics
	  register may not be available in non-secure mode and thus is not
	  available on a multiplatform kernel. This should be applied by the
	  bootloader instead.

config ARM_ERRATA_742231
	bool "ARM errata: Incorrect hazard handling in the SCU may lead to data corruption"
	depends on CPU_V7 && SMP
	depends on !ARCH_MULTIPLATFORM
	help
	  This option enables the workaround for the 742231 Cortex-A9
	  (r2p0..r2p2) erratum. Under certain conditions, specific to the
	  Cortex-A9 MPCore micro-architecture, two CPUs working in SMP mode,
	  accessing some data located in the same cache line, may get corrupted
	  data due to bad handling of the address hazard when the line gets
	  replaced from one of the CPUs at the same time as another CPU is
	  accessing it. This workaround sets specific bits in the diagnostic
	  register of the Cortex-A9 which reduces the linefill issuing
	  capabilities of the processor. Note that setting specific bits in the
	  diagnostics register may not be available in non-secure mode and thus
	  is not available on a multiplatform kernel. This should be applied by
	  the bootloader instead.

config ARM_ERRATA_643719
	bool "ARM errata: LoUIS bit field in CLIDR register is incorrect"
	depends on CPU_V7 && SMP
	default y
	help
	  This option enables the workaround for the 643719 Cortex-A9 (prior to
	  r1p0) erratum. On affected cores the LoUIS bit field of the CLIDR
	  register returns zero when it should return one. The workaround
	  corrects this value, ensuring cache maintenance operations which use
	  it behave as intended and avoiding data corruption.

config ARM_ERRATA_720789
	bool "ARM errata: TLBIASIDIS and TLBIMVAIS operations can broadcast a faulty ASID"
	depends on CPU_V7
	help
	  This option enables the workaround for the 720789 Cortex-A9 (prior to
	  r2p0) erratum. A faulty ASID can be sent to the other CPUs for the
	  broadcasted CP15 TLB maintenance operations TLBIASIDIS and TLBIMVAIS.
	  As a consequence of this erratum, some TLB entries which should be
	  invalidated are not, resulting in an incoherency in the system page
	  tables. The workaround changes the TLB flushing routines to invalidate
	  entries regardless of the ASID.

config ARM_ERRATA_743622
	bool "ARM errata: Faulty hazard checking in the Store Buffer may lead to data corruption"
	depends on CPU_V7
	depends on !ARCH_MULTIPLATFORM
	help
	  This option enables the workaround for the 743622 Cortex-A9
	  (r2p*) erratum. Under very rare conditions, a faulty
	  optimisation in the Cortex-A9 Store Buffer may lead to data
	  corruption. This workaround sets a specific bit in the diagnostic
	  register of the Cortex-A9 which disables the Store Buffer
	  optimisation, preventing the defect from occurring. This has no
	  visible impact on the overall performance or power consumption of the
	  processor. Note that setting specific bits in the diagnostics register
	  may not be available in non-secure mode and thus is not available on a
	  multiplatform kernel. This should be applied by the bootloader instead.

config ARM_ERRATA_751472
	bool "ARM errata: Interrupted ICIALLUIS may prevent completion of broadcasted operation"
	depends on CPU_V7
	depends on !ARCH_MULTIPLATFORM
	help
	  This option enables the workaround for the 751472 Cortex-A9 (prior
	  to r3p0) erratum. An interrupted ICIALLUIS operation may prevent the
	  completion of a following broadcasted operation if the second
	  operation is received by a CPU before the ICIALLUIS has completed,
	  potentially leading to corrupted entries in the cache or TLB.
	  Note that setting specific bits in the diagnostics register may
	  not be available in non-secure mode and thus is not available on
	  a multiplatform kernel. This should be applied by the bootloader
	  instead.

config ARM_ERRATA_754322
	bool "ARM errata: possible faulty MMU translations following an ASID switch"
	depends on CPU_V7
	help
	  This option enables the workaround for the 754322 Cortex-A9 (r2p*,
	  r3p*) erratum. A speculative memory access may cause a page table walk
	  which starts prior to an ASID switch but completes afterwards. This
	  can populate the micro-TLB with a stale entry which may be hit with
	  the new ASID. This workaround places two dsb instructions in the mm
	  switching code so that no page table walks can cross the ASID switch.

config ARM_ERRATA_754327
	bool "ARM errata: no automatic Store Buffer drain"
	depends on CPU_V7 && SMP
	help
	  This option enables the workaround for the 754327 Cortex-A9 (prior to
	  r2p0) erratum. The Store Buffer does not have any automatic draining
	  mechanism and therefore a livelock may occur if an external agent
	  continuously polls a memory location waiting to observe an update.
	  This workaround defines cpu_relax() as smp_mb(), preventing correctly
	  written polling loops from denying visibility of updates to memory.

config ARM_ERRATA_364296
	bool "ARM errata: Possible cache data corruption with hit-under-miss enabled"
	depends on CPU_V6
	help
	  This options enables the workaround for the 364296 ARM1136
	  r0p2 erratum (possible cache data corruption with
	  hit-under-miss enabled). It sets the undocumented bit 31 in
	  the auxiliary control register and the FI bit in the control
	  register, thus disabling hit-under-miss without putting the
	  processor into full low interrupt latency mode. ARM11MPCore
	  is not affected.

config ARM_ERRATA_764369
	bool "ARM errata: Data cache line maintenance operation by MVA may not succeed"
	depends on CPU_V7 && SMP
	help
	  This option enables the workaround for erratum 764369
	  affecting Cortex-A9 MPCore with two or more processors (all
	  current revisions). Under certain timing circumstances, a data
	  cache line maintenance operation by MVA targeting an Inner
	  Shareable memory region may fail to proceed up to either the
	  Point of Coherency or to the Point of Unification of the
	  system. This workaround adds a DSB instruction before the
	  relevant cache maintenance functions and sets a specific bit
	  in the diagnostic control register of the SCU.

config ARM_ERRATA_764319
	bool "ARM errata: Read to DBGPRSR and DBGOSLSR may generate Undefined instruction"
	depends on CPU_V7
	help
	  This option enables the workaround for the 764319 Cortex A-9 erratum.
	  CP14 read accesses to the DBGPRSR and DBGOSLSR registers generate an
	  unexpected Undefined Instruction exception when the DBGSWENABLE
	  external pin is set to 0, even when the CP14 accesses are performed
	  from a privileged mode. This work around catches the exception in a
	  way the kernel does not stop execution.

config ARM_ERRATA_775420
       bool "ARM errata: A data cache maintenance operation which aborts, might lead to deadlock"
       depends on CPU_V7
       help
	 This option enables the workaround for the 775420 Cortex-A9 (r2p2,
	 r2p6,r2p8,r2p10,r3p0) erratum. In case a data cache maintenance
	 operation aborts with MMU exception, it might cause the processor
	 to deadlock. This workaround puts DSB before executing ISB if
	 an abort may occur on cache maintenance.

config ARM_ERRATA_798181
	bool "ARM errata: TLBI/DSB failure on Cortex-A15"
	depends on CPU_V7 && SMP
	help
	  On Cortex-A15 (r0p0..r3p2) the TLBI*IS/DSB operations are not
	  adequately shooting down all use of the old entries. This
	  option enables the Linux kernel workaround for this erratum
	  which sends an IPI to the CPUs that are running the same ASID
	  as the one being invalidated.

config ARM_ERRATA_773022
	bool "ARM errata: incorrect instructions may be executed from loop buffer"
	depends on CPU_V7
	help
	  This option enables the workaround for the 773022 Cortex-A15
	  (up to r0p4) erratum. In certain rare sequences of code, the
	  loop buffer may deliver incorrect instructions. This
	  workaround disables the loop buffer to avoid the erratum.

config ARM_ERRATA_818325_852422
	bool "ARM errata: A12: some seqs of opposed cond code instrs => deadlock or corruption"
	depends on CPU_V7
	help
	  This option enables the workaround for:
	  - Cortex-A12 818325: Execution of an UNPREDICTABLE STR or STM
	    instruction might deadlock.  Fixed in r0p1.
	  - Cortex-A12 852422: Execution of a sequence of instructions might
	    lead to either a data corruption or a CPU deadlock.  Not fixed in
	    any Cortex-A12 cores yet.
	  This workaround for all both errata involves setting bit[12] of the
	  Feature Register. This bit disables an optimisation applied to a
	  sequence of 2 instructions that use opposing condition codes.

config ARM_ERRATA_821420
	bool "ARM errata: A12: sequence of VMOV to core registers might lead to a dead lock"
	depends on CPU_V7
	help
	  This option enables the workaround for the 821420 Cortex-A12
	  (all revs) erratum. In very rare timing conditions, a sequence
	  of VMOV to Core registers instructions, for which the second
	  one is in the shadow of a branch or abort, can lead to a
	  deadlock when the VMOV instructions are issued out-of-order.

config ARM_ERRATA_825619
	bool "ARM errata: A12: DMB NSHST/ISHST mixed ... might cause deadlock"
	depends on CPU_V7
	help
	  This option enables the workaround for the 825619 Cortex-A12
	  (all revs) erratum. Within rare timing constraints, executing a
	  DMB NSHST or DMB ISHST instruction followed by a mix of Cacheable
	  and Device/Strongly-Ordered loads and stores might cause deadlock

config ARM_ERRATA_857271
	bool "ARM errata: A12: CPU might deadlock under some very rare internal conditions"
	depends on CPU_V7
	help
	  This option enables the workaround for the 857271 Cortex-A12
	  (all revs) erratum. Under very rare timing conditions, the CPU might
	  hang. The workaround is expected to have a < 1% performance impact.

config ARM_ERRATA_852421
	bool "ARM errata: A17: DMB ST might fail to create order between stores"
	depends on CPU_V7
	help
	  This option enables the workaround for the 852421 Cortex-A17
	  (r1p0, r1p1, r1p2) erratum. Under very rare timing conditions,
	  execution of a DMB ST instruction might fail to properly order
	  stores from GroupA and stores from GroupB.

config ARM_ERRATA_852423
	bool "ARM errata: A17: some seqs of opposed cond code instrs => deadlock or corruption"
	depends on CPU_V7
	help
	  This option enables the workaround for:
	  - Cortex-A17 852423: Execution of a sequence of instructions might
	    lead to either a data corruption or a CPU deadlock.  Not fixed in
	    any Cortex-A17 cores yet.
	  This is identical to Cortex-A12 erratum 852422.  It is a separate
	  config option from the A12 erratum due to the way errata are checked
	  for and handled.

config ARM_ERRATA_857272
	bool "ARM errata: A17: CPU might deadlock under some very rare internal conditions"
	depends on CPU_V7
	help
	  This option enables the workaround for the 857272 Cortex-A17 erratum.
	  This erratum is not known to be fixed in any A17 revision.
	  This is identical to Cortex-A12 erratum 857271.  It is a separate
	  config option from the A12 erratum due to the way errata are checked
	  for and handled.

endmenu

source "arch/arm/common/Kconfig"

menu "Bus support"

config ISA
	bool
	help
	  Find out whether you have ISA slots on your motherboard.  ISA is the
	  name of a bus system, i.e. the way the CPU talks to the other stuff
	  inside your box.  Other bus systems are PCI, EISA, MicroChannel
	  (MCA) or VESA.  ISA is an older system, now being displaced by PCI;
	  newer boards don't support it.  If you have ISA, say Y, otherwise N.

# Select ISA DMA interface
config ISA_DMA_API
	bool

config ARM_ERRATA_814220
	bool "ARM errata: Cache maintenance by set/way operations can execute out of order"
	depends on CPU_V7
	help
	  The v7 ARM states that all cache and branch predictor maintenance
	  operations that do not specify an address execute, relative to
	  each other, in program order.
	  However, because of this erratum, an L2 set/way cache maintenance
	  operation can overtake an L1 set/way cache maintenance operation.
	  This ERRATA only affected the Cortex-A7 and present in r0p2, r0p3,
	  r0p4, r0p5.

endmenu

menu "Kernel Features"

config HAVE_SMP
	bool
	help
	  This option should be selected by machines which have an SMP-
	  capable CPU.

	  The only effect of this option is to make the SMP-related
	  options available to the user for configuration.

config SMP
	bool "Symmetric Multi-Processing"
	depends on CPU_V6K || CPU_V7
	depends on HAVE_SMP
	depends on MMU || ARM_MPU
	select IRQ_WORK
	help
	  This enables support for systems with more than one CPU. If you have
	  a system with only one CPU, say N. If you have a system with more
	  than one CPU, say Y.

	  If you say N here, the kernel will run on uni- and multiprocessor
	  machines, but will use only one CPU of a multiprocessor machine. If
	  you say Y here, the kernel will run on many, but not all,
	  uniprocessor machines. On a uniprocessor machine, the kernel
	  will run faster if you say N here.

	  See also <file:Documentation/x86/i386/IO-APIC.rst>,
	  <file:Documentation/admin-guide/lockup-watchdogs.rst> and the SMP-HOWTO available at
	  <http://tldp.org/HOWTO/SMP-HOWTO.html>.

	  If you don't know what to do here, say N.

config SMP_ON_UP
	bool "Allow booting SMP kernel on uniprocessor systems"
	depends on SMP && MMU
	default y
	help
	  SMP kernels contain instructions which fail on non-SMP processors.
	  Enabling this option allows the kernel to modify itself to make
	  these instructions safe.  Disabling it allows about 1K of space
	  savings.

	  If you don't know what to do here, say Y.


config CURRENT_POINTER_IN_TPIDRURO
	def_bool y
	depends on CPU_32v6K && !CPU_V6

config IRQSTACKS
	def_bool y
	select HAVE_IRQ_EXIT_ON_IRQ_STACK
	select HAVE_SOFTIRQ_ON_OWN_STACK

config ARM_CPU_TOPOLOGY
	bool "Support cpu topology definition"
	depends on SMP && CPU_V7
	default y
	help
	  Support ARM cpu topology definition. The MPIDR register defines
	  affinity between processors which is then used to describe the cpu
	  topology of an ARM System.

config SCHED_MC
	bool "Multi-core scheduler support"
	depends on ARM_CPU_TOPOLOGY
	help
	  Multi-core scheduler support improves the CPU scheduler's decision
	  making when dealing with multi-core CPU chips at a cost of slightly
	  increased overhead in some places. If unsure say N here.

config SCHED_SMT
	bool "SMT scheduler support"
	depends on ARM_CPU_TOPOLOGY
	help
	  Improves the CPU scheduler's decision making when dealing with
	  MultiThreading at a cost of slightly increased overhead in some
	  places. If unsure say N here.

config HAVE_ARM_SCU
	bool
	help
	  This option enables support for the ARM snoop control unit

config HAVE_ARM_ARCH_TIMER
	bool "Architected timer support"
	depends on CPU_V7
	select ARM_ARCH_TIMER
	help
	  This option enables support for the ARM architected timer

config HAVE_ARM_TWD
	bool
	help
	  This options enables support for the ARM timer and watchdog unit

config MCPM
	bool "Multi-Cluster Power Management"
	depends on CPU_V7 && SMP
	help
	  This option provides the common power management infrastructure
	  for (multi-)cluster based systems, such as big.LITTLE based
	  systems.

config MCPM_QUAD_CLUSTER
	bool
	depends on MCPM
	help
	  To avoid wasting resources unnecessarily, MCPM only supports up
	  to 2 clusters by default.
	  Platforms with 3 or 4 clusters that use MCPM must select this
	  option to allow the additional clusters to be managed.

config BIG_LITTLE
	bool "big.LITTLE support (Experimental)"
	depends on CPU_V7 && SMP
	select MCPM
	help
	  This option enables support selections for the big.LITTLE
	  system architecture.

config BL_SWITCHER
	bool "big.LITTLE switcher support"
	depends on BIG_LITTLE && MCPM && HOTPLUG_CPU && ARM_GIC
	select CPU_PM
	help
	  The big.LITTLE "switcher" provides the core functionality to
	  transparently handle transition between a cluster of A15's
	  and a cluster of A7's in a big.LITTLE system.

config BL_SWITCHER_DUMMY_IF
	tristate "Simple big.LITTLE switcher user interface"
	depends on BL_SWITCHER && DEBUG_KERNEL
	help
	  This is a simple and dummy char dev interface to control
	  the big.LITTLE switcher core code.  It is meant for
	  debugging purposes only.

choice
	prompt "Memory split"
	depends on MMU
	default VMSPLIT_3G
	help
	  Select the desired split between kernel and user memory.

	  If you are not absolutely sure what you are doing, leave this
	  option alone!

	config VMSPLIT_3G
		bool "3G/1G user/kernel split"
	config VMSPLIT_3G_OPT
		depends on !ARM_LPAE
		bool "3G/1G user/kernel split (for full 1G low memory)"
	config VMSPLIT_2G
		bool "2G/2G user/kernel split"
	config VMSPLIT_1G
		bool "1G/3G user/kernel split"
endchoice

config PAGE_OFFSET
	hex
	default PHYS_OFFSET if !MMU
	default 0x40000000 if VMSPLIT_1G
	default 0x80000000 if VMSPLIT_2G
	default 0xB0000000 if VMSPLIT_3G_OPT
	default 0xC0000000

config KASAN_SHADOW_OFFSET
	hex
	depends on KASAN
	default 0x1f000000 if PAGE_OFFSET=0x40000000
	default 0x5f000000 if PAGE_OFFSET=0x80000000
	default 0x9f000000 if PAGE_OFFSET=0xC0000000
	default 0x8f000000 if PAGE_OFFSET=0xB0000000
	default 0xffffffff

config NR_CPUS
	int "Maximum number of CPUs (2-32)"
	range 2 16 if DEBUG_KMAP_LOCAL
	range 2 32 if !DEBUG_KMAP_LOCAL
	depends on SMP
	default "4"
	help
	  The maximum number of CPUs that the kernel can support.
	  Up to 32 CPUs can be supported, or up to 16 if kmap_local()
	  debugging is enabled, which uses half of the per-CPU fixmap
	  slots as guard regions.

config HOTPLUG_CPU
	bool "Support for hot-pluggable CPUs"
	depends on SMP
	select GENERIC_IRQ_MIGRATION
	help
	  Say Y here to experiment with turning CPUs off and on.  CPUs
	  can be controlled through /sys/devices/system/cpu.

config ARM_PSCI
	bool "Support for the ARM Power State Coordination Interface (PSCI)"
	depends on HAVE_ARM_SMCCC
	select ARM_PSCI_FW
	help
	  Say Y here if you want Linux to communicate with system firmware
	  implementing the PSCI specification for CPU-centric power
	  management operations described in ARM document number ARM DEN
	  0022A ("Power State Coordination Interface System Software on
	  ARM processors").

config HZ_FIXED
	int
	default 128 if SOC_AT91RM9200
	default 0

choice
	depends on HZ_FIXED = 0
	prompt "Timer frequency"

config HZ_100
	bool "100 Hz"

config HZ_200
	bool "200 Hz"

config HZ_250
	bool "250 Hz"

config HZ_300
	bool "300 Hz"

config HZ_500
	bool "500 Hz"

config HZ_1000
	bool "1000 Hz"

endchoice

config HZ
	int
	default HZ_FIXED if HZ_FIXED != 0
	default 100 if HZ_100
	default 200 if HZ_200
	default 250 if HZ_250
	default 300 if HZ_300
	default 500 if HZ_500
	default 1000

config SCHED_HRTICK
	def_bool HIGH_RES_TIMERS

config THUMB2_KERNEL
	bool "Compile the kernel in Thumb-2 mode" if !CPU_THUMBONLY
	depends on (CPU_V7 || CPU_V7M) && !CPU_V6 && !CPU_V6K
	default y if CPU_THUMBONLY
	select ARM_UNWIND
	help
	  By enabling this option, the kernel will be compiled in
	  Thumb-2 mode.

	  If unsure, say N.

config ARM_PATCH_IDIV
	bool "Runtime patch udiv/sdiv instructions into __aeabi_{u}idiv()"
	depends on CPU_32v7
	default y
	help
	  The ARM compiler inserts calls to __aeabi_idiv() and
	  __aeabi_uidiv() when it needs to perform division on signed
	  and unsigned integers. Some v7 CPUs have support for the sdiv
	  and udiv instructions that can be used to implement those
	  functions.

	  Enabling this option allows the kernel to modify itself to
	  replace the first two instructions of these library functions
	  with the sdiv or udiv plus "bx lr" instructions when the CPU
	  it is running on supports them. Typically this will be faster
	  and less power intensive than running the original library
	  code to do integer division.

config AEABI
	bool "Use the ARM EABI to compile the kernel" if !CPU_V7 && \
		!CPU_V7M && !CPU_V6 && !CPU_V6K && !CC_IS_CLANG
	default CPU_V7 || CPU_V7M || CPU_V6 || CPU_V6K || CC_IS_CLANG
	help
	  This option allows for the kernel to be compiled using the latest
	  ARM ABI (aka EABI).  This is only useful if you are using a user
	  space environment that is also compiled with EABI.

	  Since there are major incompatibilities between the legacy ABI and
	  EABI, especially with regard to structure member alignment, this
	  option also changes the kernel syscall calling convention to
	  disambiguate both ABIs and allow for backward compatibility support
	  (selected with CONFIG_OABI_COMPAT).

	  To use this you need GCC version 4.0.0 or later.

config OABI_COMPAT
	bool "Allow old ABI binaries to run with this kernel (EXPERIMENTAL)"
	depends on AEABI && !THUMB2_KERNEL
	help
	  This option preserves the old syscall interface along with the
	  new (ARM EABI) one. It also provides a compatibility layer to
	  intercept syscalls that have structure arguments which layout
	  in memory differs between the legacy ABI and the new ARM EABI
	  (only for non "thumb" binaries). This option adds a tiny
	  overhead to all syscalls and produces a slightly larger kernel.

	  The seccomp filter system will not be available when this is
	  selected, since there is no way yet to sensibly distinguish
	  between calling conventions during filtering.

	  If you know you'll be using only pure EABI user space then you
	  can say N here. If this option is not selected and you attempt
	  to execute a legacy ABI binary then the result will be
	  UNPREDICTABLE (in fact it can be predicted that it won't work
	  at all). If in doubt say N.

config ARCH_SELECT_MEMORY_MODEL
	def_bool y

config ARCH_FLATMEM_ENABLE
	def_bool !(ARCH_RPC || ARCH_SA1100)

config ARCH_SPARSEMEM_ENABLE
	def_bool !ARCH_FOOTBRIDGE
	select SPARSEMEM_STATIC if SPARSEMEM

config HIGHMEM
	bool "High Memory Support"
	depends on MMU
	select KMAP_LOCAL
	select KMAP_LOCAL_NON_LINEAR_PTE_ARRAY
	help
	  The address space of ARM processors is only 4 Gigabytes large
	  and it has to accommodate user address space, kernel address
	  space as well as some memory mapped IO. That means that, if you
	  have a large amount of physical memory and/or IO, not all of the
	  memory can be "permanently mapped" by the kernel. The physical
	  memory that is not permanently mapped is called "high memory".

	  Depending on the selected kernel/user memory split, minimum
	  vmalloc space and actual amount of RAM, you may not need this
	  option which should result in a slightly faster kernel.

	  If unsure, say n.

config HIGHPTE
	bool "Allocate 2nd-level pagetables from highmem" if EXPERT
	depends on HIGHMEM
	default y
	help
	  The VM uses one page of physical memory for each page table.
	  For systems with a lot of processes, this can use a lot of
	  precious low memory, eventually leading to low memory being
	  consumed by page tables.  Setting this option will allow
	  user-space 2nd level page tables to reside in high memory.

config CPU_SW_DOMAIN_PAN
	bool "Enable use of CPU domains to implement privileged no-access"
	depends on MMU && !ARM_LPAE
	default y
	help
	  Increase kernel security by ensuring that normal kernel accesses
	  are unable to access userspace addresses.  This can help prevent
	  use-after-free bugs becoming an exploitable privilege escalation
	  by ensuring that magic values (such as LIST_POISON) will always
	  fault when dereferenced.

	  CPUs with low-vector mappings use a best-efforts implementation.
	  Their lower 1MB needs to remain accessible for the vectors, but
	  the remainder of userspace will become appropriately inaccessible.

config HW_PERF_EVENTS
	def_bool y
	depends on ARM_PMU

config ARM_MODULE_PLTS
	bool "Use PLTs to allow module memory to spill over into vmalloc area"
	depends on MODULES
	select KASAN_VMALLOC if KASAN
	default y
	help
	  Allocate PLTs when loading modules so that jumps and calls whose
	  targets are too far away for their relative offsets to be encoded
	  in the instructions themselves can be bounced via veneers in the
	  module's PLT. This allows modules to be allocated in the generic
	  vmalloc area after the dedicated module memory area has been
	  exhausted. The modules will use slightly more memory, but after
	  rounding up to page size, the actual memory footprint is usually
	  the same.

	  Disabling this is usually safe for small single-platform
	  configurations. If unsure, say y.

config ARCH_FORCE_MAX_ORDER
	int "Maximum zone order"
	default "12" if SOC_AM33XX
	default "9" if SA1111
	default "11"
	help
	  The kernel memory allocator divides physically contiguous memory
	  blocks into "zones", where each zone is a power of two number of
	  pages.  This option selects the largest power of two that the kernel
	  keeps in the memory allocator.  If you need to allocate very large
	  blocks of physically contiguous memory, then you may need to
	  increase this value.

	  This config option is actually maximum order plus one. For example,
	  a value of 11 means that the largest free memory block is 2^10 pages.

config ALIGNMENT_TRAP
	def_bool CPU_CP15_MMU
	select HAVE_PROC_CPU if PROC_FS
	help
	  ARM processors cannot fetch/store information which is not
	  naturally aligned on the bus, i.e., a 4 byte fetch must start at an
	  address divisible by 4. On 32-bit ARM processors, these non-aligned
	  fetch/store instructions will be emulated in software if you say
	  here, which has a severe performance impact. This is necessary for
	  correct operation of some network protocols. With an IP-only
	  configuration it is safe to say N, otherwise say Y.

config UACCESS_WITH_MEMCPY
	bool "Use kernel mem{cpy,set}() for {copy_to,clear}_user()"
	depends on MMU
	default y if CPU_FEROCEON
	help
	  Implement faster copy_to_user and clear_user methods for CPU
	  cores where a 8-word STM instruction give significantly higher
	  memory write throughput than a sequence of individual 32bit stores.

	  A possible side effect is a slight increase in scheduling latency
	  between threads sharing the same address space if they invoke
	  such copy operations with large buffers.

	  However, if the CPU data cache is using a write-allocate mode,
	  this option is unlikely to provide any performance gain.

config PARAVIRT
	bool "Enable paravirtualization code"
	help
	  This changes the kernel so it can modify itself when it is run
	  under a hypervisor, potentially improving performance significantly
	  over full virtualization.

config PARAVIRT_TIME_ACCOUNTING
	bool "Paravirtual steal time accounting"
	select PARAVIRT
	help
	  Select this option to enable fine granularity task steal time
	  accounting. Time spent executing other tasks in parallel with
	  the current vCPU is discounted from the vCPU power. To account for
	  that, there can be a small performance impact.

	  If in doubt, say N here.

config XEN_DOM0
	def_bool y
	depends on XEN

config XEN
	bool "Xen guest support on ARM"
	depends on ARM && AEABI && OF
	depends on CPU_V7 && !CPU_V6
	depends on !GENERIC_ATOMIC64
	depends on MMU
	select ARCH_DMA_ADDR_T_64BIT
	select ARM_PSCI
	select SWIOTLB
	select SWIOTLB_XEN
	select PARAVIRT
	help
	  Say Y if you want to run Linux in a Virtual Machine on Xen on ARM.

config CC_HAVE_STACKPROTECTOR_TLS
	def_bool $(cc-option,-mtp=cp15 -mstack-protector-guard=tls -mstack-protector-guard-offset=0)

config STACKPROTECTOR_PER_TASK
	bool "Use a unique stack canary value for each task"
	depends on STACKPROTECTOR && CURRENT_POINTER_IN_TPIDRURO && !XIP_DEFLATED_DATA
	depends on GCC_PLUGINS || CC_HAVE_STACKPROTECTOR_TLS
	select GCC_PLUGIN_ARM_SSP_PER_TASK if !CC_HAVE_STACKPROTECTOR_TLS
	default y
	help
	  Due to the fact that GCC uses an ordinary symbol reference from
	  which to load the value of the stack canary, this value can only
	  change at reboot time on SMP systems, and all tasks running in the
	  kernel's address space are forced to use the same canary value for
	  the entire duration that the system is up.

	  Enable this option to switch to a different method that uses a
	  different canary value for each task.

endmenu

menu "Boot options"

config USE_OF
	bool "Flattened Device Tree support"
	select IRQ_DOMAIN
	select OF
	help
	  Include support for flattened device tree machine descriptions.

config ATAGS
	bool "Support for the traditional ATAGS boot data passing"
	default y
	help
	  This is the traditional way of passing data to the kernel at boot
	  time. If you are solely relying on the flattened device tree (or
	  the ARM_ATAG_DTB_COMPAT option) then you may unselect this option
	  to remove ATAGS support from your kernel binary.

config DEPRECATED_PARAM_STRUCT
	bool "Provide old way to pass kernel parameters"
	depends on ATAGS
	help
	  This was deprecated in 2001 and announced to live on for 5 years.
	  Some old boot loaders still use this way.

# Compressed boot loader in ROM.  Yes, we really want to ask about
# TEXT and BSS so we preserve their values in the config files.
config ZBOOT_ROM_TEXT
	hex "Compressed ROM boot loader base address"
	default 0x0
	help
	  The physical address at which the ROM-able zImage is to be
	  placed in the target.  Platforms which normally make use of
	  ROM-able zImage formats normally set this to a suitable
	  value in their defconfig file.

	  If ZBOOT_ROM is not enabled, this has no effect.

config ZBOOT_ROM_BSS
	hex "Compressed ROM boot loader BSS address"
	default 0x0
	help
	  The base address of an area of read/write memory in the target
	  for the ROM-able zImage which must be available while the
	  decompressor is running. It must be large enough to hold the
	  entire decompressed kernel plus an additional 128 KiB.
	  Platforms which normally make use of ROM-able zImage formats
	  normally set this to a suitable value in their defconfig file.

	  If ZBOOT_ROM is not enabled, this has no effect.

config ZBOOT_ROM
	bool "Compressed boot loader in ROM/flash"
	depends on ZBOOT_ROM_TEXT != ZBOOT_ROM_BSS
	depends on !ARM_APPENDED_DTB && !XIP_KERNEL && !AUTO_ZRELADDR
	help
	  Say Y here if you intend to execute your compressed kernel image
	  (zImage) directly from ROM or flash.  If unsure, say N.

config ARM_APPENDED_DTB
	bool "Use appended device tree blob to zImage (EXPERIMENTAL)"
	depends on OF
	help
	  With this option, the boot code will look for a device tree binary
	  (DTB) appended to zImage
	  (e.g. cat zImage <filename>.dtb > zImage_w_dtb).

	  This is meant as a backward compatibility convenience for those
	  systems with a bootloader that can't be upgraded to accommodate
	  the documented boot protocol using a device tree.

	  Beware that there is very little in terms of protection against
	  this option being confused by leftover garbage in memory that might
	  look like a DTB header after a reboot if no actual DTB is appended
	  to zImage.  Do not leave this option active in a production kernel
	  if you don't intend to always append a DTB.  Proper passing of the
	  location into r2 of a bootloader provided DTB is always preferable
	  to this option.

config ARM_ATAG_DTB_COMPAT
	bool "Supplement the appended DTB with traditional ATAG information"
	depends on ARM_APPENDED_DTB
	help
	  Some old bootloaders can't be updated to a DTB capable one, yet
	  they provide ATAGs with memory configuration, the ramdisk address,
	  the kernel cmdline string, etc.  Such information is dynamically
	  provided by the bootloader and can't always be stored in a static
	  DTB.  To allow a device tree enabled kernel to be used with such
	  bootloaders, this option allows zImage to extract the information
	  from the ATAG list and store it at run time into the appended DTB.

choice
	prompt "Kernel command line type" if ARM_ATAG_DTB_COMPAT
	default ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER

config ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER
	bool "Use bootloader kernel arguments if available"
	help
	  Uses the command-line options passed by the boot loader instead of
	  the device tree bootargs property. If the boot loader doesn't provide
	  any, the device tree bootargs property will be used.

config ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND
	bool "Extend with bootloader kernel arguments"
	help
	  The command-line arguments provided by the boot loader will be
	  appended to the the device tree bootargs property.

endchoice

config CMDLINE
	string "Default kernel command string"
	default ""
	help
	  On some architectures (e.g. CATS), there is currently no way
	  for the boot loader to pass arguments to the kernel. For these
	  architectures, you should supply some command-line options at build
	  time by entering them here. As a minimum, you should specify the
	  memory size and the root device (e.g., mem=64M root=/dev/nfs).

choice
	prompt "Kernel command line type" if CMDLINE != ""
	default CMDLINE_FROM_BOOTLOADER

config CMDLINE_FROM_BOOTLOADER
	bool "Use bootloader kernel arguments if available"
	help
	  Uses the command-line options passed by the boot loader. If
	  the boot loader doesn't provide any, the default kernel command
	  string provided in CMDLINE will be used.

config CMDLINE_EXTEND
	bool "Extend bootloader kernel arguments"
	help
	  The command-line arguments provided by the boot loader will be
	  appended to the default kernel command string.

config CMDLINE_FORCE
	bool "Always use the default kernel command string"
	help
	  Always use the default kernel command string, even if the boot
	  loader passes other arguments to the kernel.
	  This is useful if you cannot or don't want to change the
	  command-line options your boot loader passes to the kernel.
endchoice

config XIP_KERNEL
	bool "Kernel Execute-In-Place from ROM"
	depends on !ARM_LPAE && !ARCH_MULTIPLATFORM
	depends on !ARM_PATCH_IDIV && !ARM_PATCH_PHYS_VIRT && !SMP_ON_UP
	help
	  Execute-In-Place allows the kernel to run from non-volatile storage
	  directly addressable by the CPU, such as NOR flash. This saves RAM
	  space since the text section of the kernel is not loaded from flash
	  to RAM.  Read-write sections, such as the data section and stack,
	  are still copied to RAM.  The XIP kernel is not compressed since
	  it has to run directly from flash, so it will take more space to
	  store it.  The flash address used to link the kernel object files,
	  and for storing it, is configuration dependent. Therefore, if you
	  say Y here, you must know the proper physical address where to
	  store the kernel image depending on your own flash memory usage.

	  Also note that the make target becomes "make xipImage" rather than
	  "make zImage" or "make Image".  The final kernel binary to put in
	  ROM memory will be arch/arm/boot/xipImage.

	  If unsure, say N.

config XIP_PHYS_ADDR
	hex "XIP Kernel Physical Location"
	depends on XIP_KERNEL
	default "0x00080000"
	help
	  This is the physical address in your flash memory the kernel will
	  be linked for and stored to.  This address is dependent on your
	  own flash usage.

config XIP_DEFLATED_DATA
	bool "Store kernel .data section compressed in ROM"
	depends on XIP_KERNEL
	select ZLIB_INFLATE
	help
	  Before the kernel is actually executed, its .data section has to be
	  copied to RAM from ROM. This option allows for storing that data
	  in compressed form and decompressed to RAM rather than merely being
	  copied, saving some precious ROM space. A possible drawback is a
	  slightly longer boot delay.

config KEXEC
	bool "Kexec system call (EXPERIMENTAL)"
	depends on (!SMP || PM_SLEEP_SMP)
	depends on MMU
	select KEXEC_CORE
	help
	  kexec is a system call that implements the ability to shutdown your
	  current kernel, and to start another kernel.  It is like a reboot
	  but it is independent of the system firmware.   And like a reboot
	  you can start any kernel with it, not just Linux.

	  It is an ongoing process to be certain the hardware in a machine
	  is properly shutdown, so do not be surprised if this code does not
	  initially work for you.

config ATAGS_PROC
	bool "Export atags in procfs"
	depends on ATAGS && KEXEC
	default y
	help
	  Should the atags used to boot the kernel be exported in an "atags"
	  file in procfs. Useful with kexec.

config CRASH_DUMP
	bool "Build kdump crash kernel (EXPERIMENTAL)"
	help
	  Generate crash dump after being started by kexec. This should
	  be normally only set in special crash dump kernels which are
	  loaded in the main kernel with kexec-tools into a specially
	  reserved region and then later executed after a crash by
	  kdump/kexec. The crash dump kernel must be compiled to a
	  memory address not used by the main kernel

	  For more details see Documentation/admin-guide/kdump/kdump.rst

config AUTO_ZRELADDR
	bool "Auto calculation of the decompressed kernel image address" if !ARCH_MULTIPLATFORM
	default !(ARCH_FOOTBRIDGE || ARCH_RPC || ARCH_SA1100)
	help
	  ZRELADDR is the physical address where the decompressed kernel
	  image will be placed. If AUTO_ZRELADDR is selected, the address
	  will be determined at run-time, either by masking the current IP
	  with 0xf8000000, or, if invalid, from the DTB passed in r2.
	  This assumes the zImage being placed in the first 128MB from
	  start of memory.

config EFI_STUB
	bool

config EFI
	bool "UEFI runtime support"
	depends on OF && !CPU_BIG_ENDIAN && MMU && AUTO_ZRELADDR && !XIP_KERNEL
	select UCS2_STRING
	select EFI_PARAMS_FROM_FDT
	select EFI_STUB
	select EFI_GENERIC_STUB
	select EFI_RUNTIME_WRAPPERS
	help
	  This option provides support for runtime services provided
	  by UEFI firmware (such as non-volatile variables, realtime
	  clock, and platform reset). A UEFI stub is also provided to
	  allow the kernel to be booted as an EFI application. This
	  is only useful for kernels that may run on systems that have
	  UEFI firmware.

config DMI
	bool "Enable support for SMBIOS (DMI) tables"
	depends on EFI
	default y
	help
	  This enables SMBIOS/DMI feature for systems.

	  This option is only useful on systems that have UEFI firmware.
	  However, even with this option, the resultant kernel should
	  continue to boot on existing non-UEFI platforms.

	  NOTE: This does *NOT* enable or encourage the use of DMI quirks,
	  i.e., the the practice of identifying the platform via DMI to
	  decide whether certain workarounds for buggy hardware and/or
	  firmware need to be enabled. This would require the DMI subsystem
	  to be enabled much earlier than we do on ARM, which is non-trivial.

endmenu

menu "CPU Power Management"

source "drivers/cpufreq/Kconfig"

source "drivers/cpuidle/Kconfig"

endmenu

menu "Floating point emulation"

comment "At least one emulation must be selected"

config FPE_NWFPE
	bool "NWFPE math emulation"
	depends on (!AEABI || OABI_COMPAT) && !THUMB2_KERNEL
	help
	  Say Y to include the NWFPE floating point emulator in the kernel.
	  This is necessary to run most binaries. Linux does not currently
	  support floating point hardware so you need to say Y here even if
	  your machine has an FPA or floating point co-processor podule.

	  You may say N here if you are going to load the Acorn FPEmulator
	  early in the bootup.

config FPE_NWFPE_XP
	bool "Support extended precision"
	depends on FPE_NWFPE
	help
	  Say Y to include 80-bit support in the kernel floating-point
	  emulator.  Otherwise, only 32 and 64-bit support is compiled in.
	  Note that gcc does not generate 80-bit operations by default,
	  so in most cases this option only enlarges the size of the
	  floating point emulator without any good reason.

	  You almost surely want to say N here.

config FPE_FASTFPE
	bool "FastFPE math emulation (EXPERIMENTAL)"
	depends on (!AEABI || OABI_COMPAT) && !CPU_32v3
	help
	  Say Y here to include the FAST floating point emulator in the kernel.
	  This is an experimental much faster emulator which now also has full
	  precision for the mantissa.  It does not support any exceptions.
	  It is very simple, and approximately 3-6 times faster than NWFPE.

	  It should be sufficient for most programs.  It may be not suitable
	  for scientific calculations, but you have to check this for yourself.
	  If you do not feel you need a faster FP emulation you should better
	  choose NWFPE.

config VFP
	bool "VFP-format floating point maths"
	depends on CPU_V6 || CPU_V6K || CPU_ARM926T || CPU_V7 || CPU_FEROCEON
	help
	  Say Y to include VFP support code in the kernel. This is needed
	  if your hardware includes a VFP unit.

	  Please see <file:Documentation/arm/vfp/release-notes.rst> for
	  release notes and additional status information.

	  Say N if your target does not have VFP hardware.

config VFPv3
	bool
	depends on VFP
	default y if CPU_V7

config NEON
	bool "Advanced SIMD (NEON) Extension support"
	depends on VFPv3 && CPU_V7
	help
	  Say Y to include support code for NEON, the ARMv7 Advanced SIMD
	  Extension.

config KERNEL_MODE_NEON
	bool "Support for NEON in kernel mode"
	depends on NEON && AEABI
	help
	  Say Y to include support for NEON in kernel mode.

endmenu

menu "Power management options"

source "kernel/power/Kconfig"

config ARCH_SUSPEND_POSSIBLE
	depends on CPU_ARM920T || CPU_ARM926T || CPU_FEROCEON || CPU_SA1100 || \
		CPU_V6 || CPU_V6K || CPU_V7 || CPU_V7M || CPU_XSC3 || CPU_XSCALE || CPU_MOHAWK
	def_bool y

config ARM_CPU_SUSPEND
	def_bool PM_SLEEP || BL_SWITCHER || ARM_PSCI_FW
	depends on ARCH_SUSPEND_POSSIBLE

config ARCH_HIBERNATION_POSSIBLE
	bool
	depends on MMU
	default y if ARCH_SUSPEND_POSSIBLE

endmenu

source "arch/arm/Kconfig.assembler"
