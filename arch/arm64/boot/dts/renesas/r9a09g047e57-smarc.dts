// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
/*
 * Device Tree Source for the RZ/G3E SMARC EVK board
 *
 * Copyright (C) 2024 Renesas Electronics Corp.
 */

/dts-v1/;

/* Switch selection settings */
#define SW_GPIO8_CAN0_STB	0
#define SW_GPIO9_CAN1_STB	0
#define SW_LCD_EN		0
#define SW_PDM_EN		0
#define SW_SER0_PMOD		1
#define SW_SER2_EN		1
#define SW_SD0_DEV_SEL		0
#define SW_SDIO_M2E		0

#define PMOD_GPIO4		0
#define PMOD_GPIO6		0
#define PMOD_GPIO7		0

#define KEY_1_GPIO		RZG3E_GPIO(3, 1)
#define KEY_2_GPIO		RZG3E_GPIO(8, 4)
#define KEY_3_GPIO		RZG3E_GPIO(8, 5)

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/input/input.h>
#include <dt-bindings/pinctrl/renesas,r9a09g047-pinctrl.h>
#include "r9a09g047e57.dtsi"
#include "rzg3e-smarc-som.dtsi"
#include "renesas-smarc2.dtsi"

/ {
	model = "Renesas SMARC EVK version 2 based on r9a09g047e57";
	compatible = "renesas,smarc2-evk", "renesas,rzg3e-smarcm",
		     "renesas,r9a09g047e57", "renesas,r9a09g047";

	aliases {
		i2c0 = &i2c0;
		serial0 = &rsci4;
		serial1 = &rsci9;
		serial2 = &rsci2;
		serial3 = &scif0;
		mmc1 = &sdhi1;
	};

	vqmmc_sd1_pvdd: regulator-vqmmc-sd1-pvdd {
		compatible = "regulator-gpio";
		regulator-name = "SD1_PVDD";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <3300000>;
		gpios = <&pinctrl RZG3E_GPIO(1, 5) GPIO_ACTIVE_HIGH>;
		gpios-states = <0>;
		states = <3300000 0>, <1800000 1>;
	};
};

&canfd {
	pinctrl-0 = <&canfd_pins>;
	pinctrl-names = "default";

#if (!SW_PDM_EN)
	channel1 {
		status = "okay";
#if (!SW_LCD_EN) && (SW_GPIO9_CAN1_STB)
		phys = <&can_transceiver1>;
#endif
	};
#endif

#if (!SW_LCD_EN)
	channel4 {
		status = "okay";
#if (SW_GPIO8_CAN0_STB)
		phys = <&can_transceiver0>;
#endif
	};
#endif
};

#if (!SW_LCD_EN) && (SW_GPIO8_CAN0_STB)
&can_transceiver0 {
	standby-gpios = <&pinctrl RZG3E_GPIO(5, 4) GPIO_ACTIVE_HIGH>;
	status = "okay";
};
#endif

#if (!SW_LCD_EN) && (SW_GPIO9_CAN1_STB)
&can_transceiver1 {
	standby-gpios = <&pinctrl RZG3E_GPIO(5, 5) GPIO_ACTIVE_HIGH>;
	status = "okay";
};
#endif

&i2c0 {
	pinctrl-0 = <&i2c0_pins>;
	pinctrl-names = "default";
};

&keys {
	pinctrl-0 = <&nmi_pins>;
	pinctrl-names = "default";

	key-sleep {
		interrupts-extended = <&icu 0 IRQ_TYPE_EDGE_FALLING>;
		linux,code = <KEY_SLEEP>;
		label = "SLEEP";
		debounce-interval = <20>;
	};
#if PMOD_GPIO4
	/delete-node/ key-1;
#endif

#if SW_LCD_EN || PMOD_GPIO6
	/delete-node/ key-2;
#endif

#if SW_LCD_EN || PMOD_GPIO7
	/delete-node/ key-3;
#endif
};

&pinctrl {
	canfd_pins: canfd {
		can1_pins: can1 {
			pinmux = <RZG3E_PORT_PINMUX(L, 2, 3)>, /* RX */
				 <RZG3E_PORT_PINMUX(L, 3, 3)>; /* TX */
		};

		can4_pins: can4 {
			pinmux = <RZG3E_PORT_PINMUX(5, 2, 3)>, /* RX */
				 <RZG3E_PORT_PINMUX(5, 3, 3)>; /* TX */
		};
	};

	i2c0_pins: i2c0 {
		pinmux = <RZG3E_PORT_PINMUX(D, 4, 4)>, /* SCL0 */
			 <RZG3E_PORT_PINMUX(D, 5, 4)>; /* SDA0 */
	};

	nmi_pins: nmi {
		pinmux = <RZG3E_PORT_PINMUX(S, 0, 0)>; /* NMI */
		input-schmitt-enable;
	};

	rsci2_pins: rsci2 {
		pinmux = <RZG3E_PORT_PINMUX(1, 0, 1)>, /* RXD2 */
			 <RZG3E_PORT_PINMUX(1, 1, 1)>, /* TXD2 */
			 <RZG3E_PORT_PINMUX(1, 2, 6)>, /* CTS2N */
			 <RZG3E_PORT_PINMUX(1, 3, 1)>; /* RTS2N */
		bias-pull-up;
	};

	rsci4_pins: rsci4 {
		pinmux = <RZG3E_PORT_PINMUX(7, 6, 5)>, /* RXD4 */
			 <RZG3E_PORT_PINMUX(7, 7, 5)>, /* TXD4 */
			 <RZG3E_PORT_PINMUX(8, 0, 6)>, /* CTS4N */
			 <RZG3E_PORT_PINMUX(8, 1, 5)>; /* RTS4N */
		bias-pull-up;
	};

	rsci9_pins: rsci9 {
		pinmux = <RZG3E_PORT_PINMUX(8, 2, 5)>, /* RXD9 */
			 <RZG3E_PORT_PINMUX(8, 3, 5)>; /* TXD9 */
		bias-pull-up;
	};

	scif_pins: scif {
		pins = "SCIF_TXD", "SCIF_RXD";
		renesas,output-impedance = <1>;
	};

	sd1-pwr-en-hog {
		gpio-hog;
		gpios = <RZG3E_GPIO(1, 6) GPIO_ACTIVE_HIGH>;
		output-high;
		line-name = "sd1_pwr_en";
	};

	sdhi1_pins: sd1 {
		sd1-cd {
			pinmux = <RZG3E_PORT_PINMUX(1, 4, 8)>; /* SD1CD */
		};

		sd1-ctrl {
			pinmux = <RZG3E_PORT_PINMUX(G, 0, 1)>, /* SD1CLK */
				 <RZG3E_PORT_PINMUX(G, 1, 1)>; /* SD1CMD */
		};

		sd1-data {
			pinmux = <RZG3E_PORT_PINMUX(G, 2, 1)>, /* SD1DAT0 */
				 <RZG3E_PORT_PINMUX(G, 3, 1)>, /* SD1DAT1 */
				 <RZG3E_PORT_PINMUX(G, 4, 1)>, /* SD1DAT2 */
				 <RZG3E_PORT_PINMUX(G, 5, 1)>; /* SD1DAT3 */
		};
	};

	usb3_pins: usb3 {
		pinmux = <RZG3E_PORT_PINMUX(4, 1, 12)>, /* USB30_VBUSEN */
			 <RZG3E_PORT_PINMUX(4, 0, 12)>; /* USB30_OVRCURN */
	};
};

#if SW_SER0_PMOD && SW_SER2_EN
&rsci2 {
	pinctrl-0 = <&rsci2_pins>;
	pinctrl-names = "default";

	uart-has-rtscts;

	status = "okay";
};
#endif

#if (!SW_LCD_EN) && (SW_SER0_PMOD)
&rsci4 {
	pinctrl-0 = <&rsci4_pins>;
	pinctrl-names = "default";

	uart-has-rtscts;

	status = "okay";
};
#endif

#if (!SW_LCD_EN)
&rsci9 {
	pinctrl-0 = <&rsci9_pins>;
	pinctrl-names = "default";

	status = "okay";
};
#endif

&scif0 {
	pinctrl-0 = <&scif_pins>;
	pinctrl-names = "default";
};

&sdhi1 {
	pinctrl-0 = <&sdhi1_pins>;
	pinctrl-1 = <&sdhi1_pins>;
	pinctrl-names = "default", "state_uhs";

	vmmc-supply = <&reg_3p3v>;
	vqmmc-supply = <&vqmmc_sd1_pvdd>;
};

&xhci {
	pinctrl-0 = <&usb3_pins>;
	pinctrl-names = "default";
};
