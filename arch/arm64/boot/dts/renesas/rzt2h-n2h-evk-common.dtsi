// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
/*
 * Common Device Tree Source for the RZ/T2H and RZ/N2H EVK boards.
 *
 * Copyright (C) 2025 Renesas Electronics Corp.
 */

#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/leds/common.h>
#include <dt-bindings/net/mscc-phy-vsc8531.h>
#include <dt-bindings/net/renesas,r9a09g077-pcs-miic.h>
#include <dt-bindings/pinctrl/renesas,r9a09g077-pinctrl.h>

/ {
	aliases {
		ethernet3 = &gmac1;
		ethernet2 = &gmac2;
		i2c0 = &i2c0;
		i2c1 = &i2c1;
		mmc0 = &sdhi0;
		mmc1 = &sdhi1;
		serial0 = &sci0;
	};

	chosen {
		stdout-path = "serial0:115200n8";
	};

	reg_1p8v: regulator-1p8v {
		compatible = "regulator-fixed";
		regulator-name = "fixed-1.8V";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <1800000>;
		regulator-boot-on;
		regulator-always-on;
	};

	reg_3p3v: regulator-3p3v {
		compatible = "regulator-fixed";
		regulator-name = "fixed-3.3V";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-boot-on;
		regulator-always-on;
	};

#if SD0_SD
	vqmmc_sdhi0: regulator-vqmmc-sdhi0 {
		compatible = "regulator-gpio";
		regulator-name = "SDHI0 VqmmC";
		gpios = <&pinctrl RZT2H_GPIO(2, 6) GPIO_ACTIVE_HIGH>;
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <3300000>;
		gpios-states = <0>;
		states = <3300000 0>, <1800000 1>;
	};
#endif

#if SD1_MICRO_SD
	vccq_sdhi1: regulator-vccq-sdhi1 {
		compatible = "regulator-gpio";
		regulator-name = "SDHI1 VccQ";
		regulator-min-microvolt = <1800000>;
		regulator-max-microvolt = <3300000>;
		gpios = <&pinctrl RZT2H_GPIO(8, 6) GPIO_ACTIVE_HIGH>;
		gpios-states = <0>;
		states = <3300000 0>, <1800000 1>;
	};
#endif
};

&ehci {
	dr_mode = "otg";
	status = "okay";
};

&ethss {
	status = "okay";

	renesas,miic-switch-portin = <ETHSS_GMAC0_PORT>;
};

&extal_clk {
	clock-frequency = <25000000>;
};

&gmac1 {
	pinctrl-0 = <&gmac1_pins>;
	pinctrl-names = "default";
	phy-handle = <&mdio1_phy>;
	phy-mode = "rgmii-id";
	pcs-handle = <&mii_conv3>;
	status = "okay";
};

&gmac2 {
	pinctrl-0 = <&gmac2_pins>;
	pinctrl-names = "default";
	phy-handle = <&mdio2_phy>;
	phy-mode = "rgmii-id";
	pcs-handle = <&mii_conv2>;
	status = "okay";
};

&hsusb {
	dr_mode = "otg";
	status = "okay";
};

&i2c0 {
	eeprom: eeprom@50 {
		compatible = "renesas,r1ex24016", "atmel,24c16";
		reg = <0x50>;
		pagesize = <16>;
	};
};

&mdio1 {
	mdio1_phy: ethernet-phy@3 {
		compatible = "ethernet-phy-id0007.0772", "ethernet-phy-ieee802.3-c22";
		reg = <3>;
		vsc8531,led-0-mode = <VSC8531_ACTIVITY>;
		vsc8531,led-1-mode = <VSC8531_LINK_ACTIVITY>;
		reset-assert-us = <2000>;
		reset-deassert-us = <15000>;
	};
};

&mdio2 {
	mdio2_phy: ethernet-phy@2 {
		compatible = "ethernet-phy-id0007.0772", "ethernet-phy-ieee802.3-c22";
		reg = <2>;
		vsc8531,led-0-mode = <VSC8531_ACTIVITY>;
		vsc8531,led-1-mode = <VSC8531_LINK_ACTIVITY>;
		reset-assert-us = <2000>;
		reset-deassert-us = <15000>;
	};
};

&mii_conv0 {
	renesas,miic-input = <ETHSS_ETHSW_PORT0>;
	status = "okay";
};

&mii_conv1 {
	renesas,miic-input = <ETHSS_ETHSW_PORT1>;
	status = "okay";
};

&mii_conv2 {
	renesas,miic-input = <ETHSS_GMAC2_PORT>;
	status = "okay";
};

&mii_conv3 {
	renesas,miic-input = <ETHSS_GMAC1_PORT>;
	status = "okay";
};

&ohci {
	dr_mode = "otg";
	status = "okay";
};

&pinctrl {
	/*
	 * SCI0 Pin Configuration:
	 * ------------------------
	 * Signal     | Pin     | RZ/T2H (SW4) | RZ/N2H (DSW9)
	 * -----------|---------|--------------|---------------
	 * SCI0_RXD   | P27_4   | 5: ON, 6: OFF| 1: ON, 2: OFF
	 * SCI0_TXD   | P27_5   | 7: ON, 8: OFF| 3: ON, 4: OFF
	 */
	sci0_pins: sci0-pins {
		pinmux = <RZT2H_PORT_PINMUX(27, 4, 0x14)>,
			 <RZT2H_PORT_PINMUX(27, 5, 0x14)>;
	};

#if SD0_EMMC
	sdhi0-emmc-iovs-hog {
		gpio-hog;
		gpios = <RZT2H_GPIO(2, 6) GPIO_ACTIVE_HIGH>;
		output-high;
		line-name = "SD0_IOVS";
	};
#endif

	sdhi0_emmc_pins: sd0-emmc-group {
		data-pins {
			pinmux = <RZT2H_PORT_PINMUX(12, 2, 0x29)>, /* SD0_DATA0 */
				 <RZT2H_PORT_PINMUX(12, 3, 0x29)>, /* SD0_DATA1 */
				 <RZT2H_PORT_PINMUX(12, 4, 0x29)>, /* SD0_DATA2 */
				 <RZT2H_PORT_PINMUX(12, 5, 0x29)>, /* SD0_DATA3 */
				 <RZT2H_PORT_PINMUX(12, 6, 0x29)>, /* SD0_DATA4 */
				 <RZT2H_PORT_PINMUX(12, 7, 0x29)>, /* SD0_DATA5 */
				 <RZT2H_PORT_PINMUX(13, 0, 0x29)>, /* SD0_DATA6 */
				 <RZT2H_PORT_PINMUX(13, 1, 0x29)>; /* SD0_DATA7 */
		};

		ctrl-pins {
			pinmux = <RZT2H_PORT_PINMUX(12, 0, 0x29)>, /* SD0_CLK */
				 <RZT2H_PORT_PINMUX(12, 1, 0x29)>, /* SD0_CMD */
				 <RZT2H_PORT_PINMUX(13, 2, 0x29)>; /* SD0_RST# */
		};
	};

#if SD0_SD
	sdhi0-pwen-hog {
		gpio-hog;
		gpios = <RZT2H_GPIO(2, 5) GPIO_ACTIVE_HIGH>;
		output-high;
		line-name = "SD0_PWEN";
	};
#endif

	sdhi0_sd_pins: sd0-sd-group {
		data-pins {
			pinmux = <RZT2H_PORT_PINMUX(12, 2, 0x29)>, /* SD0_DATA0 */
				 <RZT2H_PORT_PINMUX(12, 3, 0x29)>, /* SD0_DATA1 */
				 <RZT2H_PORT_PINMUX(12, 4, 0x29)>, /* SD0_DATA2 */
				 <RZT2H_PORT_PINMUX(12, 5, 0x29)>; /* SD0_DATA3 */
		};

		ctrl-pins {
			pinmux = <RZT2H_PORT_PINMUX(12, 0, 0x29)>, /* SD0_CLK */
				 <RZT2H_PORT_PINMUX(12, 1, 0x29)>, /* SD0_CMD */
				 <RZT2H_PORT_PINMUX(22, 5, 0x29)>, /* SD0_CD */
				 <RZT2H_PORT_PINMUX(22, 6, 0x29)>; /* SD0_WP */
		};
	};

#if SD1_MICRO_SD
	sdhi1-pwen-hog {
		gpio-hog;
		gpios = <RZT2H_GPIO(8, 5) GPIO_ACTIVE_HIGH>;
		output-high;
		line-name = "SD1_PWEN";
	};
#endif

	sdhi1_pins: sd1-group {
		data-pins {
			pinmux = <RZT2H_PORT_PINMUX(16, 7, 0x29)>, /* SD1_DATA0 */
				 <RZT2H_PORT_PINMUX(17, 0, 0x29)>, /* SD1_DATA1 */
				 <RZT2H_PORT_PINMUX(17, 1, 0x29)>, /* SD1_DATA2 */
				 <RZT2H_PORT_PINMUX(17, 2, 0x29)>; /* SD1_DATA3 */
		};

		ctrl-pins {
			pinmux = <RZT2H_PORT_PINMUX(16, 5, 0x29)>, /* SD1_CLK */
				 <RZT2H_PORT_PINMUX(16, 6, 0x29)>, /* SD1_CMD */
				 <RZT2H_PORT_PINMUX(17, 4, 0x29)>; /* SD1_CD */
		};
	};
};

&sci0 {
	pinctrl-0 = <&sci0_pins>;
	pinctrl-names = "default";
	status = "okay";
};

#if SD0_EMMC
&sdhi0 {
	pinctrl-0 = <&sdhi0_emmc_pins>;
	pinctrl-1 = <&sdhi0_emmc_pins>;
	pinctrl-names = "default", "state_uhs";
	vmmc-supply = <&reg_3p3v>;
	vqmmc-supply = <&reg_1p8v>;
	bus-width = <8>;
	non-removable;
	mmc-hs200-1_8v;
	fixed-emmc-driver-type = <1>;
	status = "okay";
};
#endif

#if SD0_SD
&sdhi0 {
	pinctrl-0 = <&sdhi0_sd_pins>;
	pinctrl-1 = <&sdhi0_sd_pins>;
	pinctrl-names = "default", "state_uhs";
	vmmc-supply = <&reg_3p3v>;
	vqmmc-supply = <&vqmmc_sdhi0>;
	bus-width = <4>;
	sd-uhs-sdr50;
	sd-uhs-sdr104;
	status = "okay";
};
#endif

#if SD1_MICRO_SD
&sdhi1 {
	pinctrl-0 = <&sdhi1_pins>;
	pinctrl-1 = <&sdhi1_pins>;
	pinctrl-names = "default", "state_uhs";
	vmmc-supply = <&reg_3p3v>;
	vqmmc-supply = <&vccq_sdhi1>;
	bus-width = <4>;
	sd-uhs-sdr50;
	sd-uhs-sdr104;
	status = "okay";
};
#endif

&usb2_phy {
	pinctrl-0 = <&usb_pins>;
	pinctrl-names = "default";

	status = "okay";
};

&wdt2 {
	status = "okay";
	timeout-sec = <60>;
};

/*
 * ADC0 AN000 can be connected to a potentiometer on the board or
 * exposed on ADC header.
 *
 * T2H:
 * SW17[1] = ON, SW17[2] = OFF - Potentiometer
 * SW17[1] = OFF, SW17[2] = ON  - CN41 header
 * N2H:
 * DSW6[1] = OFF, DSW6[2] = ON - Potentiometer
 * DSW6[1] = ON, DSW6[2] = OFF - CN3 header
 */
&adc0 {
	status = "okay";

	channel@0 {
		reg = <0x0>;
	};

	channel@1 {
		reg = <0x1>;
	};

	channel@2 {
		reg = <0x2>;
	};

	channel@3 {
		reg = <0x3>;
	};
};

/*
 * ADC1 AN100 can be exposed on ADC header or on mikroBUS connector.
 *
 * T2H:
 * SW18[1] = ON, SW18[2] = OFF - CN42 header
 * SW18[1] = OFF, SW18[2] = ON - mikroBUS
 * N2H:
 * DSW6[3] = ON, DSW6[4] = OFF - CN4 header
 * DSW6[3] = OFF, DSW6[4] = ON - mikroBUS
 *
 * ADC1 AN101 can be exposed on ADC header or on Grove2 connector.
 *
 * T2H:
 * SW18[3] = ON, SW18[4] = OFF - CN42 header
 * SW18[3] = OFF, SW18[4] = ON - Grove2
 * N2H:
 * DSW6[5] = ON, DSW6[6] = OFF - CN4 header
 * DSW6[5] = OFF, DSW6[6] = ON - Grove2
 *
 * ADC1 AN102 can be exposed on ADC header or on Grove2 connector.
 *
 * T2H:
 * SW18[5] = ON, SW18[6] = OFF - CN42 header
 * SW18[5] = OFF, SW18[6] = ON - Grove2
 * N2H:
 * DSW6[7] = ON, DSW6[8] = OFF - CN4 header
 * DSW6[7] = OFF, DSW6[8] = ON - Grove2
 */
&adc1 {
	status = "okay";

	channel@0 {
		reg = <0x0>;
	};

	channel@1 {
		reg = <0x1>;
	};

	channel@2 {
		reg = <0x2>;
	};

	channel@3 {
		reg = <0x3>;
	};
};
